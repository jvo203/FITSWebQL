<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: xsample01.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">xsample01.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Demo and a benchmark on memory consumption control and logical operation</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Copyright(c) 2002-2017 Anatoliy Kuznetsov(anatoliy_kuznetsov at yahoo.com)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div><div class="line"><span class="comment">you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment">You may obtain a copy of the License at</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div><div class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment">See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment">limitations under the License.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">For more information please visit:  http://bitmagic.io</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/** \example xsample01.cpp</span></div><div class="line"><span class="comment">  Demo and a benchmark on memory consumption control and logical operation</span></div><div class="line"><span class="comment">*/</span><span class="comment"></span></div><div class="line"><span class="comment">/*! \file xsample01.cpp</span></div><div class="line"><span class="comment">    \brief Example: Example: memory consumption techniques</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bm_8h.html">bm.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmalgo_8h.html">bmalgo.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmtimer_8h.html">bmtimer.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmserial_8h.html">bmserial.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmsparsevec_8h.html">bmsparsevec.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmsparsevec__algo_8h.html">bmsparsevec_algo.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmsparsevec__serial_8h.html">bmsparsevec_serial.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmalgo__similarity_8h.html">bmalgo_similarity.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;bmdbg.h&quot;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ----------------------------------------------------</span></div><div class="line"><span class="comment">// Global parameters and types</span></div><div class="line"><span class="comment">// ----------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="comment">// Number of vectors generated for the test</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a0"></a><a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a> = 1000000;</div><div class="line"></div><div class="line"><span class="comment">// Dynamic range for constructed sets</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a1"></a><a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a> = 2000000;</div><div class="line"></div><div class="line"><span class="comment">// Number of bits per one vector</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a2"></a><a class="code" href="xsample01_8cpp.html#a7ed289822df3fbefde31901e32f9ae90">bits_per_vect</a> = 5;</div><div class="line"></div><div class="line"><span class="comment">// benchmark operation count</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a3"></a><a class="code" href="xsample01_8cpp.html#a368f2a2dfa759300fbe221aaa1550eea">benchmark_ops</a> = 1000;</div><div class="line"></div><div class="line"><span class="comment">// subset of vectors used as a sample</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a4"></a><a class="code" href="xsample01_8cpp.html#abd38d1f1700e2c6d58e040b54855892b">sample_cnt</a> = 250;</div><div class="line"></div><div class="line"><span class="comment">// index values to extract</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a name="a5"></a><a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a> = 200;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// bit-vector type for this example</span></div><div class="line"><span class="keyword">typedef</span>  <a name="_a6"></a><a class="code" href="classbm_1_1bvector.html">bm::bvector&lt;&gt;</a>   <a name="a7"></a><a class="code" href="xsample01_8cpp.html#a0a5d50c8eac9a301e438473ce1d60ce2">TBVector</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// timing storage for benchmarking</span></div><div class="line"><a class="code" href="classbm_1_1chrono__taker.html#add1676592117ed0eaa2fa6279a71b46a">bm::chrono_taker::duration_map_type</a>  <a name="a8"></a><a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* BitMagic provides two GAP length tables for situations when we have</span></div><div class="line"><span class="comment">   standard or embarassingly sparse vectors.</span></div><div class="line"><span class="comment">   bm::gap_len_table - default standard</span></div><div class="line"><span class="comment">   bm::gap_len_table_min - option for smaller vectors</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">   Here we define an alternative table for very sparse vectors</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a name="_a9"></a><a class="code" href="structgap__len__table__sparse.html">gap_len_table_sparse</a></div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> <a name="a10"></a><a class="code" href="structgap__len__table__sparse.html#a04da8308e3834d86f847de5690f09995">_len</a>[<a name="a11"></a><a class="code" href="namespacebm.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>];</div><div class="line">};</div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> <a class="code" href="structgap__len__table__sparse.html">gap_len_table_sparse&lt;T&gt;::_len</a>[<a class="code" href="namespacebm.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>] =</div><div class="line">                                    { 8, 32, 128, 512 };</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// simple bit-vector class factory for the project</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line">TBVector* <a name="a12"></a><a class="code" href="xsample01_8cpp.html#a40a2c867e052361386cad227606d3e6e">construct_bvector</a>()</div><div class="line">{</div><div class="line">    <span class="comment">// in this example we plan to keep lots of vectors in memory, thus</span></div><div class="line">    <span class="comment">// use parameters to minimize memory consumption</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    TBVector* bv =</div><div class="line">        <span class="keyword">new</span> <a class="code" href="xsample01_8cpp.html#a0a5d50c8eac9a301e438473ce1d60ce2">TBVector</a>(<a name="a13"></a><a class="code" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">bm::BM_GAP</a>,  <span class="comment">// use GAP compressed mode</span></div><div class="line">                     <a class="code" href="structgap__len__table__sparse.html">gap_len_table_sparse&lt;true&gt;::_len</a>, <span class="comment">// custom lens for super sparse vectors</span></div><div class="line">                     <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>  <span class="comment">// limit the maximum size</span></div><div class="line">                   );</div><div class="line">    <span class="keywordflow">return</span> bv;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic utility to destroy map of pointers</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TM&gt;</div><div class="line"><span class="keywordtype">void</span> <a name="a14"></a><a class="code" href="xsample01_8cpp.html#a962e38dd6386ffdec6f7500fa24ec60a">destroy_map</a>(TM&amp; id_map)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> TM::iterator it = id_map.begin();</div><div class="line">         it != id_map.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">typename</span> TM::mapped_type mp = it-&gt;second;</div><div class="line">        <span class="keyword">delete</span> mp;</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    id_map.clear();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ------------------------------------------------------------------</span></div><div class="line"><span class="comment">// Sample data structures</span></div><div class="line"><span class="comment">// ------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="comment">// Sample index structure to keep a map of in-memory bit-vectors</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a name="_a15"></a><a class="code" href="structbv__index.html">bv_index</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> std::map&lt;unsigned, TBVector*&gt; map_type;</div><div class="line">    ~<a class="code" href="structbv__index.html">bv_index</a>()</div><div class="line">    {</div><div class="line">        <a class="code" href="xsample01_8cpp.html#a962e38dd6386ffdec6f7500fa24ec60a">destroy_map</a>(idx_);</div><div class="line">    }</div><div class="line">    map_type  idx_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Sample index structure to keep map of in-memory serialized/compressed bit-vectors</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a name="_a16"></a><a class="code" href="structbvs__index.html">bvs_index</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;unsigned char&gt;           buffer_type;</div><div class="line">    <span class="keyword">typedef</span> std::map&lt;unsigned, buffer_type&gt;      map_type;</div><div class="line">    </div><div class="line">    map_type  idx_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Sample index structure to keep map of in-memory vector&lt;unsigned int&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a name="_a17"></a><a class="code" href="structvect__index.html">vect_index</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;unsigned int&gt;           buffer_type;</div><div class="line">    <span class="keyword">typedef</span> std::map&lt;unsigned, buffer_type&gt;     map_type;</div><div class="line">    </div><div class="line">    map_type  idx_;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Sample index structure as in-memory sparse_vector</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a name="_a18"></a><a class="code" href="structsparse__vect__index.html">sparse_vect_index</a></div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>vect_addr</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> offset;</div><div class="line">        <span class="keywordtype">unsigned</span> size;</div><div class="line">    };</div><div class="line">    </div><div class="line">    <span class="keyword">typedef</span> <a name="_a19"></a><a class="code" href="classbm_1_1sparse__vector.html">bm::sparse_vector&lt;unsigned, bm::bvector&lt;&gt;</a> &gt;   sparse_vector_type;</div><div class="line">    <span class="keyword">typedef</span> std::map&lt;unsigned, vect_addr&gt;                 map_type;</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt; std::pair&lt;uint64_t, unsigned&gt; &gt;  delta_sum_map_type;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> get_vector(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, std::vector&lt;unsigned&gt;&amp; vect) <span class="keyword">const</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    sparse_vector_type  sv_storage_;</div><div class="line">    sparse_vector_type  sv_storage1_;</div><div class="line">    map_type            idx_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a name="a20"></a><a class="code" href="structsparse__vect__index.html#ae07351c616badacff2fdba4e55d82dd4">sparse_vect_index::get_vector</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, std::vector&lt;unsigned&gt;&amp; vect)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    map_type::const_iterator it = idx_.find(<span class="keywordtype">id</span>);</div><div class="line">    <span class="keywordflow">if</span> (it != idx_.end())</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a name="_a21"></a><a class="code" href="structsparse__vect__index_1_1vect__addr.html">sparse_vect_index::vect_addr</a>&amp; vaddr = it-&gt;second;</div><div class="line">        vect.resize(vaddr.<a name="a22"></a><a class="code" href="structsparse__vect__index_1_1vect__addr.html#a8a64540446665e45a89f327289803a90">size</a>+1);</div><div class="line">        vect[0] = sv_storage1_.get(<span class="keywordtype">id</span>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 1; j &lt; vect.size(); ++j)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> a = sv_storage_.get(j + vaddr.<a name="a23"></a><a class="code" href="structsparse__vect__index_1_1vect__addr.html#ac6c9bf8d1cf409aa77d5afdb429e2242">offset</a> - 1);</div><div class="line">            a += (vect[j-1] + 1);</div><div class="line">            vect[j] = a;</div><div class="line">        } <span class="comment">// for j</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        vect.resize(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --------------------------------------------------------------------</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// set bits in a vector using various methods picked at random</span><span class="comment"></span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment"></span><span class="comment">// one method will generate a plato of non-random integers,</span></div><div class="line"><span class="comment">// another random integers of near neighbors</span></div><div class="line"><span class="comment">// the other adds ints randomly without following any system</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a24"></a><a class="code" href="xsample01_8cpp.html#a05ac61a248eabbd9df856b6308885d18">generate_random_vector</a>(TBVector* bv)</div><div class="line">{</div><div class="line">    <span class="keywordtype">unsigned</span> method = rand() % 5; <span class="comment">// pick a generation method</span></div><div class="line">    <span class="keywordflow">if</span> (method == 0) <span class="comment">// generate a incremental linear sequence at random location</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> seed_id = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = seed_id; i &lt; seed_id+<a class="code" href="xsample01_8cpp.html#a7ed289822df3fbefde31901e32f9ae90">bits_per_vect</a>; ++i)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (i &gt;= <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>)</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            bv-&gt;<a name="a25"></a><a class="code" href="classbm_1_1bvector.html#aecf79c2c05bda3445ade2e10b61066b7">set_bit</a>(i);</div><div class="line">        } <span class="comment">// for i</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">if</span> (method == 1) <span class="comment">// generate near neighbors</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> seed_id = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = seed_id;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a7ed289822df3fbefde31901e32f9ae90">bits_per_vect</a>; ++i)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>)</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            bv-&gt;<a class="code" href="classbm_1_1bvector.html#aecf79c2c05bda3445ade2e10b61066b7">set_bit</a>(<span class="keywordtype">id</span>);</div><div class="line">            <span class="keywordtype">id</span> += (rand() % 10);</div><div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>)</div><div class="line">                <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>;</div><div class="line">        } <span class="comment">// for i</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// generate completely random bits</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i  = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a7ed289822df3fbefde31901e32f9ae90">bits_per_vect</a>; ++i)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>;</div><div class="line">            <span class="keywordflow">if</span> (i &gt;= <a class="code" href="xsample01_8cpp.html#ae474e48ebc0bd005cbab08620edbc5fe">max_size</a>) <span class="comment">// paranoiya check</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            bv-&gt;<a class="code" href="classbm_1_1bvector.html#aecf79c2c05bda3445ade2e10b61066b7">set_bit</a>(<span class="keywordtype">id</span>);</div><div class="line">        } <span class="comment">// for i</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// generate map of bit-vectors, each filled with just a few bits</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a26"></a><a class="code" href="xsample01_8cpp.html#a14dd8e20549b8c10dc1eda35055f77ef">generate_bv_index</a>(<a class="code" href="structbv__index.html">bv_index</a>&amp; bvi)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a>; ++i)</div><div class="line">    {</div><div class="line">        std::auto_ptr&lt;TBVector&gt; ap(<a class="code" href="xsample01_8cpp.html#a40a2c867e052361386cad227606d3e6e">construct_bvector</a>());</div><div class="line">        </div><div class="line">        <a class="code" href="xsample01_8cpp.html#a05ac61a248eabbd9df856b6308885d18">generate_random_vector</a>(ap.get());</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!ap-&gt;any()) <span class="comment">// integrity check</span></div><div class="line">        {</div><div class="line">            <span class="comment">// this should never happen</span></div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Warning. Empty vector generated!&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        bvi.<a name="a27"></a><a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>[i] = ap.release();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// calculate memory footprint for in memory index</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">size_t</span> <a name="a28"></a><a class="code" href="xsample01_8cpp.html#a86e1ced56a418a49ba4ee5cf711a8ab8">calc_memory_footprint</a>(<span class="keyword">const</span> <a class="code" href="structbv__index.html">bv_index</a>&amp; bvi)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span> mem_total = 0;</div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> TBVector* mp = it-&gt;second;</div><div class="line">        </div><div class="line">        <a name="_a29"></a><a class="code" href="structbm_1_1bvector_1_1statistics.html">TBVector::statistics</a> st;</div><div class="line">        mp-&gt;<a name="a30"></a><a class="code" href="classbm_1_1bvector.html#a984a4f43724ebd9d840a36a3aa0eacca">calc_stat</a>(&amp;st);</div><div class="line">        mem_total += st.<a name="a31"></a><a class="code" href="structbm_1_1bv__statistics.html#aeb3cae5be872eed7fbe4191a8d710e42">memory_used</a>;</div><div class="line">        </div><div class="line">        mem_total += <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*);</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> mem_total;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// convert bit-vector index to bit-vector serialized index</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">size_t</span> <a name="a32"></a><a class="code" href="xsample01_8cpp.html#a94c49211e6bc6f94107a0a829efc79e0">convert_bv2bvs</a>(<span class="keyword">const</span> <a class="code" href="structbv__index.html">bv_index</a>&amp; bvi, <a class="code" href="structbvs__index.html">bvs_index</a>&amp; bvs)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span>  mem_total = 0;</div><div class="line">    std::vector&lt;unsigned char&gt; buf;      <span class="comment">// prepare a temporary buffer</span></div><div class="line">    buf.reserve(1024);</div><div class="line"></div><div class="line">    <span class="comment">// bit-vector serializer</span></div><div class="line">    <span class="comment">// (keep it out of the serialization loop to minimize buffers re-allocations)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a name="_a33"></a><a class="code" href="classbm_1_1serializer.html">bm::serializer&lt;TBVector&gt;</a> bvsr;</div><div class="line">    bvsr.<a name="a34"></a><a class="code" href="classbm_1_1serializer.html#a892b124d42bb939485e47d197b8dc1ac">byte_order_serialization</a>(<span class="keyword">false</span>);</div><div class="line">    bvsr.<a name="a35"></a><a class="code" href="classbm_1_1serializer.html#a5b19026c2e928c639f09da4a4e1235ab">gap_length_serialization</a>(<span class="keyword">false</span>);</div><div class="line">    bvsr.<a name="a36"></a><a class="code" href="classbm_1_1serializer.html#ad433d790f07103d39c5f15a6caaf2823">set_compression_level</a>(4);</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = it-&gt;first;</div><div class="line">        <span class="keyword">const</span> TBVector* bvp = it-&gt;second;</div><div class="line">        </div><div class="line">        <a class="code" href="structbm_1_1bvector_1_1statistics.html">TBVector::statistics</a> st;</div><div class="line">        bvp-&gt;<a class="code" href="classbm_1_1bvector.html#a984a4f43724ebd9d840a36a3aa0eacca">calc_stat</a>(&amp;st);  <span class="comment">// calculate max. serialized size</span></div><div class="line">        </div><div class="line">        buf.resize(st.<a name="a37"></a><a class="code" href="structbm_1_1bv__statistics.html#acf1547fe85bf8562dde286488d567f35">max_serialize_mem</a>); <span class="comment">// prepare the temp buffer</span></div><div class="line">        </div><div class="line">        <span class="comment">// run serialization, actual serialization size is expacted to be smaller</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keywordtype">unsigned</span> bvs_size = bvsr.<a name="a38"></a><a class="code" href="classbm_1_1serializer.html#aaf363b2e7735675621b2d2f451d6ba46">serialize</a>(*bvp, buf.data(), st.<a class="code" href="structbm_1_1bv__statistics.html#acf1547fe85bf8562dde286488d567f35">max_serialize_mem</a>);</div><div class="line">        </div><div class="line">        <span class="comment">// move from temp serialization buffer to compressed in-memory index</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="structbvs__index.html#a5e3cb878fb0853eb69c85e1e73fec9ce">bvs_index::buffer_type</a>&amp; vbuf = bvs.<a name="a39"></a><a class="code" href="structbvs__index.html#abec1907109f727ec0985ab026eb90ee2">idx_</a>[id];</div><div class="line">        vbuf.resize(bvs_size);</div><div class="line">        ::memcpy(vbuf.data(), buf.data(), bvs_size);</div><div class="line">        </div><div class="line">        mem_total += bvs_size;</div><div class="line">        </div><div class="line">        mem_total += <span class="keyword">sizeof</span>(std::vector&lt;unsigned char&gt;::size_type);</div><div class="line"></div><div class="line">        </div><div class="line">        <span class="comment">// paranoia check compare source and desirialized vectors</span></div><div class="line">        <span class="comment">//</span></div><div class="line"><span class="preprocessor">        #ifdef DEBUG</span></div><div class="line">        {</div><div class="line">            TBVector bv1;</div><div class="line">            <a name="a40"></a><a class="code" href="group__bvserial.html#ga9193b4dcc3b9daa15341c1b1c1d00efa">bm::deserialize</a>(bv1, vbuf.data());</div><div class="line">            <span class="keywordflow">if</span> (bv1.<a name="a41"></a><a class="code" href="classbm_1_1bvector.html#a38404509c80ec69e1075092f436a958e">compare</a>(*bvp) !=0 )</div><div class="line">            {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deserialization check failed&quot;</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line"></div><div class="line">    } <span class="comment">// for</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> mem_total;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// convert bit-vector index to vector&lt;usingned&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">size_t</span> <a name="a42"></a><a class="code" href="xsample01_8cpp.html#ab690eccd750172e85728755be1e3fc1f">convert_bv2vect</a>(<span class="keyword">const</span> <a class="code" href="structbv__index.html">bv_index</a>&amp; bvi, <a class="code" href="structvect__index.html">vect_index</a>&amp; vidx)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span>  mem_total = 0;</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = it-&gt;first;</div><div class="line">        <span class="keyword">const</span> TBVector* bvp = it-&gt;second;</div><div class="line">        </div><div class="line">        <span class="keywordtype">unsigned</span> count = bvp-&gt;<a name="a43"></a><a class="code" href="classbm_1_1bvector.html#ad012390ff13532528a8e25bf433de544">count</a>();  <span class="comment">// population count</span></div><div class="line">        </div><div class="line">        <a class="code" href="structvect__index.html#a64eb68e4da3fe85df25f48e549ea4f9e">vect_index::buffer_type</a>&amp; vect = vidx.<a name="a44"></a><a class="code" href="structvect__index.html#a639297784cb1e872413e16b9ae6532d7">idx_</a>[id];</div><div class="line">        vect.resize(count);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<a name="_a45"></a><a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bvp-&gt;<a name="a46"></a><a class="code" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>(); en.<a name="a47"></a><a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>(); ++en)</div><div class="line">        {</div><div class="line">            vect.push_back(*en);</div><div class="line">        }</div><div class="line">        </div><div class="line">        mem_total +=</div><div class="line">            <span class="keyword">sizeof</span>(vect_index::buffer_type::value_type) * vect.size() +</div><div class="line">            <span class="keyword">sizeof</span>(vect_index::buffer_type::size_type);</div><div class="line"></div><div class="line">    } <span class="comment">// for</span></div><div class="line">    <span class="keywordflow">return</span> mem_total;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a48"></a><a class="code" href="xsample01_8cpp.html#a930adb4bffd1d9cab641d11487cc3b9d">bv2delta</a>(<span class="keyword">const</span> TBVector&amp; bv, std::vector&lt;unsigned&gt;&amp; vect)</div><div class="line">{</div><div class="line">    <span class="comment">// convert into a plain vector first</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    vect.resize(0);</div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bv.<a class="code" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>(); en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>(); ++en)</div><div class="line">    {</div><div class="line">        vect.push_back(*en);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert into delta-vector</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k  = vect.size()-1; k &gt;= 1; --k)</div><div class="line">        {</div><div class="line">            vect[k] -= vect[k-1];</div><div class="line">            --vect[k];</div><div class="line">        } <span class="comment">// for</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// convert bit-vector index to bm::sparse_vector</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">size_t</span> <a name="a49"></a><a class="code" href="xsample01_8cpp.html#ac59606c4935a1cabb31d68e9260fda9d">convert_bv2sv</a>(<span class="keyword">const</span> <a class="code" href="structbv__index.html">bv_index</a>&amp; bvi, <a class="code" href="structsparse__vect__index.html">sparse_vect_index</a>&amp; sv_idx)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span>  mem_total = 0;</div><div class="line">    </div><div class="line">    std::vector&lt;unsigned&gt; vect;</div><div class="line">    </div><div class="line">    <a class="code" href="structsparse__vect__index.html#abf8f9252d599cbc4d3ccba4f243ffd1a">sparse_vect_index::delta_sum_map_type</a>  delta_map;</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = it-&gt;first;</div><div class="line">        <span class="keyword">const</span> TBVector* bvp = it-&gt;second;</div><div class="line">        </div><div class="line">        <a class="code" href="xsample01_8cpp.html#a930adb4bffd1d9cab641d11487cc3b9d">bv2delta</a>(*bvp, vect);</div><div class="line">        </div><div class="line">        <span class="comment">// compute sum of the delta-vector elements add to the sort map</span></div><div class="line">        {</div><div class="line">            uint64_t sum = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k  = 1; k &lt; vect.size(); ++k)</div><div class="line">            {</div><div class="line">                sum += vect[k];</div><div class="line">            } <span class="comment">// for</span></div><div class="line">            delta_map.push_back(std::make_pair(sum, <span class="keywordtype">id</span>));</div><div class="line">        }</div><div class="line">        </div><div class="line">    } <span class="comment">// for</span></div><div class="line">    </div><div class="line">    <span class="comment">// sort by &quot;enthropy&quot; (sort of)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    std::sort(delta_map.begin(), delta_map.end());</div><div class="line">    <span class="keywordflow">if</span> (delta_map.size() != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.size()) <span class="comment">// paranoia check</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;delta map size is incorrect&quot;</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">unsigned</span> sv_pos = 0; <span class="comment">// current position in sparse vector</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; delta_map.size(); ++j)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = delta_map[j].second;</div><div class="line">        </div><div class="line">        bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.find(<span class="keywordtype">id</span>);</div><div class="line">        <span class="keywordflow">if</span> (it == bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end())</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        <span class="keyword">const</span> TBVector&amp; bv = *(it-&gt;second);</div><div class="line">        </div><div class="line">        <span class="comment">// convert into a plain delta vector again</span></div><div class="line">        <a class="code" href="xsample01_8cpp.html#a930adb4bffd1d9cab641d11487cc3b9d">bv2delta</a>(bv, vect);</div><div class="line"></div><div class="line">        <a class="code" href="structsparse__vect__index_1_1vect__addr.html">sparse_vect_index::vect_addr</a> vaddr;</div><div class="line">        vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#ac6c9bf8d1cf409aa77d5afdb429e2242">offset</a> = sv_pos;</div><div class="line">        vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#a8a64540446665e45a89f327289803a90">size</a> = (unsigned)(vect.size() - 1);</div><div class="line">        </div><div class="line">        sv_idx.<a name="a50"></a><a class="code" href="structsparse__vect__index.html#a0727dbc6319ebf2353ebf86549fccdc2">sv_storage1_</a>.<a name="a51"></a><a class="code" href="classbm_1_1sparse__vector.html#a56101ce9a559b30f8e14153133063ca7">set</a>(<span class="keywordtype">id</span>, vect[0]);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#a8a64540446665e45a89f327289803a90">size</a>)</div><div class="line">        {</div><div class="line">            sv_idx.<a name="a52"></a><a class="code" href="structsparse__vect__index.html#ae835bb0ea16143ed334e96d9d34d6d52">sv_storage_</a>.<a name="a53"></a><a class="code" href="classbm_1_1sparse__vector.html#a45064b7760e1366fcb8564ddd9c3d643">import</a>(&amp;vect[1], vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#a8a64540446665e45a89f327289803a90">size</a>, vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#ac6c9bf8d1cf409aa77d5afdb429e2242">offset</a>);</div><div class="line">            sv_pos += vaddr.<a class="code" href="structsparse__vect__index_1_1vect__addr.html#a8a64540446665e45a89f327289803a90">size</a>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        sv_idx.<a name="a54"></a><a class="code" href="structsparse__vect__index.html#a06e304ec23c59c4705a9e1dfd8566c94">idx_</a>[id] = vaddr;</div><div class="line">    } <span class="comment">// for</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// optimize sparse vector storage, compute memory consumption</span></div><div class="line">    {</div><div class="line">        sparse_vect_index::sparse_vector_type::statistics st;</div><div class="line">        </div><div class="line">        <a name="a55"></a><a class="code" href="bm_8h.html#ad9736d9521d713fa5d48859aa720bfdd">BM_DECLARE_TEMP_BLOCK</a>(tb)</div><div class="line">        sv_idx.<a class="code" href="structsparse__vect__index.html#ae835bb0ea16143ed334e96d9d34d6d52">sv_storage_</a>.<a name="a56"></a><a class="code" href="classbm_1_1sparse__vector.html#af9f218aa3af25cdfc9088cc0affdaa8f">optimize</a>(tb, <a name="a57"></a><a class="code" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">TBVector::opt_compress</a>, &amp;st);</div><div class="line">        mem_total += st.memory_used;</div><div class="line">        sv_idx.<a class="code" href="structsparse__vect__index.html#a0727dbc6319ebf2353ebf86549fccdc2">sv_storage1_</a>.<a class="code" href="classbm_1_1sparse__vector.html#af9f218aa3af25cdfc9088cc0affdaa8f">optimize</a>(tb, <a class="code" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">TBVector::opt_compress</a>, &amp;st);</div><div class="line">        mem_total += st.memory_used;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// check</span></div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = it-&gt;first;</div><div class="line">        <span class="keyword">const</span> TBVector* bvp = it-&gt;second;</div><div class="line">        </div><div class="line">        <span class="comment">// convert into a plain vector first</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        vect.<a name="a58"></a><a class="code" href="classbm_1_1bvector.html#a56b7573c759e51c8943cf95a82a5b9d6">resize</a>(0);</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bvp-&gt;<a class="code" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>(); en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>(); ++en)</div><div class="line">        {</div><div class="line">            vect.push_back(*en);</div><div class="line">        }</div><div class="line">        </div><div class="line">        </div><div class="line">        std::vector&lt;unsigned&gt; svect;</div><div class="line">        sv_idx.<a class="code" href="structsparse__vect__index.html#ae07351c616badacff2fdba4e55d82dd4">get_vector</a>(<span class="keywordtype">id</span>, svect);</div><div class="line">        <span class="keywordflow">if</span> (svect.size() != vect.size())</div><div class="line">        {</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Size check failed! id = &quot;</span> &lt;&lt; <span class="keywordtype">id</span></div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;size() = &quot;</span> &lt;&lt; svect.size()</div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;sparse vector content check failed&quot;</span>);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; vect.size(); ++k)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (vect[k] != svect[k])</div><div class="line">            {</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;SV content check failed! id = &quot;</span> &lt;&lt; <span class="keywordtype">id</span></div><div class="line">                          &lt;&lt;  <span class="stringliteral">&quot; i=&quot;</span> &lt;&lt; k &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> h = 0; h &lt; vect.size(); ++h)</div><div class="line">                {</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; vect[h] &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; svect[h] &lt;&lt; <span class="stringliteral">&quot;], &quot;</span>;</div><div class="line">                } <span class="comment">// for h</span></div><div class="line">                std::cout &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;sparse vector content check failed&quot;</span>);</div><div class="line">            }</div><div class="line">        } <span class="comment">// for k</span></div><div class="line"></div><div class="line">    } <span class="comment">// for</span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #ifdef DEBUG</span></div><div class="line">    bm::print_svector_stat(sv_idx.<a class="code" href="structsparse__vect__index.html#ae835bb0ea16143ed334e96d9d34d6d52">sv_storage_</a>, <span class="keyword">true</span>);</div><div class="line">    bm::print_svector_stat(sv_idx.<a class="code" href="structsparse__vect__index.html#a0727dbc6319ebf2353ebf86549fccdc2">sv_storage1_</a>, <span class="keyword">true</span>);</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> mem_total;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// speed test for in-memory bit vectors</span></div><div class="line"><span class="comment">// benchmark performs a mix of logical operations</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a59"></a><a class="code" href="xsample01_8cpp.html#a844081fa54de635ef47709065278dbe1">speed_test_bv_index</a>(<span class="keyword">const</span> <a class="code" href="structbv__index.html">bv_index</a>&amp; bvi)</div><div class="line">{</div><div class="line">    TBVector bv_join; <span class="comment">// OR join vector</span></div><div class="line">    </div><div class="line">    <a name="_a60"></a><a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt1(<span class="stringliteral">&quot;1. bm::bvector&lt;&gt; index&quot;</span>, 1, &amp;<a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>);</div><div class="line"></div><div class="line">    <span class="comment">// join all vectors using OR operation</span></div><div class="line">    <span class="keywordflow">for</span> (bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.begin();</div><div class="line">         it != bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> TBVector* bvp = it-&gt;second;</div><div class="line">        bv_join |= *bvp;</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    bv_join.<a name="a61"></a><a class="code" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a>();</div><div class="line">    </div><div class="line">    <span class="comment">// a group of random vectors from the index map, compute OR</span></div><div class="line">    <span class="comment">// then compute AND with the join vector</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    TBVector bv_res(<a class="code" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">bm::BM_GAP</a>);</div><div class="line">    std::vector&lt;unsigned&gt; result_set;</div><div class="line">    result_set.reserve(<a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>); <span class="comment">// memory reservation to avoid reallocs</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a368f2a2dfa759300fbe221aaa1550eea">benchmark_ops</a>; ++i)</div><div class="line">    {</div><div class="line">        bv_res.<a name="a62"></a><a class="code" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312">clear</a>(<span class="keyword">true</span>); <span class="comment">// free all blocks</span></div><div class="line">        result_set.resize(0);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; <a class="code" href="xsample01_8cpp.html#abd38d1f1700e2c6d58e040b54855892b">sample_cnt</a>; ++j)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a>;</div><div class="line">            bv_index::map_type::const_iterator it = bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.find(<span class="keywordtype">id</span>);</div><div class="line">            <span class="keywordflow">if</span> (it == bvi.<a class="code" href="structbv__index.html#a7cefb04d6297b8d95e2cca36760289d2">idx_</a>.end())</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            <span class="keyword">const</span> TBVector&amp; bv = *(it-&gt;second);</div><div class="line">            bv_res |= bv;</div><div class="line">        }</div><div class="line">        </div><div class="line">        bv_res &amp;= bv_join;</div><div class="line">        </div><div class="line">        <span class="comment">// enumerate the final result set, extract first N elements</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bv_res.<a class="code" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>() &amp;&amp; k &lt; <a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>; ++k, ++en)</div><div class="line">        {</div><div class="line">            result_set.push_back(*en);</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="comment">// for i</span></div><div class="line">    </div><div class="line">    tt1.<a name="a63"></a><a class="code" href="classbm_1_1chrono__taker.html#a5b4dcfaed5a8adaab6716c03d1a47089">add_repeats</a>(benchmark_ops + 1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// speed test for in-memory serialized bit vectors</span></div><div class="line"><span class="comment">// this function uses bm::operation_deserializer</span></div><div class="line"><span class="comment">// to perform logical operation between a BLOB and bvector&lt;&gt; in memory</span></div><div class="line"><span class="comment">// and avoids extra decompression overhead</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a64"></a><a class="code" href="xsample01_8cpp.html#aef971e8c7eff09255dad020bf879fb46">speed_test_bvs_index</a>(<span class="keyword">const</span> <a class="code" href="structbvs__index.html">bvs_index</a>&amp; bvs)</div><div class="line">{</div><div class="line">    TBVector bv_join; <span class="comment">// OR join vector</span></div><div class="line">    </div><div class="line">    <a class="code" href="bm_8h.html#ad9736d9521d713fa5d48859aa720bfdd">BM_DECLARE_TEMP_BLOCK</a>(tb)</div><div class="line"></div><div class="line">    <a name="_a65"></a><a class="code" href="classbm_1_1operation__deserializer.html">bm::operation_deserializer&lt;TBVector&gt;</a> des;</div><div class="line">    </div><div class="line">    <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt1(<span class="stringliteral">&quot;2. serialized bvector&quot;</span>, 1, &amp;<a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>);</div><div class="line"></div><div class="line">    <span class="comment">// join all vectors using OR operation</span></div><div class="line">    <span class="keywordflow">for</span> (bvs_index::map_type::const_iterator it = bvs.<a class="code" href="structbvs__index.html#abec1907109f727ec0985ab026eb90ee2">idx_</a>.begin();</div><div class="line">         it != bvs.<a class="code" href="structbvs__index.html#abec1907109f727ec0985ab026eb90ee2">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structbvs__index.html#a5e3cb878fb0853eb69c85e1e73fec9ce">bvs_index::buffer_type</a>&amp; svect = it-&gt;second;</div><div class="line">        <span class="keywordflow">if</span> (svect.size() == 0)</div><div class="line">        {</div><div class="line">           <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;empty buffer error&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf = it-&gt;second.data();</div><div class="line">        </div><div class="line">        des.<a name="a66"></a><a class="code" href="classbm_1_1operation__deserializer.html#a3ddb2bd36faa96cc9a5fccd7ff38cb43">deserialize</a>(bv_join, buf, tb, <a name="a67"></a><a class="code" href="group__bvector.html#gga76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">bm::set_OR</a>);</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    bv_join.<a class="code" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// a group of random vectors from the index map, compute OR</span></div><div class="line">    <span class="comment">// then compute AND with the join vector</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    TBVector bv_res(<a class="code" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">bm::BM_GAP</a>);</div><div class="line">    std::vector&lt;unsigned&gt; result_set;</div><div class="line">    result_set.reserve(<a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>); <span class="comment">// memory reservation to avoid reallocs</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a368f2a2dfa759300fbe221aaa1550eea">benchmark_ops</a>; ++i)</div><div class="line">    {</div><div class="line">        bv_res.<a class="code" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312">clear</a>(<span class="keyword">true</span>); <span class="comment">// free all blocks</span></div><div class="line">        result_set.resize(0);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; <a class="code" href="xsample01_8cpp.html#abd38d1f1700e2c6d58e040b54855892b">sample_cnt</a>; ++j)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a>;</div><div class="line">            bvs_index::map_type::const_iterator it = bvs.<a class="code" href="structbvs__index.html#abec1907109f727ec0985ab026eb90ee2">idx_</a>.find(<span class="keywordtype">id</span>);</div><div class="line">            <span class="keywordflow">if</span> (it == bvs.<a class="code" href="structbvs__index.html#abec1907109f727ec0985ab026eb90ee2">idx_</a>.end())</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf = it-&gt;second.data();</div><div class="line">            des.<a class="code" href="classbm_1_1operation__deserializer.html#a3ddb2bd36faa96cc9a5fccd7ff38cb43">deserialize</a>(bv_res, buf, tb, <a class="code" href="group__bvector.html#gga76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">bm::set_OR</a>);</div><div class="line">        } <span class="comment">// for j</span></div><div class="line">        </div><div class="line">        bv_res &amp;= bv_join;</div><div class="line">        </div><div class="line">        <span class="comment">// enumerate the final result set, extract first N elements</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bv_res.<a class="code" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>() &amp;&amp; k &lt; <a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>; ++k, ++en)</div><div class="line">        {</div><div class="line">            result_set.push_back(*en);</div><div class="line">        }</div><div class="line">    } <span class="comment">// for i</span></div><div class="line">    </div><div class="line">    tt1.<a class="code" href="classbm_1_1chrono__taker.html#a5b4dcfaed5a8adaab6716c03d1a47089">add_repeats</a>(benchmark_ops + 1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a68"></a><a class="code" href="xsample01_8cpp.html#a32f1645859699b68ae87da80d82370cf">speed_test_vect_index</a>(<span class="keyword">const</span> <a class="code" href="structvect__index.html">vect_index</a>&amp; vecti)</div><div class="line">{</div><div class="line">    TBVector bv_join; <span class="comment">// OR join vector</span></div><div class="line">    </div><div class="line">    <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt1(<span class="stringliteral">&quot;3. std::vector&lt;unsigned&gt; &quot;</span>, 1, &amp;<a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>);</div><div class="line"></div><div class="line">    <span class="comment">// join all vectors using OR operation</span></div><div class="line">    <span class="keywordflow">for</span> (vect_index::map_type::const_iterator it = vecti.<a class="code" href="structvect__index.html#a639297784cb1e872413e16b9ae6532d7">idx_</a>.begin();</div><div class="line">         it != vecti.<a class="code" href="structvect__index.html#a639297784cb1e872413e16b9ae6532d7">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structvect__index.html#a64eb68e4da3fe85df25f48e549ea4f9e">vect_index::buffer_type</a>&amp; vect = it-&gt;second;</div><div class="line">        <span class="keywordflow">if</span> (vect.size() == 0)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;empty buffer error&quot;</span>);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <a name="a69"></a><a class="code" href="group__setalgo.html#gab15f2180dfd9a8bcb0d261689336d786">bm::combine_or</a>(bv_join, vect.begin(), vect.<a name="a70"></a><a class="code" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a>());</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    bv_join.<a class="code" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a>();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// a group of random vectors from the index map, compute OR</span></div><div class="line">    <span class="comment">// then compute AND with the join vector</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    TBVector bv_res(<a class="code" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">bm::BM_GAP</a>);</div><div class="line">    std::vector&lt;unsigned&gt; result_set;</div><div class="line">    result_set.reserve(<a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>); <span class="comment">// memory reservation to avoid reallocs</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a368f2a2dfa759300fbe221aaa1550eea">benchmark_ops</a>; ++i)</div><div class="line">    {</div><div class="line">        bv_res.<a class="code" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312">clear</a>(<span class="keyword">true</span>); <span class="comment">// free all blocks</span></div><div class="line">        result_set.resize(0);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; <a class="code" href="xsample01_8cpp.html#abd38d1f1700e2c6d58e040b54855892b">sample_cnt</a>; ++j)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a>;</div><div class="line">            vect_index::map_type::const_iterator it = vecti.<a class="code" href="structvect__index.html#a639297784cb1e872413e16b9ae6532d7">idx_</a>.find(<span class="keywordtype">id</span>);</div><div class="line">            <span class="keywordflow">if</span> (it == vecti.<a class="code" href="structvect__index.html#a639297784cb1e872413e16b9ae6532d7">idx_</a>.end())</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">const</span> <a class="code" href="structvect__index.html#a64eb68e4da3fe85df25f48e549ea4f9e">vect_index::buffer_type</a>&amp; vect = it-&gt;second;</div><div class="line">            </div><div class="line">            <a class="code" href="group__setalgo.html#gab15f2180dfd9a8bcb0d261689336d786">bm::combine_or</a>(bv_join, vect.begin(), vect.<a class="code" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a>());</div><div class="line">        } <span class="comment">// for j</span></div><div class="line">        </div><div class="line">        bv_res &amp;= bv_join;</div><div class="line">        </div><div class="line">        <span class="comment">// enumerate the final result set, extract first N elements</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bv_res.first();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>() &amp;&amp; k &lt; <a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>; ++k, ++en)</div><div class="line">        {</div><div class="line">            result_set.push_back(*en);</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="comment">// for i</span></div><div class="line">    </div><div class="line">    tt1.<a class="code" href="classbm_1_1chrono__taker.html#a5b4dcfaed5a8adaab6716c03d1a47089">add_repeats</a>(benchmark_ops + 1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">void</span> <a name="a71"></a><a class="code" href="xsample01_8cpp.html#aa3cf3825afed302e7ede75ba33e5502a">speed_test_sv_index</a>(<span class="keyword">const</span> <a class="code" href="structsparse__vect__index.html">sparse_vect_index</a>&amp; svi)</div><div class="line">{</div><div class="line">    TBVector bv_join; <span class="comment">// OR join vector</span></div><div class="line">    </div><div class="line">    <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt1(<span class="stringliteral">&quot;4. bm::sparse_vector&lt;unsigned&gt; &quot;</span>, 1, &amp;<a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>);</div><div class="line">    </div><div class="line">    std::vector&lt;unsigned&gt; vect;</div><div class="line"></div><div class="line">    <span class="comment">// join all vectors using OR operation</span></div><div class="line">    <span class="keywordflow">for</span> (sparse_vect_index::map_type::const_iterator it = svi.<a class="code" href="structsparse__vect__index.html#a06e304ec23c59c4705a9e1dfd8566c94">idx_</a>.begin();</div><div class="line">         it != svi.<a class="code" href="structsparse__vect__index.html#a06e304ec23c59c4705a9e1dfd8566c94">idx_</a>.end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = it-&gt;first;</div><div class="line">        svi.<a class="code" href="structsparse__vect__index.html#ae07351c616badacff2fdba4e55d82dd4">get_vector</a>(<span class="keywordtype">id</span>, vect);</div><div class="line">        </div><div class="line">        <a class="code" href="group__setalgo.html#gab15f2180dfd9a8bcb0d261689336d786">bm::combine_or</a>(bv_join, vect.begin(), vect.<a class="code" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a>());</div><div class="line">    } <span class="comment">// for</span></div><div class="line">    bv_join.<a class="code" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a>();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// a group of random vectors from the index map, compute OR</span></div><div class="line">    <span class="comment">// then compute AND with the join vector</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    TBVector bv_res(<a class="code" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">bm::BM_GAP</a>);</div><div class="line">    std::vector&lt;unsigned&gt; result_set;</div><div class="line">    result_set.reserve(<a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>); <span class="comment">// memory reservation to avoid reallocs</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="xsample01_8cpp.html#a368f2a2dfa759300fbe221aaa1550eea">benchmark_ops</a>; ++i)</div><div class="line">    {</div><div class="line">        bv_res.<a class="code" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312">clear</a>(<span class="keyword">true</span>); <span class="comment">// free all blocks</span></div><div class="line">        result_set.resize(0);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; <a class="code" href="xsample01_8cpp.html#abd38d1f1700e2c6d58e040b54855892b">sample_cnt</a>; ++j)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = unsigned(rand()) % <a class="code" href="xsample01_8cpp.html#a1d252dabf483e0114e2e01782cb07d2a">index_size</a>;</div><div class="line">            svi.<a class="code" href="structsparse__vect__index.html#ae07351c616badacff2fdba4e55d82dd4">get_vector</a>(<span class="keywordtype">id</span>, vect);</div><div class="line">            <span class="keywordflow">if</span> (vect.size() == 0)</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            </div><div class="line">            <a class="code" href="group__setalgo.html#gab15f2180dfd9a8bcb0d261689336d786">bm::combine_or</a>(bv_join, vect.begin(), vect.<a class="code" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a>());</div><div class="line">        } <span class="comment">// for j</span></div><div class="line">        </div><div class="line">        bv_res &amp;= bv_join;</div><div class="line">        </div><div class="line">        <span class="comment">// enumerate the final result set, extract first N elements</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="classbm_1_1bvector_1_1enumerator.html">TBVector::enumerator</a> en = bv_res.first();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; en.<a class="code" href="classbm_1_1bvector_1_1iterator__base.html#a10f662a5764d2bcf6a158fb3521401a9">valid</a>() &amp;&amp; k &lt; <a class="code" href="xsample01_8cpp.html#a968fb3b90a1c99803dc9380d54bd013b">result_set_cnt</a>; ++k, ++en)</div><div class="line">        {</div><div class="line">            result_set.push_back(*en);</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="comment">// for i</span></div><div class="line"></div><div class="line">    tt1.<a class="code" href="classbm_1_1chrono__taker.html#a5b4dcfaed5a8adaab6716c03d1a47089">add_repeats</a>(benchmark_ops + 1);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a name="a72"></a><a class="code" href="xsample01_8cpp.html#a840291bc02cba5474a4cb46a9b9566fe">main</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <a class="code" href="structbv__index.html">bv_index</a>  bvi; <span class="comment">// regular in-memory index id to bvector&lt;&gt;</span></div><div class="line">        <a class="code" href="structbvs__index.html">bvs_index</a> bvs; <span class="comment">// compressed in-memory index id to bvector&lt;&gt; BLOB</span></div><div class="line">        <a class="code" href="structvect__index.html">vect_index</a> vecti; <span class="comment">// index based on plain uncompressed vector&lt;unsigned&gt;</span></div><div class="line">        <a class="code" href="structsparse__vect__index.html">sparse_vect_index</a> svi; <span class="comment">// all ids in a sparse vector</span></div><div class="line">        </div><div class="line">        <span class="comment">// experiments generation, measuring memory footprints</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <a class="code" href="xsample01_8cpp.html#a14dd8e20549b8c10dc1eda35055f77ef">generate_bv_index</a>(bvi);</div><div class="line">        </div><div class="line">        <span class="keywordtype">size_t</span> bv_mem_total = <a class="code" href="xsample01_8cpp.html#a86e1ced56a418a49ba4ee5cf711a8ab8">calc_memory_footprint</a>(bvi);</div><div class="line">        <span class="keywordtype">size_t</span> bv_mem_total_MB = bv_mem_total / (1024*1024);</div><div class="line">        </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;bm::bvector&lt;&gt; memory footprint = &quot;</span></div><div class="line">                  &lt;&lt; bv_mem_total &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; bv_mem_total_MB &lt;&lt; <span class="stringliteral">&quot;MB)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        </div><div class="line">        <span class="keywordtype">size_t</span> bvs_mem_total = <a class="code" href="xsample01_8cpp.html#a94c49211e6bc6f94107a0a829efc79e0">convert_bv2bvs</a>(bvi, bvs);</div><div class="line">        <span class="keywordtype">size_t</span> bvs_mem_total_MB = bvs_mem_total / (1024*1024);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;bm::bvector&lt;&gt; BLOB memory footprint = &quot;</span></div><div class="line">                  &lt;&lt; bvs_mem_total &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; bvs_mem_total_MB &lt;&lt; <span class="stringliteral">&quot;MB)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordtype">size_t</span> vecti_mem_total = <a class="code" href="xsample01_8cpp.html#ab690eccd750172e85728755be1e3fc1f">convert_bv2vect</a>(bvi, vecti);</div><div class="line">        <span class="keywordtype">size_t</span> vecti_mem_total_MB = vecti_mem_total / (1024*1024);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;std::vector&lt;unsigned&gt; memory footprint = &quot;</span></div><div class="line">                  &lt;&lt; vecti_mem_total &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; vecti_mem_total_MB &lt;&lt; <span class="stringliteral">&quot;MB)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordtype">size_t</span> svi_mem_total = <a class="code" href="xsample01_8cpp.html#ac59606c4935a1cabb31d68e9260fda9d">convert_bv2sv</a>(bvi, svi);</div><div class="line">        <span class="keywordtype">size_t</span> svi_mem_total_MB = svi_mem_total / (1024*1024);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;bm::sparse_vector&lt;&gt; memory footprint = &quot;</span></div><div class="line">                  &lt;&lt; svi_mem_total &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; svi_mem_total_MB &lt;&lt; <span class="stringliteral">&quot;MB)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// run performance tests</span></div><div class="line">        <span class="comment">//</span></div><div class="line"></div><div class="line">        <a class="code" href="xsample01_8cpp.html#a844081fa54de635ef47709065278dbe1">speed_test_bv_index</a>(bvi);</div><div class="line">        <a class="code" href="xsample01_8cpp.html#aef971e8c7eff09255dad020bf879fb46">speed_test_bvs_index</a>(bvs);</div><div class="line">        <a class="code" href="xsample01_8cpp.html#a32f1645859699b68ae87da80d82370cf">speed_test_vect_index</a>(vecti);</div><div class="line">        <a class="code" href="xsample01_8cpp.html#aa3cf3825afed302e7ede75ba33e5502a">speed_test_sv_index</a>(svi);</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Performance (ops/sec):&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <a name="a73"></a><a class="code" href="classbm_1_1chrono__taker.html#a30b45453d952d14afe56c29087970899">bm::chrono_taker::print_duration_map</a>(<a class="code" href="xsample01_8cpp.html#a6cb51d150528a5d2d87acb3e88f450bc">timing_map</a>, <a name="a74"></a><a class="code" href="classbm_1_1chrono__taker.html#a9a41e5f2fe48ba472fd77a1dbd86457dad530ca7863ce7e60f4fa221e1dfa64a2">bm::chrono_taker::ct_ops_per_sec</a>);</div><div class="line"></div><div class="line">        <span class="comment">//getchar();  // uncomment to check memory consumption at the OS level</span></div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(std::exception&amp; ex)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
