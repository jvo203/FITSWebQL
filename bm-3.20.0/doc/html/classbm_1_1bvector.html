<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: bm::bvector&lt; Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebm.html">bm</a></li><li class="navelem"><a class="el" href="classbm_1_1bvector.html">bvector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">bm::bvector&lt; Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__bmagic.html">BitMagic Library</a> &raquo; <a class="el" href="group__bvector.html">bvector&lt;&gt; container</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Bitvector Bit-vector container with runtime compression of bits.  
 <a href="classbm_1_1bvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bm_8h_source.html">bm.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bm::bvector&lt; Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classbm_1_1bvector__inherit__graph.png" border="0" usemap="#bm_1_1bvector_3_01Alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="bm_1_1bvector_3_01Alloc_01_4_inherit__map" id="bm_1_1bvector_3_01Alloc_01_4_inherit__map">
<area shape="rect" id="node2" href="classbm_1_1bvector.html" title="bm::bvector\&lt;\&gt;" alt="" coords="24,95,129,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bvector_1_1allocation__policy.html">allocation_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory allocation policy  <a href="structbm_1_1bvector_1_1allocation__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1bulk__insert__iterator.html">bulk_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output iterator iterator designed to set "ON" bits based on input sequence of integers.  <a href="classbm_1_1bvector_1_1bulk__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1counted__enumerator.html">counted_enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator designed to enumerate "ON" bits <a class="el" href="classbm_1_1bvector_1_1counted__enumerator.html" title="Constant iterator designed to enumerate &quot;ON&quot; bits counted_enumerator keeps bitcount, ie number of ON bits starting from the position 0 in the bit string up to the currently enumerated bit. ">counted_enumerator</a> keeps bitcount, ie number of ON bits starting from the position 0 in the bit string up to the currently enumerated bit.  <a href="classbm_1_1bvector_1_1counted__enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator designed to enumerate "ON" bits.  <a href="classbm_1_1bvector_1_1enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output iterator iterator designed to set "ON" bits based on input sequence of integers (bit indeces).  <a href="classbm_1_1bvector_1_1insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all iterators.  <a href="classbm_1_1bvector_1_1iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1mem__pool__guard.html">mem_pool_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class reference implements an object for bit assignment.  <a href="classbm_1_1bvector_1_1reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical information about bitset's memory allocation details.  <a href="structbm_1_1bvector_1_1statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> { <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a> = 0, 
<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe">opt_free_0</a> = 1, 
<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc">opt_free_01</a> = 2, 
<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a> = 3
 }<tr class="memdesc:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization mode Every next level means additional checks (better compression vs time)  <a href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dbe63690fd5cd2b1e064795d3f1b6c"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">allocator_type</a></td></tr>
<tr class="separator:ad1dbe63690fd5cd2b1e064795d3f1b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8990a2147fdc3e6094011e77e559e8"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::allocator_pool_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a></td></tr>
<tr class="separator:a2c8990a2147fdc3e6094011e77e559e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdfeafe05217c31cdc9140b7642b611"><td class="memItemLeft" align="right" valign="top">typedef blocks_manager&lt; Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a></td></tr>
<tr class="separator:a6fdfeafe05217c31cdc9140b7642b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405dd9ed048c935c84a5086ec8ba3649"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a></td></tr>
<tr class="separator:a405dd9ed048c935c84a5086ec8ba3649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d7ea71a6e69abb26e03b31f93e6689"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a04d7ea71a6e69abb26e03b31f93e6689">const_reference</a></td></tr>
<tr class="separator:a04d7ea71a6e69abb26e03b31f93e6689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37233698b671258ed4aaacf95fbc6b53"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbm_1_1rs__index.html">rs_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a37233698b671258ed4aaacf95fbc6b53">blocks_count</a></td></tr>
<tr class="separator:a37233698b671258ed4aaacf95fbc6b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309afd0facb857c5591f88a1fee276b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbm_1_1rs__index.html">rs_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a></td></tr>
<tr class="separator:a309afd0facb857c5591f88a1fee276b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1917a8e264fd69c102d7232862707732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a1917a8e264fd69c102d7232862707732">operator[]</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="separator:a1917a8e264fd69c102d7232862707732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbce2c22793865f10a2c445f3bb319a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afbce2c22793865f10a2c445f3bb319a4">operator[]</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n) const</td></tr>
<tr class="separator:afbce2c22793865f10a2c445f3bb319a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192bc4d069c11e3bb3ee0d3b6ce2903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6192bc4d069c11e3bb3ee0d3b6ce2903">operator&amp;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="separator:a6192bc4d069c11e3bb3ee0d3b6ce2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3adf4c9870b960d5dff4203074fc3d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac3adf4c9870b960d5dff4203074fc3d7">operator^=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="separator:ac3adf4c9870b960d5dff4203074fc3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48cd211c038bdc186baeca30e42fa93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac48cd211c038bdc186baeca30e42fa93">operator|=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="separator:ac48cd211c038bdc186baeca30e42fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceab1a0111e47f2fe4c4421e44fd3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7ceab1a0111e47f2fe4c4421e44fd3e4">operator-=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="separator:a7ceab1a0111e47f2fe4c4421e44fd3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba6bcb25602091aedbd01dcb831dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a33ba6bcb25602091aedbd01dcb831dcf">operator&lt;</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a33ba6bcb25602091aedbd01dcb831dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e18cf38c1986e81c495ac10cc1e8c96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9e18cf38c1986e81c495ac10cc1e8c96">operator&lt;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a9e18cf38c1986e81c495ac10cc1e8c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c937eedfa6e8ad1f2b381678075cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a493c937eedfa6e8ad1f2b381678075cd">operator&gt;</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a493c937eedfa6e8ad1f2b381678075cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5dfbe8e46c969d36ecbaf7261db03c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9f5dfbe8e46c969d36ecbaf7261db03c">operator&gt;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a9f5dfbe8e46c969d36ecbaf7261db03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd0733885a5c736633343a377afd31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a42cd0733885a5c736633343a377afd31">operator==</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a42cd0733885a5c736633343a377afd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0aa609e421d4bd30f54bfc0c37672f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7c0aa609e421d4bd30f54bfc0c37672f">operator!=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="separator:a7c0aa609e421d4bd30f54bfc0c37672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51687153e07d3be056aeb38ada237816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a51687153e07d3be056aeb38ada237816">operator~</a> () const</td></tr>
<tr class="separator:a51687153e07d3be056aeb38ada237816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f97290c7998d85514404e10f6a11a63"><td class="memItemLeft" align="right" valign="top">Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7f97290c7998d85514404e10f6a11a63">get_allocator</a> () const</td></tr>
<tr class="separator:a7f97290c7998d85514404e10f6a11a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca1a05eb82edd1172207da584c1374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af9ca1a05eb82edd1172207da584c1374">set_allocator_pool</a> (<a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *pool_ptr)</td></tr>
<tr class="memdesc:af9ca1a05eb82edd1172207da584c1374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set allocator pool for local (non-threaded) memory cyclic(lots of alloc-free ops) opertations.  <a href="#af9ca1a05eb82edd1172207da584c1374">More...</a><br /></td></tr>
<tr class="separator:af9ca1a05eb82edd1172207da584c1374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30287a9a5b42f654c1a00732dc6615e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad30287a9a5b42f654c1a00732dc6615e">get_allocator_pool</a> ()</td></tr>
<tr class="memdesc:ad30287a9a5b42f654c1a00732dc6615e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get curent allocator pool (if set)  <a href="#ad30287a9a5b42f654c1a00732dc6615e">More...</a><br /></td></tr>
<tr class="separator:ad30287a9a5b42f654c1a00732dc6615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb5c0bd6f4b05712ee7701dcd1fe1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">inserter</a> ()</td></tr>
<tr class="separator:a6fbb5c0bd6f4b05712ee7701dcd1fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, initialization, assignment</div></td></tr>
<tr class="memitem:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a159e3c2cb32e6d098eddd9d1eac21c88">bvector</a> (<a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat=<a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a>, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len=<a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt; true &gt;::_len, <a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a> bv_size=<a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs bvector class.  <a href="#a159e3c2cb32e6d098eddd9d1eac21c88">More...</a><br /></td></tr>
<tr class="separator:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54e579bdddadece60dcfa519d18a1c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae54e579bdddadece60dcfa519d18a1c5">bvector</a> (<a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a> bv_size, <a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat=<a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a>, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len=<a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt; true &gt;::_len, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:ae54e579bdddadece60dcfa519d18a1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs bvector class.  <a href="#ae54e579bdddadece60dcfa519d18a1c5">More...</a><br /></td></tr>
<tr class="separator:ae54e579bdddadece60dcfa519d18a1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608b979d18211645c625e1bcd41cf307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a608b979d18211645c625e1bcd41cf307">bvector</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a608b979d18211645c625e1bcd41cf307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a608b979d18211645c625e1bcd41cf307">More...</a><br /></td></tr>
<tr class="separator:a608b979d18211645c625e1bcd41cf307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359e850745b9901b5b6e7be08ae9713d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a359e850745b9901b5b6e7be08ae9713d">bvector</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right)</td></tr>
<tr class="memdesc:a359e850745b9901b5b6e7be08ae9713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for range copy [left..right].  <a href="#a359e850745b9901b5b6e7be08ae9713d">More...</a><br /></td></tr>
<tr class="separator:a359e850745b9901b5b6e7be08ae9713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78c55229da6a419352d4d97a0827da2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae78c55229da6a419352d4d97a0827da2">~bvector</a> () <a class="el" href="bmdef_8h.html#a573be708bbdefe3907cbd46fbd090de5">BMNOEXEPT</a></td></tr>
<tr class="separator:ae78c55229da6a419352d4d97a0827da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaceb8d31d9da05f977de5c6a6cd62e24">init</a> ()</td></tr>
<tr class="memdesc:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit post-construction initialization.  <a href="#aaceb8d31d9da05f977de5c6a6cd62e24">More...</a><br /></td></tr>
<tr class="separator:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffde9962a72e85ad2e6da29b397882e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3ffde9962a72e85ad2e6da29b397882e">operator=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a3ffde9962a72e85ad2e6da29b397882e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a3ffde9962a72e85ad2e6da29b397882e">More...</a><br /></td></tr>
<tr class="separator:a3ffde9962a72e85ad2e6da29b397882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57196373d4b83d0cab1bd3f2b80c1c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aa57196373d4b83d0cab1bd3f2b80c1c5">bvector</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a573be708bbdefe3907cbd46fbd090de5">BMNOEXEPT</a></td></tr>
<tr class="memdesc:aa57196373d4b83d0cab1bd3f2b80c1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa57196373d4b83d0cab1bd3f2b80c1c5">More...</a><br /></td></tr>
<tr class="separator:aa57196373d4b83d0cab1bd3f2b80c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd521f397836d4d38c7f621a239061b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3dd521f397836d4d38c7f621a239061b">bvector</a> (std::initializer_list&lt; <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &gt; il)</td></tr>
<tr class="memdesc:a3dd521f397836d4d38c7f621a239061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brace constructor.  <a href="#a3dd521f397836d4d38c7f621a239061b">More...</a><br /></td></tr>
<tr class="separator:a3dd521f397836d4d38c7f621a239061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b12c8991f5868c8a976f3d272dddf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a06b12c8991f5868c8a976f3d272dddf3">operator=</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a573be708bbdefe3907cbd46fbd090de5">BMNOEXEPT</a></td></tr>
<tr class="memdesc:a06b12c8991f5868c8a976f3d272dddf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a06b12c8991f5868c8a976f3d272dddf3">More...</a><br /></td></tr>
<tr class="separator:a06b12c8991f5868c8a976f3d272dddf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661988e4733743eece85726c9b5f99eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a661988e4733743eece85726c9b5f99eb">move_from</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a573be708bbdefe3907cbd46fbd090de5">BMNOEXEPT</a></td></tr>
<tr class="memdesc:a661988e4733743eece85726c9b5f99eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move bvector content from another bvector.  <a href="#a661988e4733743eece85726c9b5f99eb">More...</a><br /></td></tr>
<tr class="separator:a661988e4733743eece85726c9b5f99eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb23b3d28671129ae37f21fc37c31cdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afb23b3d28671129ae37f21fc37c31cdd">swap</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a573be708bbdefe3907cbd46fbd090de5">BMNOEXEPT</a></td></tr>
<tr class="memdesc:afb23b3d28671129ae37f21fc37c31cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges content of bv and this bvector.  <a href="#afb23b3d28671129ae37f21fc37c31cdd">More...</a><br /></td></tr>
<tr class="separator:afb23b3d28671129ae37f21fc37c31cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237170e9f988319665bbcac2cd10e24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a237170e9f988319665bbcac2cd10e24e">merge</a> (<a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a237170e9f988319665bbcac2cd10e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge/move content from another vector.  <a href="#a237170e9f988319665bbcac2cd10e24e">More...</a><br /></td></tr>
<tr class="separator:a237170e9f988319665bbcac2cd10e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit access/modification methods</div></td></tr>
<tr class="memitem:aecf79c2c05bda3445ade2e10b61066b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aecf79c2c05bda3445ade2e10b61066b7">set_bit</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, bool val=true)</td></tr>
<tr class="memdesc:aecf79c2c05bda3445ade2e10b61066b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n.  <a href="#aecf79c2c05bda3445ade2e10b61066b7">More...</a><br /></td></tr>
<tr class="separator:aecf79c2c05bda3445ade2e10b61066b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae63c4aafd1215964477957b599f1502"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aae63c4aafd1215964477957b599f1502">set_bit_and</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, bool val=true)</td></tr>
<tr class="memdesc:aae63c4aafd1215964477957b599f1502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n using bit AND with the provided value.  <a href="#aae63c4aafd1215964477957b599f1502">More...</a><br /></td></tr>
<tr class="separator:aae63c4aafd1215964477957b599f1502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c81ffb8a615f3c2593cd8541fac26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ade7c81ffb8a615f3c2593cd8541fac26">inc</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="memdesc:ade7c81ffb8a615f3c2593cd8541fac26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the specified element.  <a href="#ade7c81ffb8a615f3c2593cd8541fac26">More...</a><br /></td></tr>
<tr class="separator:ade7c81ffb8a615f3c2593cd8541fac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd2b46e67549275f72517930f99e3ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9cd2b46e67549275f72517930f99e3ae">set_bit_conditional</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, bool val, bool condition)</td></tr>
<tr class="memdesc:a9cd2b46e67549275f72517930f99e3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n only if current value equals the condition.  <a href="#a9cd2b46e67549275f72517930f99e3ae">More...</a><br /></td></tr>
<tr class="separator:a9cd2b46e67549275f72517930f99e3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3af299b53a3d50af720192aed04791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ade3af299b53a3d50af720192aed04791">set</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, bool val=true)</td></tr>
<tr class="memdesc:ade3af299b53a3d50af720192aed04791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n if val is true, clears bit n if val is false.  <a href="#ade3af299b53a3d50af720192aed04791">More...</a><br /></td></tr>
<tr class="separator:ade3af299b53a3d50af720192aed04791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948743fdaf254dfc9d946b75c5e301a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a948743fdaf254dfc9d946b75c5e301a0">set</a> ()</td></tr>
<tr class="memdesc:a948743fdaf254dfc9d946b75c5e301a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets every bit in this bitset to 1.  <a href="#a948743fdaf254dfc9d946b75c5e301a0">More...</a><br /></td></tr>
<tr class="separator:a948743fdaf254dfc9d946b75c5e301a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b91dacd0dac75e18fa79570acb29256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a5b91dacd0dac75e18fa79570acb29256">set</a> (const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *ids, unsigned ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:a5b91dacd0dac75e18fa79570acb29256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set list of bits in this bitset to 1.  <a href="#a5b91dacd0dac75e18fa79570acb29256">More...</a><br /></td></tr>
<tr class="separator:a5b91dacd0dac75e18fa79570acb29256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd40871b6cf3868aa9ff924c4c98d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6cd40871b6cf3868aa9ff924c4c98d57">keep</a> (const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *ids, unsigned ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:a6cd40871b6cf3868aa9ff924c4c98d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep list of bits in this bitset, others are cleared.  <a href="#a6cd40871b6cf3868aa9ff924c4c98d57">More...</a><br /></td></tr>
<tr class="separator:a6cd40871b6cf3868aa9ff924c4c98d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc04dcf2543cc096a028ac55320312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312">clear</a> (const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *ids, unsigned ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:ab2cc04dcf2543cc096a028ac55320312"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear list of bits in this bitset  <a href="#ab2cc04dcf2543cc096a028ac55320312">More...</a><br /></td></tr>
<tr class="separator:ab2cc04dcf2543cc096a028ac55320312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269707ecb4a5cba0d1907f85c0742f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a269707ecb4a5cba0d1907f85c0742f33">set_bit_no_check</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="memdesc:a269707ecb4a5cba0d1907f85c0742f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit without checking preconditions (size, etc)  <a href="#a269707ecb4a5cba0d1907f85c0742f33">More...</a><br /></td></tr>
<tr class="separator:a269707ecb4a5cba0d1907f85c0742f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14650ede7559f896894f951810cadbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae14650ede7559f896894f951810cadbf">set_range</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right, bool value=true)</td></tr>
<tr class="memdesc:ae14650ede7559f896894f951810cadbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector.  <a href="#ae14650ede7559f896894f951810cadbf">More...</a><br /></td></tr>
<tr class="separator:ae14650ede7559f896894f951810cadbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd89156d7ae68dfcb818628389c42158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afd89156d7ae68dfcb818628389c42158">copy_range</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right)</td></tr>
<tr class="memdesc:afd89156d7ae68dfcb818628389c42158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all bits in the specified closed interval [left,right].  <a href="#afd89156d7ae68dfcb818628389c42158">More...</a><br /></td></tr>
<tr class="separator:afd89156d7ae68dfcb818628389c42158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ac87e9de75219d1dd81bbc7e5da58a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac9ac87e9de75219d1dd81bbc7e5da58a">clear_bit</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="memdesc:ac9ac87e9de75219d1dd81bbc7e5da58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bit n.  <a href="#ac9ac87e9de75219d1dd81bbc7e5da58a">More...</a><br /></td></tr>
<tr class="separator:ac9ac87e9de75219d1dd81bbc7e5da58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4393f22ba0da527ba19e2829289a893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac4393f22ba0da527ba19e2829289a893">clear_bit_no_check</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="memdesc:ac4393f22ba0da527ba19e2829289a893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bit n without precondiion checks.  <a href="#ac4393f22ba0da527ba19e2829289a893">More...</a><br /></td></tr>
<tr class="separator:ac4393f22ba0da527ba19e2829289a893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eab84a88eabdee3a3afd1792df76110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a4eab84a88eabdee3a3afd1792df76110">clear</a> (bool free_mem=false)</td></tr>
<tr class="memdesc:a4eab84a88eabdee3a3afd1792df76110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears every bit in the bitvector.  <a href="#a4eab84a88eabdee3a3afd1792df76110">More...</a><br /></td></tr>
<tr class="separator:a4eab84a88eabdee3a3afd1792df76110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1280ff08a2b1f4377ca15df081781f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac1280ff08a2b1f4377ca15df081781f8">reset</a> ()</td></tr>
<tr class="memdesc:ac1280ff08a2b1f4377ca15df081781f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears every bit in the bitvector.  <a href="#ac1280ff08a2b1f4377ca15df081781f8">More...</a><br /></td></tr>
<tr class="separator:ac1280ff08a2b1f4377ca15df081781f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a75eb8e2857dd05a4fd45c545f9902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab2a75eb8e2857dd05a4fd45c545f9902">flip</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)</td></tr>
<tr class="memdesc:ab2a75eb8e2857dd05a4fd45c545f9902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips bit n.  <a href="#ab2a75eb8e2857dd05a4fd45c545f9902">More...</a><br /></td></tr>
<tr class="separator:ab2a75eb8e2857dd05a4fd45c545f9902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaf87e9eb001e03c8828c7a92d9ab4e90">flip</a> ()</td></tr>
<tr class="memdesc:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all bits.  <a href="#aaf87e9eb001e03c8828c7a92d9ab4e90">More...</a><br /></td></tr>
<tr class="separator:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>By default bvector is dynamically sized, manual control methods available </p>
</div></td></tr>
<tr class="memitem:af5a216c869877b33e991b7ff14b6d5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af5a216c869877b33e991b7ff14b6d5dd">capacity</a> () const</td></tr>
<tr class="memdesc:af5a216c869877b33e991b7ff14b6d5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns bvector's capacity (number of bits it can store)  <a href="#af5a216c869877b33e991b7ff14b6d5dd">More...</a><br /></td></tr>
<tr class="separator:af5a216c869877b33e991b7ff14b6d5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105aeb50ff3b085db6f592793914c9f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a105aeb50ff3b085db6f592793914c9f9">size</a> () const</td></tr>
<tr class="memdesc:a105aeb50ff3b085db6f592793914c9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return current size of the vector (bits)  <a href="#a105aeb50ff3b085db6f592793914c9f9">More...</a><br /></td></tr>
<tr class="separator:a105aeb50ff3b085db6f592793914c9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b7573c759e51c8943cf95a82a5b9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a56b7573c759e51c8943cf95a82a5b9d6">resize</a> (<a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a> new_size)</td></tr>
<tr class="memdesc:a56b7573c759e51c8943cf95a82a5b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size of the bvector.  <a href="#a56b7573c759e51c8943cf95a82a5b9d6">More...</a><br /></td></tr>
<tr class="separator:a56b7573c759e51c8943cf95a82a5b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Population counting and ranking methods</div></td></tr>
<tr class="memitem:ad012390ff13532528a8e25bf433de544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad012390ff13532528a8e25bf433de544">count</a> () const</td></tr>
<tr class="memdesc:ad012390ff13532528a8e25bf433de544"><td class="mdescLeft">&#160;</td><td class="mdescRight">population cout (count of ON bits)  <a href="#ad012390ff13532528a8e25bf433de544">More...</a><br /></td></tr>
<tr class="separator:ad012390ff13532528a8e25bf433de544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf06ad417831a404cc8565612ed1d8d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abaf06ad417831a404cc8565612ed1d8d">count_blocks</a> (unsigned *arr) const</td></tr>
<tr class="memdesc:abaf06ad417831a404cc8565612ed1d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitcount values for all bvector blocks.  <a href="#abaf06ad417831a404cc8565612ed1d8d">More...</a><br /></td></tr>
<tr class="separator:abaf06ad417831a404cc8565612ed1d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35430ed12f7880574dd2eb499269f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acb35430ed12f7880574dd2eb499269f7">count_range</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right, const unsigned *block_count_arr=0) const</td></tr>
<tr class="memdesc:acb35430ed12f7880574dd2eb499269f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits in the given range.  <a href="#acb35430ed12f7880574dd2eb499269f7">More...</a><br /></td></tr>
<tr class="separator:acb35430ed12f7880574dd2eb499269f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc1b143c58296a0c52ba6039cd15ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aedc1b143c58296a0c52ba6039cd15ab9">running_count_blocks</a> (<a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> *blocks_cnt) const</td></tr>
<tr class="memdesc:aedc1b143c58296a0c52ba6039cd15ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute running total of all blocks in bit vector  <a href="#aedc1b143c58296a0c52ba6039cd15ab9">More...</a><br /></td></tr>
<tr class="separator:aedc1b143c58296a0c52ba6039cd15ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d0ee9f9a50a44e6a6d5830fdacd12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#add7d0ee9f9a50a44e6a6d5830fdacd12">build_rs_index</a> (<a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> *rs_idx) const</td></tr>
<tr class="memdesc:add7d0ee9f9a50a44e6a6d5830fdacd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute running total of all blocks in bit vector (rank-select index)  <a href="#add7d0ee9f9a50a44e6a6d5830fdacd12">More...</a><br /></td></tr>
<tr class="separator:add7d0ee9f9a50a44e6a6d5830fdacd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf058731b3a7a77c6aedf40e8dd730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a52cf058731b3a7a77c6aedf40e8dd730">count_to</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;blocks_cnt) const</td></tr>
<tr class="memdesc:a52cf058731b3a7a77c6aedf40e8dd730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits (population) in [0..right] range.  <a href="#a52cf058731b3a7a77c6aedf40e8dd730">More...</a><br /></td></tr>
<tr class="separator:a52cf058731b3a7a77c6aedf40e8dd730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">rank</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;rs_idx) const</td></tr>
<tr class="memdesc:aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rank of specified bit position.  <a href="#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">More...</a><br /></td></tr>
<tr class="separator:aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae3b0a7a9aff8e43a84bd8504eb853d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a8ae3b0a7a9aff8e43a84bd8504eb853d">count_to_test</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;blocks_cnt) const</td></tr>
<tr class="memdesc:a8ae3b0a7a9aff8e43a84bd8504eb853d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits (population) in [0..right] range if test(right) == true.  <a href="#a8ae3b0a7a9aff8e43a84bd8504eb853d">More...</a><br /></td></tr>
<tr class="separator:a8ae3b0a7a9aff8e43a84bd8504eb853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ebd6c8f81a36679b26c6c7535da78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad88ebd6c8f81a36679b26c6c7535da78">recalc_count</a> ()</td></tr>
<tr class="separator:ad88ebd6c8f81a36679b26c6c7535da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c870f1b54b6b54a3f52d84c4cb3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af77c870f1b54b6b54a3f52d84c4cb3ae">forget_count</a> ()</td></tr>
<tr class="separator:af77c870f1b54b6b54a3f52d84c4cb3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit access (read-only)</div></td></tr>
<tr class="memitem:a267ed9d3782cc6f10a9d04a4a5e80074"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a267ed9d3782cc6f10a9d04a4a5e80074">get_bit</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n) const</td></tr>
<tr class="memdesc:a267ed9d3782cc6f10a9d04a4a5e80074"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if bit n is set and false is bit n is 0.  <a href="#a267ed9d3782cc6f10a9d04a4a5e80074">More...</a><br /></td></tr>
<tr class="separator:a267ed9d3782cc6f10a9d04a4a5e80074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf474232920c5a01c88db1f85608b79b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abf474232920c5a01c88db1f85608b79b">test</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n) const</td></tr>
<tr class="memdesc:abf474232920c5a01c88db1f85608b79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if bit n is set and false is bit n is 0.  <a href="#abf474232920c5a01c88db1f85608b79b">More...</a><br /></td></tr>
<tr class="separator:abf474232920c5a01c88db1f85608b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">bit-shift and insert operations</div></td></tr>
<tr class="memitem:aacf96380ec223d52340a60ec57c8bdbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aacf96380ec223d52340a60ec57c8bdbd">shift_right</a> ()</td></tr>
<tr class="memdesc:aacf96380ec223d52340a60ec57c8bdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift right by 1 bit, fill with zero return carry over.  <a href="#aacf96380ec223d52340a60ec57c8bdbd">More...</a><br /></td></tr>
<tr class="separator:aacf96380ec223d52340a60ec57c8bdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d54f9c0d104464a63082bf9ba70284"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab1d54f9c0d104464a63082bf9ba70284">insert</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, bool value)</td></tr>
<tr class="memdesc:ab1d54f9c0d104464a63082bf9ba70284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert bit into specified position All the vector content after position is shifted right.  <a href="#ab1d54f9c0d104464a63082bf9ba70284">More...</a><br /></td></tr>
<tr class="separator:ab1d54f9c0d104464a63082bf9ba70284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check for empty-ness of container</div></td></tr>
<tr class="memitem:ad7aca9a02246fea29236065adf0c2790"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad7aca9a02246fea29236065adf0c2790">any</a> () const</td></tr>
<tr class="memdesc:ad7aca9a02246fea29236065adf0c2790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any bits in this bitset are set, and otherwise returns false.  <a href="#ad7aca9a02246fea29236065adf0c2790">More...</a><br /></td></tr>
<tr class="separator:ad7aca9a02246fea29236065adf0c2790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ecc1abf8ac09c5c29b1c668811ab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3e7ecc1abf8ac09c5c29b1c668811ab7">none</a> () const</td></tr>
<tr class="memdesc:a3e7ecc1abf8ac09c5c29b1c668811ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no bits are set, otherwise returns false.  <a href="#a3e7ecc1abf8ac09c5c29b1c668811ab7">More...</a><br /></td></tr>
<tr class="separator:a3e7ecc1abf8ac09c5c29b1c668811ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scan and find bits and indexes</div></td></tr>
<tr class="memitem:a16d604b466f187f725e34a5e9ee38e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a16d604b466f187f725e34a5e9ee38e2a">find</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos) const</td></tr>
<tr class="memdesc:a16d604b466f187f725e34a5e9ee38e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds index of first 1 bit.  <a href="#a16d604b466f187f725e34a5e9ee38e2a">More...</a><br /></td></tr>
<tr class="separator:a16d604b466f187f725e34a5e9ee38e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21238b77210e1d723afe8af4a4208bff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a21238b77210e1d723afe8af4a4208bff">find</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> from, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos) const</td></tr>
<tr class="memdesc:a21238b77210e1d723afe8af4a4208bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds index of 1 bit starting from position.  <a href="#a21238b77210e1d723afe8af4a4208bff">More...</a><br /></td></tr>
<tr class="separator:a21238b77210e1d723afe8af4a4208bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a165efa0b14f6c89eb1263ff88cbd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4">get_first</a> () const</td></tr>
<tr class="memdesc:ad3a165efa0b14f6c89eb1263ff88cbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actually set or bit-vector is empty  <a href="#ad3a165efa0b14f6c89eb1263ff88cbd4">More...</a><br /></td></tr>
<tr class="separator:ad3a165efa0b14f6c89eb1263ff88cbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973d2b45365c993fe27b9d3513dc848f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f">get_next</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev) const</td></tr>
<tr class="memdesc:a973d2b45365c993fe27b9d3513dc848f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of the next bit ON.  <a href="#a973d2b45365c993fe27b9d3513dc848f">More...</a><br /></td></tr>
<tr class="separator:a973d2b45365c993fe27b9d3513dc848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ff4b9bd8fdf35e40ba1eba67446e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37">extract_next</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev)</td></tr>
<tr class="memdesc:a30ff4b9bd8fdf35e40ba1eba67446e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of the next bit ON and sets it to 0.  <a href="#a30ff4b9bd8fdf35e40ba1eba67446e37">More...</a><br /></td></tr>
<tr class="separator:a30ff4b9bd8fdf35e40ba1eba67446e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b1d4bab9143870fc476a3a920a89e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e">find_reverse</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos) const</td></tr>
<tr class="memdesc:a708b1d4bab9143870fc476a3a920a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds last index of 1 bit.  <a href="#a708b1d4bab9143870fc476a3a920a89e">More...</a><br /></td></tr>
<tr class="separator:a708b1d4bab9143870fc476a3a920a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a579d1002435b8c04a37bc34c5057b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a40a579d1002435b8c04a37bc34c5057b">find_range</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;<a class="el" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;last) const</td></tr>
<tr class="memdesc:a40a579d1002435b8c04a37bc34c5057b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds dynamic range of bit-vector [first, last].  <a href="#a40a579d1002435b8c04a37bc34c5057b">More...</a><br /></td></tr>
<tr class="separator:a40a579d1002435b8c04a37bc34c5057b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cb380d6481c423831868a2b3fd3c34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab4cb380d6481c423831868a2b3fd3c34">find_rank</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">rank</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> from, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos) const</td></tr>
<tr class="memdesc:ab4cb380d6481c423831868a2b3fd3c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bit-vector position for the specified rank(bitcount)  <a href="#ab4cb380d6481c423831868a2b3fd3c34">More...</a><br /></td></tr>
<tr class="separator:ab4cb380d6481c423831868a2b3fd3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4e4aa2cc2976b1ce21109fa52e3c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a34d4e4aa2cc2976b1ce21109fa52e3c9">find_rank</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">rank</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> from, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos, const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;blocks_cnt) const</td></tr>
<tr class="memdesc:a34d4e4aa2cc2976b1ce21109fa52e3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bit-vector position for the specified rank(bitcount)  <a href="#a34d4e4aa2cc2976b1ce21109fa52e3c9">More...</a><br /></td></tr>
<tr class="separator:a34d4e4aa2cc2976b1ce21109fa52e3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53af203265080beff109b18dd386215"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215">select</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">rank</a>, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;pos, const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;blocks_cnt) const</td></tr>
<tr class="memdesc:ad53af203265080beff109b18dd386215"><td class="mdescLeft">&#160;</td><td class="mdescRight">select bit-vector position for the specified rank(bitcount)  <a href="#ad53af203265080beff109b18dd386215">More...</a><br /></td></tr>
<tr class="separator:ad53af203265080beff109b18dd386215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebra of Sets operations</div></td></tr>
<tr class="memitem:a644c6a6aaf089f8dad99f6186d8c15c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a644c6a6aaf089f8dad99f6186d8c15c4">bit_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode)</td></tr>
<tr class="memdesc:a644c6a6aaf089f8dad99f6186d8c15c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand OR : this := bv1 OR bv2  <a href="#a644c6a6aaf089f8dad99f6186d8c15c4">More...</a><br /></td></tr>
<tr class="separator:a644c6a6aaf089f8dad99f6186d8c15c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae515fb7bf11888bcb40bbab6857e5818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae515fb7bf11888bcb40bbab6857e5818">bit_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode)</td></tr>
<tr class="memdesc:ae515fb7bf11888bcb40bbab6857e5818"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand XOR : this := bv1 XOR bv2  <a href="#ae515fb7bf11888bcb40bbab6857e5818">More...</a><br /></td></tr>
<tr class="separator:ae515fb7bf11888bcb40bbab6857e5818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cf32926e9d0b84f5d626e9c14f5776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a46cf32926e9d0b84f5d626e9c14f5776">bit_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode)</td></tr>
<tr class="memdesc:a46cf32926e9d0b84f5d626e9c14f5776"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand AND : this := bv1 AND bv2  <a href="#a46cf32926e9d0b84f5d626e9c14f5776">More...</a><br /></td></tr>
<tr class="separator:a46cf32926e9d0b84f5d626e9c14f5776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e792a63fd3bbc2ca48108a362550bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aa9e792a63fd3bbc2ca48108a362550bb">bit_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode)</td></tr>
<tr class="memdesc:aa9e792a63fd3bbc2ca48108a362550bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT  <a href="#aa9e792a63fd3bbc2ca48108a362550bb">More...</a><br /></td></tr>
<tr class="separator:aa9e792a63fd3bbc2ca48108a362550bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aee4b63ca79de51765a89a2d37cd6f5bf">bit_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical OR  <a href="#aee4b63ca79de51765a89a2d37cd6f5bf">More...</a><br /></td></tr>
<tr class="separator:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403f2fd49192ce251618f53a693bc36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a2403f2fd49192ce251618f53a693bc36">bit_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:a2403f2fd49192ce251618f53a693bc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical AND  <a href="#a2403f2fd49192ce251618f53a693bc36">More...</a><br /></td></tr>
<tr class="separator:a2403f2fd49192ce251618f53a693bc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae087c7b4d78f00d7b04ea0e9e4915ba3">bit_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical XOR  <a href="#ae087c7b4d78f00d7b04ea0e9e4915ba3">More...</a><br /></td></tr>
<tr class="separator:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5659f54365fb0a7714a3c3282ca481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aeb5659f54365fb0a7714a3c3282ca481">bit_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:aeb5659f54365fb0a7714a3c3282ca481"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical SUB(AND NOT). Also known as MINUS.  <a href="#aeb5659f54365fb0a7714a3c3282ca481">More...</a><br /></td></tr>
<tr class="separator:aeb5659f54365fb0a7714a3c3282ca481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e95553f358ebebda6b521336682deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a27e95553f358ebebda6b521336682deb">invert</a> ()</td></tr>
<tr class="memdesc:a27e95553f358ebebda6b521336682deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert/NEG all bits It should be noted, invert is affected by <a class="el" href="classbm_1_1bvector.html#a105aeb50ff3b085db6f592793914c9f9" title="return current size of the vector (bits) ">size()</a> if size is set - it only inverts [0..size-1] bits.  <a href="#a27e95553f358ebebda6b521336682deb">More...</a><br /></td></tr>
<tr class="separator:a27e95553f358ebebda6b521336682deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a> opcode)</td></tr>
<tr class="memdesc:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation by operation code  <a href="#ae57f6d62d1f54eeaa604ae7ce53e0e0f">More...</a><br /></td></tr>
<tr class="separator:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1084ec5fad8c1faf50d31a182dc4287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac1084ec5fad8c1faf50d31a182dc4287">combine_operation_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:ac1084ec5fad8c1faf50d31a182dc4287"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation OR  <a href="#ac1084ec5fad8c1faf50d31a182dc4287">More...</a><br /></td></tr>
<tr class="separator:ac1084ec5fad8c1faf50d31a182dc4287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a25bb679772c3d0adee3dbd4d02f7e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7a25bb679772c3d0adee3dbd4d02f7e3">combine_operation_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a7a25bb679772c3d0adee3dbd4d02f7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation AND  <a href="#a7a25bb679772c3d0adee3dbd4d02f7e3">More...</a><br /></td></tr>
<tr class="separator:a7a25bb679772c3d0adee3dbd4d02f7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc454e79b5261f7c4859cac74aa81832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acc454e79b5261f7c4859cac74aa81832">combine_operation_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:acc454e79b5261f7c4859cac74aa81832"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation MINUS (AND NOT)  <a href="#acc454e79b5261f7c4859cac74aa81832">More...</a><br /></td></tr>
<tr class="separator:acc454e79b5261f7c4859cac74aa81832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311f59a89c8b75a252fc7e55400ea2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a311f59a89c8b75a252fc7e55400ea2e4">combine_operation_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a311f59a89c8b75a252fc7e55400ea2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation XOR  <a href="#a311f59a89c8b75a252fc7e55400ea2e4">More...</a><br /></td></tr>
<tr class="separator:a311f59a89c8b75a252fc7e55400ea2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator-traversal methods</div></td></tr>
<tr class="memitem:a86b939f3aed555dc073e8c26e9efea71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a> () const</td></tr>
<tr class="memdesc:a86b939f3aed555dc073e8c26e9efea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on the first non-zero bit.  <a href="#a86b939f3aed555dc073e8c26e9efea71">More...</a><br /></td></tr>
<tr class="separator:a86b939f3aed555dc073e8c26e9efea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937cd13482984f234a5d94cc638c22b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a> () const</td></tr>
<tr class="memdesc:a937cd13482984f234a5d94cc638c22b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on the next bit after the last.  <a href="#a937cd13482984f234a5d94cc638c22b5">More...</a><br /></td></tr>
<tr class="separator:a937cd13482984f234a5d94cc638c22b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceae1bb9ce9a7471f7343d0d4da4ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aeceae1bb9ce9a7471f7343d0d4da4ed5">get_enumerator</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> pos) const</td></tr>
<tr class="memdesc:aeceae1bb9ce9a7471f7343d0d4da4ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on specified or the next available bit.  <a href="#aeceae1bb9ce9a7471f7343d0d4da4ed5">More...</a><br /></td></tr>
<tr class="separator:aeceae1bb9ce9a7471f7343d0d4da4ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory management and compression</div></td></tr>
<tr class="memitem:a984a4f43724ebd9d840a36a3aa0eacca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a984a4f43724ebd9d840a36a3aa0eacca">calc_stat</a> (struct <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *st) const</td></tr>
<tr class="memdesc:a984a4f43724ebd9d840a36a3aa0eacca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates bitvector statistics.  <a href="#a984a4f43724ebd9d840a36a3aa0eacca">More...</a><br /></td></tr>
<tr class="separator:a984a4f43724ebd9d840a36a3aa0eacca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ee052b297a49c35344704df67a452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452">set_new_blocks_strat</a> (<a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat)</td></tr>
<tr class="memdesc:a653ee052b297a49c35344704df67a452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new blocks allocation strategy.  <a href="#a653ee052b297a49c35344704df67a452">More...</a><br /></td></tr>
<tr class="separator:a653ee052b297a49c35344704df67a452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce99c7eed57bcf2c89ceb0dc0553a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a0bce99c7eed57bcf2c89ceb0dc0553a6">get_new_blocks_strat</a> () const</td></tr>
<tr class="memdesc:a0bce99c7eed57bcf2c89ceb0dc0553a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns blocks allocation strategy.  <a href="#a0bce99c7eed57bcf2c89ceb0dc0553a6">More...</a><br /></td></tr>
<tr class="separator:a0bce99c7eed57bcf2c89ceb0dc0553a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622e6827d799a561e2f0db28f7ac19d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *temp_block=0, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a>, <a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *stat=0)</td></tr>
<tr class="memdesc:a622e6827d799a561e2f0db28f7ac19d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize memory bitvector's memory allocation.  <a href="#a622e6827d799a561e2f0db28f7ac19d2">More...</a><br /></td></tr>
<tr class="separator:a622e6827d799a561e2f0db28f7ac19d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2d954f42ea75520b8795066302daab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaa2d954f42ea75520b8795066302daab">optimize_gap_size</a> ()</td></tr>
<tr class="memdesc:aaa2d954f42ea75520b8795066302daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize sizes of GAP blocks.  <a href="#aaa2d954f42ea75520b8795066302daab">More...</a><br /></td></tr>
<tr class="separator:aaa2d954f42ea75520b8795066302daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a14f9b220fec8e7b65e4e5ed2832af96b">set_gap_levels</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len)</td></tr>
<tr class="memdesc:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme.  <a href="#a14f9b220fec8e7b65e4e5ed2832af96b">More...</a><br /></td></tr>
<tr class="separator:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:a38404509c80ec69e1075092f436a958e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a38404509c80ec69e1075092f436a958e">compare</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) const</td></tr>
<tr class="memdesc:a38404509c80ec69e1075092f436a958e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison with a bitvector.  <a href="#a38404509c80ec69e1075092f436a958e">More...</a><br /></td></tr>
<tr class="separator:a38404509c80ec69e1075092f436a958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Open internals</div></td></tr>
<tr class="memitem:a2e36aefebc64e6a88d03353d29f03dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a2e36aefebc64e6a88d03353d29f03dfb">combine_operation_with_block</a> (unsigned nb, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, bool arg_gap, <a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a> opcode)</td></tr>
<tr class="separator:a2e36aefebc64e6a88d03353d29f03dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a21e8a9f8362908e073eb4d8b0ca1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a285a21e8a9f8362908e073eb4d8b0ca1">get_blocks_manager</a> () const</td></tr>
<tr class="memdesc:a285a21e8a9f8362908e073eb4d8b0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get access to memory manager (internal) Use only if you are BitMagic library  <a href="#a285a21e8a9f8362908e073eb4d8b0ca1">More...</a><br /></td></tr>
<tr class="separator:a285a21e8a9f8362908e073eb4d8b0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe10cd231a9fe147810ba8d359cefac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afe10cd231a9fe147810ba8d359cefac1">get_blocks_manager</a> ()</td></tr>
<tr class="memdesc:afe10cd231a9fe147810ba8d359cefac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get access to memory manager (internal) Use only if you are BitMagic library  <a href="#afe10cd231a9fe147810ba8d359cefac1">More...</a><br /></td></tr>
<tr class="separator:afe10cd231a9fe147810ba8d359cefac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a38b7223ef1dc03d8b02b6feefea8e01b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a38b7223ef1dc03d8b02b6feefea8e01b">throw_bad_alloc</a> ()</td></tr>
<tr class="separator:a38b7223ef1dc03d8b02b6feefea8e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4c6c213804cd440ce15ede3d374f0c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a4c6c213804cd440ce15ede3d374f0c69">sync_size</a> ()</td></tr>
<tr class="memdesc:a4c6c213804cd440ce15ede3d374f0c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncronize size if it got extended due to bulk import.  <a href="#a4c6c213804cd440ce15ede3d374f0c69">More...</a><br /></td></tr>
<tr class="separator:a4c6c213804cd440ce15ede3d374f0c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456c6c5c91e482eaaf99824fe054b076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a456c6c5c91e482eaaf99824fe054b076">import</a> (const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *ids, unsigned ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> sorted_idx)</td></tr>
<tr class="memdesc:a456c6c5c91e482eaaf99824fe054b076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import integers (set bits).  <a href="#a456c6c5c91e482eaaf99824fe054b076">More...</a><br /></td></tr>
<tr class="separator:a456c6c5c91e482eaaf99824fe054b076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340255085db3f10b9092892aa17138d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aa340255085db3f10b9092892aa17138d">import_block</a> (const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *ids, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> nblock, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> start, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> stop)</td></tr>
<tr class="separator:aa340255085db3f10b9092892aa17138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeec1461fca400b5b4313765eb9e94c73"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aeec1461fca400b5b4313765eb9e94c73">iterator_base</a></td></tr>
<tr class="separator:aeec1461fca400b5b4313765eb9e94c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cabca9670588878381f72d16e059b8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a71cabca9670588878381f72d16e059b8">enumerator</a></td></tr>
<tr class="separator:a71cabca9670588878381f72d16e059b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b713f8799df176e5ab5da91d782bf3"><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr class="memitem:a27b713f8799df176e5ab5da91d782bf3"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a27b713f8799df176e5ab5da91d782bf3">aggregator</a></td></tr>
<tr class="separator:a27b713f8799df176e5ab5da91d782bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Alloc&gt;<br />
class bm::bvector&lt; Alloc &gt;</h3>

<p>Bitvector Bit-vector container with runtime compression of bits. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#_a11">bvsetalgebra.cpp</a>, <a class="el" href="sample14_8cpp-example.html#_a11">sample14.cpp</a>, <a class="el" href="sample4_8cpp-example.html#_a16">sample4.cpp</a>, and <a class="el" href="sample6_8cpp-example.html#_a10">sample6.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00135">135</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2c8990a2147fdc3e6094011e77e559e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8990a2147fdc3e6094011e77e559e8">&#9670;&nbsp;</a></span>allocator_pool_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::allocator_pool_type <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00139">139</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ad1dbe63690fd5cd2b1e064795d3f1b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dbe63690fd5cd2b1e064795d3f1b6c">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00138">138</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a37233698b671258ed4aaacf95fbc6b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37233698b671258ed4aaacf95fbc6b53">&#9670;&nbsp;</a></span>blocks_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbm_1_1rs__index.html">rs_index</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a37233698b671258ed4aaacf95fbc6b53">blocks_count</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01254">1254</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a6fdfeafe05217c31cdc9140b7642b611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdfeafe05217c31cdc9140b7642b611">&#9670;&nbsp;</a></span>blocks_manager_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef blocks_manager&lt;Alloc&gt; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00140">140</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a04d7ea71a6e69abb26e03b31f93e6689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d7ea71a6e69abb26e03b31f93e6689">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a04d7ea71a6e69abb26e03b31f93e6689">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00253">253</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a309afd0facb857c5591f88a1fee276b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309afd0facb857c5591f88a1fee276b4">&#9670;&nbsp;</a></span>rs_index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbm_1_1rs__index.html">rs_index</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01255">1255</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a405dd9ed048c935c84a5086ec8ba3649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405dd9ed048c935c84a5086ec8ba3649">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00141">141</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a05f1e977cb5e6208838afc7e7b69e5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1e977cb5e6208838afc7e7b69e5f0">&#9670;&nbsp;</a></span>optmode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">bm::bvector::optmode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization mode Every next level means additional checks (better compression vs time) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660"></a>opt_none&#160;</td><td class="fielddoc"><p>no optimization </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe"></a>opt_free_0&#160;</td><td class="fielddoc"><p>Free unused 0 blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc"></a>opt_free_01&#160;</td><td class="fielddoc"><p>Free unused 0 and 1 blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001"></a>opt_compress&#160;</td><td class="fielddoc"><p>compress blocks when possible (GAP/prefix sum) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00152">152</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a159e3c2cb32e6d098eddd9d1eac21c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159e3c2cb32e6d098eddd9d1eac21c88">&#9670;&nbsp;</a></span>bvector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code><a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em> = <code><a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt;true&gt;::_len</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a>&#160;</td>
          <td class="paramname"><em>bv_size</em> = <code><a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs bvector class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strat</td><td>- operation mode strategy, BM_BIT - default strategy, bvector use plain bitset blocks, (performance oriented strategy). BM_GAP - memory effitent strategy, bvector allocates blocks as array of intervals(gaps) and convert blocks into plain bitsets only when enthropy grows. </td></tr>
    <tr><td class="paramname">glevel_len</td><td><ul>
<li>pointer on C-style array keeping GAP block sizes. <a class="el" href="structbm_1_1gap__len__table.html#af9260645490e8cac0769ba84847d4512">bm::gap_len_table&lt;true&gt;::_len</a> - default value set (use <a class="el" href="structbm_1_1gap__len__table__min.html#a7049262dea6250b11522da8e8359eefc">bm::gap_len_table_min&lt;true&gt;::_len</a> for very sparse vectors) (use <a class="el" href="structbm_1_1gap__len__table__nl.html#acdb994f54c823e7b2803e19fc06b7098">bm::gap_len_table_nl&lt;true&gt;::_len</a> non-linear GAP growth) </li>
</ul>
</td></tr>
    <tr><td class="paramname">bv_size</td><td><ul>
<li>bvector size (number of bits addressable by bvector), <a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a> means "no limits" (recommended). bit vector allocates this space dynamically on demand. </li>
</ul>
</td></tr>
    <tr><td class="paramname">alloc</td><td>- alllocator for this instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbm_1_1gap__len__table.html" title="Default GAP lengths table. ">bm::gap_len_table</a> <a class="el" href="structbm_1_1gap__len__table__min.html" title="Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets. ">bm::gap_len_table_min</a> <a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452" title="Sets new blocks allocation strategy. ">set_new_blocks_strat</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01281">1281</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ae54e579bdddadece60dcfa519d18a1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54e579bdddadece60dcfa519d18a1c5">&#9670;&nbsp;</a></span>bvector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a>&#160;</td>
          <td class="paramname"><em>bv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code><a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em> = <code><a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt;true&gt;::_len</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs bvector class. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01293">1293</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a608b979d18211645c625e1bcd41cf307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b979d18211645c625e1bcd41cf307">&#9670;&nbsp;</a></span>bvector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01305">1305</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a359e850745b9901b5b6e7be08ae9713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359e850745b9901b5b6e7be08ae9713d">&#9670;&nbsp;</a></span>bvector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for range copy [left..right]. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#afd89156d7ae68dfcb818628389c42158" title="Copy all bits in the specified closed interval [left,right]. ">copy_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01316">1316</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ae78c55229da6a419352d4d97a0827da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78c55229da6a419352d4d97a0827da2">&#9670;&nbsp;</a></span>~bvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::~<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01329">1329</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="aa57196373d4b83d0cab1bd3f2b80c1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57196373d4b83d0cab1bd3f2b80c1c5">&#9670;&nbsp;</a></span>bvector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01353">1353</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a3dd521f397836d4d38c7f621a239061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd521f397836d4d38c7f621a239061b">&#9670;&nbsp;</a></span>bvector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Brace constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01364">1364</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7aca9a02246fea29236065adf0c2790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aca9a02246fea29236065adf0c2790">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any bits in this bitset are set, and otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any bit is set </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02486">2486</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample04_8cpp_source.html#l00250">DNA_FingerprintScanner::Find()</a>.</p>

</div>
</div>
<a id="a46cf32926e9d0b84f5d626e9c14f5776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cf32926e9d0b84f5d626e9c14f5776">&#9670;&nbsp;</a></span>bit_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand AND : this := bv1 AND bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a46cf32926e9d0b84f5d626e9c14f5776" title="3-operand AND : this := bv1 AND bv2 ">bit_and</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04552">4552</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01733">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::filter()</a>, and <a class="el" href="bm_8h_source.html#l02362">bm::operator &amp;()</a>.</p>

</div>
</div>
<a id="a2403f2fd49192ce251618f53a693bc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2403f2fd49192ce251618f53a693bc36">&#9670;&nbsp;</a></span>bit_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical AND </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02034">2034</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a644c6a6aaf089f8dad99f6186d8c15c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644c6a6aaf089f8dad99f6186d8c15c4">&#9670;&nbsp;</a></span>bit_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand OR : this := bv1 OR bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a644c6a6aaf089f8dad99f6186d8c15c4" title="3-operand OR : this := bv1 OR bv2 ">bit_or</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04386">4386</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00095">DemoOR()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00056">bm::dynamic_range_clip_high()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00097">bm::dynamic_range_clip_low()</a>, and <a class="el" href="bm_8h_source.html#l02373">bm::operator|()</a>.</p>

</div>
</div>
<a id="aee4b63ca79de51765a89a2d37cd6f5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4b63ca79de51765a89a2d37cd6f5bf">&#9670;&nbsp;</a></span>bit_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical OR </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- Argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02024">2024</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="aa9e792a63fd3bbc2ca48108a362550bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e792a63fd3bbc2ca48108a362550bb">&#9670;&nbsp;</a></span>bit_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize</a>, <a class="el" href="classbm_1_1bvector.html#aa9e792a63fd3bbc2ca48108a362550bb" title="3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT ">bit_sub</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04637">4637</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00404">DemoSUB()</a>, and <a class="el" href="bm_8h_source.html#l02395">bm::operator-()</a>.</p>

</div>
</div>
<a id="aeb5659f54365fb0a7714a3c3282ca481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5659f54365fb0a7714a3c3282ca481">&#9670;&nbsp;</a></span>bit_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical SUB(AND NOT). Also known as MINUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02054">2054</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ae515fb7bf11888bcb40bbab6857e5818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae515fb7bf11888bcb40bbab6857e5818">&#9670;&nbsp;</a></span>bit_xor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand XOR : this := bv1 XOR bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation. ">optimize</a>, <a class="el" href="classbm_1_1bvector.html#ae515fb7bf11888bcb40bbab6857e5818" title="3-operand XOR : this := bv1 XOR bv2 ">bit_xor</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04464">4464</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00331">DemoXOR()</a>, and <a class="el" href="bm_8h_source.html#l02384">bm::operator^()</a>.</p>

</div>
</div>
<a id="ae087c7b4d78f00d7b04ea0e9e4915ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae087c7b4d78f00d7b04ea0e9e4915ba3">&#9670;&nbsp;</a></span>bit_xor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical XOR </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02044">2044</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="add7d0ee9f9a50a44e6a6d5830fdacd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7d0ee9f9a50a44e6a6d5830fdacd12">&#9670;&nbsp;</a></span>build_rs_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::build_rs_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> *&#160;</td>
          <td class="paramname"><em>rs_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute running total of all blocks in bit vector (rank-select index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs_idx</td><td>- [out] pointer to index / count structure Function will fill full array of running totals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a52cf058731b3a7a77c6aedf40e8dd730" title="Returns count of 1 bits (population) in [0..right] range. ">count_to</a>, <a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215" title="select bit-vector position for the specified rank(bitcount) ">select</a>, <a class="el" href="classbm_1_1bvector.html#ab4cb380d6481c423831868a2b3fd3c34" title="Find bit-vector position for the specified rank(bitcount) ">find_rank</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01712">1712</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00181">bv_count_to_acc()</a>, and <a class="el" href="sample11_8cpp_source.html#l00207">bv_count_to_range_acc()</a>.</p>

</div>
</div>
<a id="a984a4f43724ebd9d840a36a3aa0eacca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984a4f43724ebd9d840a36a3aa0eacca">&#9670;&nbsp;</a></span>calc_stat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::calc_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates bitvector statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>- pointer on statistics structure to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<p>Function fills statistics structure containing information about how this vector uses memory and estimation of max. amount of memory bvector needs to serialize itself.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbm_1_1bvector_1_1statistics.html" title="Statistical information about bitset&#39;s memory allocation details. ">statistics</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a30">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03193">3193</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00281">calc_memory_footprint()</a>, <a class="el" href="xsample01_8cpp_source.html#l00303">convert_bv2bvs()</a>, <a class="el" href="sample11_8cpp_source.html#l00057">generate_bvector()</a>, and <a class="el" href="sample3_8cpp_source.html#l00060">print_statistics()</a>.</p>

</div>
</div>
<a id="af5a216c869877b33e991b7ff14b6d5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a216c869877b33e991b7ff14b6d5dd">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns bvector's capacity (number of bits it can store) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01654">1654</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ab2cc04dcf2543cc096a028ac55320312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cc04dcf2543cc096a028ac55320312">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear list of bits in this bitset </p>
<p>This is equivalent of AND NOT (Set Substract), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ade3af299b53a3d50af720192aed04791" title="Sets bit n if val is true, clears bit n if val is false. ">set</a>, <a class="el" href="classbm_1_1bvector.html#a6cd40871b6cf3868aa9ff924c4c98d57" title="Keep list of bits in this bitset, others are cleared. ">keep</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a62">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03332">3332</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00240">bv_count_and()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00404">DemoSUB()</a>, <a class="el" href="sample18_8cpp_source.html#l00042">main()</a>, <a class="el" href="xsample01_8cpp_source.html#l00553">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00612">speed_test_bvs_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00738">speed_test_sv_index()</a>, and <a class="el" href="xsample01_8cpp_source.html#l00676">speed_test_vect_index()</a>.</p>

</div>
</div>
<a id="a4eab84a88eabdee3a3afd1792df76110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eab84a88eabdee3a3afd1792df76110">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_mem</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears every bit in the bitvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_mem</td><td>if "true" (default) bvector frees the memory, otherwise sets blocks to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01611">1611</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac9ac87e9de75219d1dd81bbc7e5da58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ac87e9de75219d1dd81bbc7e5da58a">&#9670;&nbsp;</a></span>clear_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears bit n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit's index to be cleaned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if bit was cleared </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01597">1597</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac4393f22ba0da527ba19e2829289a893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4393f22ba0da527ba19e2829289a893">&#9670;&nbsp;</a></span>clear_bit_no_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears bit n without precondiion checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit's index to be cleaned. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01603">1603</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmbmatrix_8h_source.html#l00771">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::set_octet()</a>, and <a class="el" href="bmsparsevec_8h_source.html#l01464">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::set_value_no_null()</a>.</p>

</div>
</div>
<a id="ae57f6d62d1f54eeaa604ae7ce53e0e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57f6d62d1f54eeaa604ae7ce53e0e0f">&#9670;&nbsp;</a></span>combine_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation by operation code </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04995">4995</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00095">DemoOR()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00404">DemoSUB()</a>, and <a class="el" href="bvsetalgebra_8cpp_source.html#l00331">DemoXOR()</a>.</p>

</div>
</div>
<a id="a7a25bb679772c3d0adee3dbd4d02f7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a25bb679772c3d0adee3dbd4d02f7e3">&#9670;&nbsp;</a></span>combine_operation_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation AND </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04863">4863</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac1084ec5fad8c1faf50d31a182dc4287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1084ec5fad8c1faf50d31a182dc4287">&#9670;&nbsp;</a></span>combine_operation_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation OR </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04730">4730</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="acc454e79b5261f7c4859cac74aa81832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc454e79b5261f7c4859cac74aa81832">&#9670;&nbsp;</a></span>combine_operation_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation MINUS (AND NOT) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04937">4937</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a2e36aefebc64e6a88d03353d29f03dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e36aefebc64e6a88d03353d29f03dfb">&#9670;&nbsp;</a></span>combine_operation_with_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>arg_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04372">4372</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="a311f59a89c8b75a252fc7e55400ea2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311f59a89c8b75a252fc7e55400ea2e4">&#9670;&nbsp;</a></span>combine_operation_xor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation XOR </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04794">4794</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a38404509c80ec69e1075092f436a958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38404509c80ec69e1075092f436a958e">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographical comparison with a bitvector. </p>
<p>Function compares current bitvector with the provided argument bit by bit and returns -1 if our bitvector less than the argument, 1 - greater, 0 - equal. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a41">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03051">3051</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00303">convert_bv2bvs()</a>, <a class="el" href="xsample04a_8cpp_source.html#l00398">fingerprint_compare()</a>, <a class="el" href="sample14_8cpp_source.html#l00059">main()</a>, and <a class="el" href="xsample03_8cpp_source.html#l00348">run_benchmark()</a>.</p>

</div>
</div>
<a id="afd89156d7ae68dfcb818628389c42158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd89156d7ae68dfcb818628389c42158">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::copy_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all bits in the specified closed interval [left,right]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- source bit-vector </td></tr>
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06127">6127</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec_8h_source.html#l01698">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::copy_range()</a>, and <a class="el" href="bmsparsevec_8h_source.html#l01280">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::extract()</a>.</p>

</div>
</div>
<a id="ad012390ff13532528a8e25bf433de544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad012390ff13532528a8e25bf433de544">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>population cout (count of ON bits) </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of bits ON. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a43">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02468">2468</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00113">bv_count_test()</a>, <a class="el" href="xsample01_8cpp_source.html#l00365">convert_bv2vect()</a>, <a class="el" href="sample1_8cpp_source.html#l00039">main()</a>, <a class="el" href="sample11_8cpp_source.html#l00096">pre_heat()</a>, <a class="el" href="svsample05_8cpp_source.html#l00072">print_bvector()</a>, <a class="el" href="sample3_8cpp_source.html#l00060">print_statistics()</a>, <a class="el" href="xsample05_8cpp_source.html#l00300">run_benchmark()</a>, and <a class="el" href="sample4_8cpp_source.html#l00076">serialize_bvector()</a>.</p>

</div>
</div>
<a id="abaf06ad417831a404cc8565612ed1d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf06ad417831a404cc8565612ed1d8d">&#9670;&nbsp;</a></span>count_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_blocks </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitcount values for all bvector blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer on array of block bit counts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the last block counted. This number +1 gives you number of arr elements initialized during the function call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02591">2591</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00152">bv_count_range_acc()</a>.</p>

</div>
</div>
<a id="acb35430ed12f7880574dd2eb499269f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb35430ed12f7880574dd2eb499269f7">&#9670;&nbsp;</a></span>count_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block_count_arr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- index of first bit start counting from </td></tr>
    <tr><td class="paramname">right</td><td>- index of last bit </td></tr>
    <tr><td class="paramname">block_count_arr</td><td>- optional parameter (bitcount by bvector blocks) calculated by count_blocks method. Used to improve performance of wide range searches </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the diapason </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02814">2814</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00131">bv_count_range()</a>, and <a class="el" href="sample11_8cpp_source.html#l00152">bv_count_range_acc()</a>.</p>

</div>
</div>
<a id="a52cf058731b3a7a77c6aedf40e8dd730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cf058731b3a7a77c6aedf40e8dd730">&#9670;&nbsp;</a></span>count_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits (population) in [0..right] range. </p>
<p>This operation is also known as rank of bit N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to rank </td></tr>
    <tr><td class="paramname">blocks_cnt</td><td>- block count structure to accelerate search should be prepared using build_rs_index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the range [0..n] </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#add7d0ee9f9a50a44e6a6d5830fdacd12" title="compute running total of all blocks in bit vector (rank-select index) ">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a8ae3b0a7a9aff8e43a84bd8504eb853d" title="Returns count of 1 bits (population) in [0..right] range if test(right) == true. ">count_to_test</a>, <a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215" title="select bit-vector position for the specified rank(bitcount) ">select</a>, <a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd" title="Returns rank of specified bit position. ">rank</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02716">2716</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00181">bv_count_to_acc()</a>, and <a class="el" href="sample11_8cpp_source.html#l00207">bv_count_to_range_acc()</a>.</p>

</div>
</div>
<a id="a8ae3b0a7a9aff8e43a84bd8504eb853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae3b0a7a9aff8e43a84bd8504eb853d">&#9670;&nbsp;</a></span>count_to_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_to_test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits (population) in [0..right] range if test(right) == true. </p>
<p>This is conditional rank operation, which is faster than <a class="el" href="classbm_1_1bvector.html#abf474232920c5a01c88db1f85608b79b" title="returns true if bit n is set and false is bit n is 0. ">test()</a> plus <a class="el" href="classbm_1_1bvector.html#a52cf058731b3a7a77c6aedf40e8dd730" title="Returns count of 1 bits (population) in [0..right] range. ">count_to()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to test and rank </td></tr>
    <tr><td class="paramname">blocks_cnt</td><td>- block count structure to accelerate search should be prepared using running_count_blocks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the diapason or 0 if right bit test failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#aedc1b143c58296a0c52ba6039cd15ab9" title="compute running total of all blocks in bit vector ">running_count_blocks</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a52cf058731b3a7a77c6aedf40e8dd730" title="Returns count of 1 bits (population) in [0..right] range. ">count_to</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02760">2760</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a937cd13482984f234a5d94cc638c22b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937cd13482984f234a5d94cc638c22b5">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">bvector::enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on the next bit after the last. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a70">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02104">2104</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00149">combine_or_test()</a>, <a class="el" href="sample10_8cpp_source.html#l00047">main()</a>, <a class="el" href="xsample01_8cpp_source.html#l00738">speed_test_sv_index()</a>, and <a class="el" href="xsample01_8cpp_source.html#l00676">speed_test_vect_index()</a>.</p>

</div>
</div>
<a id="a30ff4b9bd8fdf35e40ba1eba67446e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ff4b9bd8fdf35e40ba1eba67446e37">&#9670;&nbsp;</a></span>extract_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::extract_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of the next bit ON and sets it to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>- Index of the previously found bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the next bit which is ON or 0 if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01883">1883</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a16d604b466f187f725e34a5e9ee38e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d604b466f187f725e34a5e9ee38e2a">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds index of first 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- index of the found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03779">3779</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample15_8cpp_source.html#l00060">main()</a>.</p>

</div>
</div>
<a id="a21238b77210e1d723afe8af4a4208bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21238b77210e1d723afe8af4a4208bff">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds index of 1 bit starting from position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- position to start search from </td></tr>
    <tr><td class="paramname">pos</td><td>- index of the found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03720">3720</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a40a579d1002435b8c04a37bc34c5057b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a579d1002435b8c04a37bc34c5057b">&#9670;&nbsp;</a></span>find_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds dynamic range of bit-vector [first, last]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- index of the first found 1 bit </td></tr>
    <tr><td class="paramname">last</td><td>- index of the last found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a16d604b466f187f725e34a5e9ee38e2a" title="Finds index of first 1 bit. ">find</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03821">3821</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample15_8cpp_source.html#l00060">main()</a>.</p>

</div>
</div>
<a id="ab4cb380d6481c423831868a2b3fd3c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cb380d6481c423831868a2b3fd3c34">&#9670;&nbsp;</a></span>find_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bit-vector position for the specified rank(bitcount) </p>
<p>Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">from</td><td>- start positioon for rank search </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03835">3835</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a34d4e4aa2cc2976b1ce21109fa52e3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d4e4aa2cc2976b1ce21109fa52e3c9">&#9670;&nbsp;</a></span>find_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bit-vector position for the specified rank(bitcount) </p>
<p>Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">from</td><td>- start positioon for rank search </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position) </td></tr>
    <tr><td class="paramname">blocks_cnt</td><td>- block count structure to accelerate rank search should be prepared using running_count_blocks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#aedc1b143c58296a0c52ba6039cd15ab9" title="compute running total of all blocks in bit vector ">running_count_blocks</a>, <a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215" title="select bit-vector position for the specified rank(bitcount) ">select</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03875">3875</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a708b1d4bab9143870fc476a3a920a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708b1d4bab9143870fc476a3a920a89e">&#9670;&nbsp;</a></span>find_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds last index of 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- index of the last found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a16d604b466f187f725e34a5e9ee38e2a" title="Finds index of first 1 bit. ">find</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03735">3735</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03332">bm::bvector&lt;&gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l03305">bm::bvector&lt;&gt;::keep()</a>, and <a class="el" href="sample15_8cpp_source.html#l00060">main()</a>.</p>

</div>
</div>
<a id="a86b939f3aed555dc073e8c26e9efea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b939f3aed555dc073e8c26e9efea71">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on the first non-zero bit. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a46">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02098">2098</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00395">bv2delta()</a>, <a class="el" href="sample11_8cpp_source.html#l00270">bv_counted_enumerator()</a>, <a class="el" href="xsample01_8cpp_source.html#l00419">convert_bv2sv()</a>, <a class="el" href="xsample01_8cpp_source.html#l00365">convert_bv2vect()</a>, <a class="el" href="xsample03_8cpp_source.html#l00291">generate_random_subset()</a>, <a class="el" href="sample10_8cpp_source.html#l00047">main()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00063">print_bvector()</a>, <a class="el" href="xsample02_8cpp_source.html#l00170">print_sorted()</a>, <a class="el" href="xsample01_8cpp_source.html#l00553">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00612">speed_test_bvs_index()</a>, and <a class="el" href="xsample04_8cpp_source.html#l00344">DNA_FingerprintScanner::TranslateResults()</a>.</p>

</div>
</div>
<a id="ab2a75eb8e2857dd05a4fd45c545f9902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a75eb8e2857dd05a4fd45c545f9902">&#9670;&nbsp;</a></span>flip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips bit n. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01630">1630</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="aaf87e9eb001e03c8828c7a92d9ab4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf87e9eb001e03c8828c7a92d9ab4e90">&#9670;&nbsp;</a></span>flip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a27e95553f358ebebda6b521336682deb" title="Invert/NEG all bits It should be noted, invert is affected by size() if size is set - it only inverts...">invert</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01637">1637</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="af77c870f1b54b6b54a3f52d84c4cb3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77c870f1b54b6b54a3f52d84c4cb3ae">&#9670;&nbsp;</a></span>forget_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::forget_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disables count cache. (deprecated). </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01768">1768</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a7f97290c7998d85514404e10f6a11a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f97290c7998d85514404e10f6a11a63">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Alloc <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01440">1440</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ad30287a9a5b42f654c1a00732dc6615e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30287a9a5b42f654c1a00732dc6615e">&#9670;&nbsp;</a></span>get_allocator_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a>* <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_allocator_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get curent allocator pool (if set) </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current pool or NULL </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01453">1453</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01213">bm::bvector&lt; Alloc &gt;::mem_pool_guard::assign_if_not_set()</a>.</p>

</div>
</div>
<a id="a267ed9d3782cc6f10a9d04a4a5e80074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267ed9d3782cc6f10a9d04a4a5e80074">&#9670;&nbsp;</a></span>get_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if bit n is set and false is bit n is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- Index of the bit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02933">2933</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a285a21e8a9f8362908e073eb4d8b0ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a21e8a9f8362908e073eb4d8b0ca1">&#9670;&nbsp;</a></span>get_blocks_manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_blocks_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get access to memory manager (internal) Use only if you are BitMagic library </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02215">2215</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04552">bm::bvector&lt;&gt;::bit_and()</a>, <a class="el" href="bm_8h_source.html#l04386">bm::bvector&lt;&gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l04637">bm::bvector&lt;&gt;::bit_sub()</a>, <a class="el" href="bm_8h_source.html#l04464">bm::bvector&lt;&gt;::bit_xor()</a>, and <a class="el" href="bmbmatrix_8h_source.html#l00756">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::get_block()</a>.</p>

</div>
</div>
<a id="afe10cd231a9fe147810ba8d359cefac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe10cd231a9fe147810ba8d359cefac1">&#9670;&nbsp;</a></span>get_blocks_manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_blocks_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get access to memory manager (internal) Use only if you are BitMagic library </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02222">2222</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="aeceae1bb9ce9a7471f7343d0d4da4ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeceae1bb9ce9a7471f7343d0d4da4ed5">&#9670;&nbsp;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on specified or the next available bit. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02110">2110</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ad3a165efa0b14f6c89eb1263ff88cbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a165efa0b14f6c89eb1263ff88cbd4">&#9670;&nbsp;</a></span>get_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actually set or bit-vector is empty </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the first 1 bit, may return 0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a973d2b45365c993fe27b9d3513dc848f" title="Finds the number of the next bit ON. ">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a16d604b466f187f725e34a5e9ee38e2a" title="Finds index of first 1 bit. ">find</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01864">1864</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample2_8cpp_source.html#l00035">print_bvector()</a>.</p>

</div>
</div>
<a id="a0bce99c7eed57bcf2c89ceb0dc0553a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bce99c7eed57bcf2c89ceb0dc0553a6">&#9670;&nbsp;</a></span>get_new_blocks_strat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_new_blocks_strat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns blocks allocation strategy. </p>
<dl class="section return"><dt>Returns</dt><dd>- Strategy code 0 - bitblocks allocation only. 1 - Blocks mutation mode (adaptive algorithm) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452" title="Sets new blocks allocation strategy. ">set_new_blocks_strat</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02146">2146</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a973d2b45365c993fe27b9d3513dc848f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973d2b45365c993fe27b9d3513dc848f">&#9670;&nbsp;</a></span>get_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of the next bit ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>- Index of the previously found bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the next bit which is ON or 0 if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3a165efa0b14f6c89eb1263ff88cbd4" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a16d604b466f187f725e34a5e9ee38e2a" title="Finds index of first 1 bit. ">find</a>, <a class="el" href="classbm_1_1bvector.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0. ">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a708b1d4bab9143870fc476a3a920a89e" title="Finds last index of 1 bit. ">find_reverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01873">1873</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample2_8cpp_source.html#l00035">print_bvector()</a>.</p>

</div>
</div>
<a id="a456c6c5c91e482eaaf99824fe054b076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456c6c5c91e482eaaf99824fe054b076">&#9670;&nbsp;</a></span>import()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>sorted_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import integers (set bits). </p>
<p>(Fast, no checks). </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03423">3423</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03332">bm::bvector&lt;&gt;::clear()</a>, and <a class="el" href="bm_8h_source.html#l03305">bm::bvector&lt;&gt;::keep()</a>.</p>

</div>
</div>
<a id="aa340255085db3f10b9092892aa17138d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340255085db3f10b9092892aa17138d">&#9670;&nbsp;</a></span>import_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::import_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>nblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03462">3462</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ade7c81ffb8a615f3c2593cd8541fac26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7c81ffb8a615f3c2593cd8541fac26">&#9670;&nbsp;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the specified element. </p>
<p>Bit increment rules: 0 + 1 = 1 (no carry over) 1 + 1 = 0 (with carry over returned)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if carry over created (1+1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03557">3557</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec_8h_source.html#l01513">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::inc()</a>.</p>

</div>
</div>
<a id="aaceb8d31d9da05f977de5c6a6cd62e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb8d31d9da05f977de5c6a6cd62e24">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit post-construction initialization. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02407">2407</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00121">bv_set_bit_no_check_test()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00814">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::insert_octet()</a>, <a class="el" href="xsample03_8cpp_source.html#l00217">load_snp_report()</a>, <a class="el" href="sample12_8cpp_source.html#l00182">main()</a>, <a class="el" href="xsample03_8cpp_source.html#l00348">run_benchmark()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00771">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::set_octet()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00105">vector_search()</a>.</p>

</div>
</div>
<a id="ab1d54f9c0d104464a63082bf9ba70284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d54f9c0d104464a63082bf9ba70284">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert bit into specified position All the vector content after position is shifted right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to insert </td></tr>
    <tr><td class="paramname">value</td><td>- insert value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Carry over bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04144">4144</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmbmatrix_8h_source.html#l00814">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::insert_octet()</a>.</p>

</div>
</div>
<a id="a6fbb5c0bd6f4b05712ee7701dcd1fe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">&#9670;&nbsp;</a></span>inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::inserter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function erturns insert iterator for this bitvector </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01644">1644</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample18_8cpp_source.html#l00042">main()</a>.</p>

</div>
</div>
<a id="a27e95553f358ebebda6b521336682deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e95553f358ebebda6b521336682deb">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert/NEG all bits It should be noted, invert is affected by <a class="el" href="classbm_1_1bvector.html#a105aeb50ff3b085db6f592793914c9f9" title="return current size of the vector (bits) ">size()</a> if size is set - it only inverts [0..size-1] bits. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02915">2915</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00517">DemoINV()</a>, and <a class="el" href="bm_8h_source.html#l01438">bm::bvector&lt;&gt;::operator~()</a>.</p>

</div>
</div>
<a id="a6cd40871b6cf3868aa9ff924c4c98d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd40871b6cf3868aa9ff924c4c98d57">&#9670;&nbsp;</a></span>keep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep list of bits in this bitset, others are cleared. </p>
<p>This is equivalent of AND (Set Intersect), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ade3af299b53a3d50af720192aed04791" title="Sets bit n if val is true, clears bit n if val is false. ">set</a>, <a class="el" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312" title="clear list of bits in this bitset ">clear</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03305">3305</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>.</p>

</div>
</div>
<a id="a237170e9f988319665bbcac2cd10e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237170e9f988319665bbcac2cd10e24e">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge/move content from another vector. </p>
<p>Merge performs a logical OR operation, but the source vector is not immutable. Source content gets destroyed (memory moved) to create a union of two vectors. Merge operation can be more efficient than OR if argument is a temporary vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- [in, out] - source vector (NOT immutable) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04312">4312</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00095">DemoOR()</a>, and <a class="el" href="bmsparsevec_8h_source.html#l01660">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::merge()</a>.</p>

</div>
</div>
<a id="a661988e4733743eece85726c9b5f99eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661988e4733743eece85726c9b5f99eb">&#9670;&nbsp;</a></span>move_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::move_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move bvector content from another bvector. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02416">2416</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a3e7ecc1abf8ac09c5c29b1c668811ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7ecc1abf8ac09c5c29b1c668811ab7">&#9670;&nbsp;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if no bits are set, otherwise returns false. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01828">1828</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a7c0aa609e421d4bd30f54bfc0c37672f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0aa609e421d4bd30f54bfc0c37672f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01436">1436</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a6192bc4d069c11e3bb3ee0d3b6ce2903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6192bc4d069c11e3bb3ee0d3b6ce2903">&#9670;&nbsp;</a></span>operator&=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator &amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01426">1426</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a7ceab1a0111e47f2fe4c4421e44fd3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceab1a0111e47f2fe4c4421e44fd3e4">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01429">1429</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a33ba6bcb25602091aedbd01dcb831dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ba6bcb25602091aedbd01dcb831dcf">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01431">1431</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a9e18cf38c1986e81c495ac10cc1e8c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e18cf38c1986e81c495ac10cc1e8c96">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01432">1432</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a3ffde9962a72e85ad2e6da29b397882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffde9962a72e85ad2e6da29b397882e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01338">1338</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a06b12c8991f5868c8a976f3d272dddf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b12c8991f5868c8a976f3d272dddf3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01381">1381</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a42cd0733885a5c736633343a377afd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cd0733885a5c736633343a377afd31">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01435">1435</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a493c937eedfa6e8ad1f2b381678075cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493c937eedfa6e8ad1f2b381678075cd">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01433">1433</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a9f5dfbe8e46c969d36ecbaf7261db03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5dfbe8e46c969d36ecbaf7261db03c">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01434">1434</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a1917a8e264fd69c102d7232862707732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1917a8e264fd69c102d7232862707732">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01410">1410</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="afbce2c22793865f10a2c445f3bb319a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbce2c22793865f10a2c445f3bb319a4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01420">1420</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac3adf4c9870b960d5dff4203074fc3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3adf4c9870b960d5dff4203074fc3d7">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01427">1427</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac48cd211c038bdc186baeca30e42fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48cd211c038bdc186baeca30e42fa93">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01428">1428</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a51687153e07d3be056aeb38ada237816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51687153e07d3be056aeb38ada237816">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01438">1438</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a622e6827d799a561e2f0db28f7ac19d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622e6827d799a561e2f0db28f7ac19d2">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize memory bitvector's memory allocation. </p>
<p>Function analyze all blocks in the bitvector, compresses blocks with a regular structure, frees some memory. This function is recommended after a bulk modification of the bitvector using set_bit, clear_bit or logical operations.</p>
<p>Optionally function can calculate vector post optimization statistics</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0" title="Optimization mode Every next level means additional checks (better compression vs time) ...">optmode</a>, <a class="el" href="classbm_1_1bvector.html#aaa2d954f42ea75520b8795066302daab" title="Optimize sizes of GAP blocks. ">optimize_gap_size</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a61">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02964">2964</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00057">generate_bvector()</a>, <a class="el" href="sample14_8cpp_source.html#l00059">main()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00076">make_BLOB()</a>, <a class="el" href="bmbmatrix_8h_source.html#l01032">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::optimize()</a>, <a class="el" href="sample4_8cpp_source.html#l00076">serialize_bvector()</a>, <a class="el" href="xsample01_8cpp_source.html#l00553">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00612">speed_test_bvs_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00738">speed_test_sv_index()</a>, and <a class="el" href="xsample01_8cpp_source.html#l00676">speed_test_vect_index()</a>.</p>

</div>
</div>
<a id="aaa2d954f42ea75520b8795066302daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2d954f42ea75520b8795066302daab">&#9670;&nbsp;</a></span>optimize_gap_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::optimize_gap_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize sizes of GAP blocks. </p>
<p>This method runs an analysis to find optimal GAP levels for the specific vector. Current GAP compression algorithm uses several fixed GAP sizes. By default bvector uses some reasonable preset. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03011">3011</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec_8h_source.html#l01604">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::optimize_gap_size()</a>.</p>

</div>
</div>
<a id="aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns rank of specified bit position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to rank </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the range [0..n] </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#add7d0ee9f9a50a44e6a6d5830fdacd12" title="compute running total of all blocks in bit vector (rank-select index) ">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a8ae3b0a7a9aff8e43a84bd8504eb853d" title="Returns count of 1 bits (population) in [0..right] range if test(right) == true. ">count_to_test</a>, <a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215" title="select bit-vector position for the specified rank(bitcount) ">select</a>, <a class="el" href="classbm_1_1bvector.html#aff0db4a3bfa4b8c8ed7c5d20ad2e8dbd" title="Returns rank of specified bit position. ">rank</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01739">1739</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ad88ebd6c8f81a36679b26c6c7535da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88ebd6c8f81a36679b26c6c7535da78">&#9670;&nbsp;</a></span>recalc_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::recalc_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recalculate bitcount (deprecated) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01763">1763</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ac1280ff08a2b1f4377ca15df081781f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1280ff08a2b1f4377ca15df081781f8">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears every bit in the bitvector. </p>
<dl class="section return"><dt>Returns</dt><dd>*this; </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01620">1620</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00091">bv_set_bit_test()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00072">generate_test_set()</a>.</p>

</div>
</div>
<a id="a56b7573c759e51c8943cf95a82a5b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b7573c759e51c8943cf95a82a5b9d6">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change size of the bvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>- new size in bits </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02498">2498</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03332">bm::bvector&lt;&gt;::clear()</a>, <a class="el" href="xsample01_8cpp_source.html#l00419">convert_bv2sv()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00517">DemoINV()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00095">DemoOR()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00404">DemoSUB()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00331">DemoXOR()</a>, <a class="el" href="bm_8h_source.html#l03305">bm::bvector&lt;&gt;::keep()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00252">pick_benchmark_set()</a>.</p>

</div>
</div>
<a id="aedc1b143c58296a0c52ba6039cd15ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc1b143c58296a0c52ba6039cd15ab9">&#9670;&nbsp;</a></span>running_count_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::running_count_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> *&#160;</td>
          <td class="paramname"><em>blocks_cnt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute running total of all blocks in bit vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocks_cnt</td><td>- out pointer to counting structure, holding the array Function will fill full array of running totals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a52cf058731b3a7a77c6aedf40e8dd730" title="Returns count of 1 bits (population) in [0..right] range. ">count_to</a>, <a class="el" href="classbm_1_1bvector.html#ad53af203265080beff109b18dd386215" title="select bit-vector position for the specified rank(bitcount) ">select</a>, <a class="el" href="classbm_1_1bvector.html#ab4cb380d6481c423831868a2b3fd3c34" title="Find bit-vector position for the specified rank(bitcount) ">find_rank</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02532">2532</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ad53af203265080beff109b18dd386215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53af203265080beff109b18dd386215">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a309afd0facb857c5591f88a1fee276b4">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>select bit-vector position for the specified rank(bitcount) </p>
<p>Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. Uses In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position) [out] </td></tr>
    <tr><td class="paramname">blocks_cnt</td><td>- block count structure to accelerate rank search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#aedc1b143c58296a0c52ba6039cd15ab9" title="compute running total of all blocks in bit vector ">running_count_blocks</a>, <a class="el" href="classbm_1_1bvector.html#ab4cb380d6481c423831868a2b3fd3c34" title="Find bit-vector position for the specified rank(bitcount) ">find_rank</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03943">3943</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ade3af299b53a3d50af720192aed04791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3af299b53a3d50af720192aed04791">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n if val is true, clears bit n if val is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03367">3367</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00165">bvector_bulk_set_test()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01418">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::clear()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00095">DemoOR()</a>, <a class="el" href="sample14_8cpp_source.html#l00047">fill_bvector()</a>, <a class="el" href="sample11_8cpp_source.html#l00057">generate_bvector()</a>, <a class="el" href="bmsparsevec_8h_source.html#l00908">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::import()</a>, <a class="el" href="sample10_8cpp_source.html#l00047">main()</a>, <a class="el" href="xsample05_8cpp_source.html#l00252">pick_benchmark_set()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00300">run_benchmark()</a>.</p>

</div>
</div>
<a id="a948743fdaf254dfc9d946b75c5e301a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948743fdaf254dfc9d946b75c5e301a0">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets every bit in this bitset to 1. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03358">3358</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a5b91dacd0dac75e18fa79570acb29256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b91dacd0dac75e18fa79570acb29256">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set list of bits in this bitset to 1. </p>
<p>Method implements optimized bulk setting of multiple bits at once. The best results are achieved when the imput comes sorted. This is equivalent of OR (Set Union), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a6cd40871b6cf3868aa9ff924c4c98d57" title="Keep list of bits in this bitset, others are cleared. ">keep</a>, <a class="el" href="classbm_1_1bvector.html#ab2cc04dcf2543cc096a028ac55320312" title="clear list of bits in this bitset ">clear</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03290">3290</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="af9ca1a05eb82edd1172207da584c1374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ca1a05eb82edd1172207da584c1374">&#9670;&nbsp;</a></span>set_allocator_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_allocator_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *&#160;</td>
          <td class="paramname"><em>pool_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set allocator pool for local (non-threaded) memory cyclic(lots of alloc-free ops) opertations. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01448">1448</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01213">bm::bvector&lt; Alloc &gt;::mem_pool_guard::assign_if_not_set()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01280">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::extract()</a>, and <a class="el" href="bm_8h_source.html#l01202">bm::bvector&lt; Alloc &gt;::mem_pool_guard::mem_pool_guard()</a>.</p>

</div>
</div>
<a id="aecf79c2c05bda3445ade2e10b61066b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf79c2c05bda3445ade2e10b61066b7">&#9670;&nbsp;</a></span>set_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="xsample01_8cpp-example.html#a25">xsample01.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03406">3406</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00091">bv_set_bit_test()</a>, <a class="el" href="sample3_8cpp_source.html#l00047">fill_bvector()</a>, and <a class="el" href="xsample01_8cpp_source.html#l00217">generate_random_vector()</a>.</p>

</div>
</div>
<a id="aae63c4aafd1215964477957b599f1502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae63c4aafd1215964477957b599f1502">&#9670;&nbsp;</a></span>set_bit_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n using bit AND with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03393">3393</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a9cd2b46e67549275f72517930f99e3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd2b46e67549275f72517930f99e3ae">&#9670;&nbsp;</a></span>set_bit_conditional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_conditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n only if current value equals the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
    <tr><td class="paramname">condition</td><td>- expected current value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03376">3376</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a269707ecb4a5cba0d1907f85c0742f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269707ecb4a5cba0d1907f85c0742f33">&#9670;&nbsp;</a></span>set_bit_no_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bit without checking preconditions (size, etc) </p>
<p>Fast set bit method, without safety net. Make sure you call <a class="el" href="classbm_1_1bvector.html#aaceb8d31d9da05f977de5c6a6cd62e24" title="Explicit post-construction initialization. ">bvector&lt;&gt;::init()</a> before setting bits with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03254">3254</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00121">bv_set_bit_no_check_test()</a>, <a class="el" href="bm_8h_source.html#l03462">bm::bvector&lt;&gt;::import_block()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01513">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::inc()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00814">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::insert_octet()</a>, <a class="el" href="xsample03_8cpp_source.html#l00217">load_snp_report()</a>, <a class="el" href="svsample06_8cpp_source.html#l00132">main()</a>, <a class="el" href="xsample03_8cpp_source.html#l00348">run_benchmark()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00771">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::set_octet()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01453">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::set_value()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01464">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::set_value_no_null()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00105">vector_search()</a>.</p>

</div>
</div>
<a id="a14f9b220fec8e7b65e4e5ed2832af96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f9b220fec8e7b65e4e5ed2832af96b">&#9670;&nbsp;</a></span>set_gap_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_gap_levels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glevel_len</td><td>- pointer on C-style array keeping GAP block sizes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03035">3035</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a653ee052b297a49c35344704df67a452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ee052b297a49c35344704df67a452">&#9670;&nbsp;</a></span>set_new_blocks_strat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_new_blocks_strat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets new blocks allocation strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strat</td><td>- Strategy code 0 - bitblocks allocation only. 1 - Blocks mutation mode (adaptive algorithm) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02138">2138</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample3_8cpp_source.html#l00073">main()</a>.</p>

</div>
</div>
<a id="ae14650ede7559f896894f951810cadbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14650ede7559f896894f951810cadbf">&#9670;&nbsp;</a></span>set_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval) </td></tr>
    <tr><td class="paramname">value</td><td>- value to set interval in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02431">2431</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00240">bv_count_and()</a>, <a class="el" href="sample11_8cpp_source.html#l00057">generate_bvector()</a>, <a class="el" href="bmsparsevec_8h_source.html#l00908">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::import()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01621">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::join()</a>, and <a class="el" href="bmsparsevec_8h_source.html#l01660">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::merge()</a>.</p>

</div>
</div>
<a id="aacf96380ec223d52340a60ec57c8bdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf96380ec223d52340a60ec57c8bdbd">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::shift_right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift right by 1 bit, fill with zero return carry over. </p>
<dl class="section return"><dt>Returns</dt><dd>Carry over bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04136">4136</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample04_8cpp_source.html#l00250">DNA_FingerprintScanner::Find()</a>.</p>

</div>
</div>
<a id="a105aeb50ff3b085db6f592793914c9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105aeb50ff3b085db6f592793914c9f9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a405dd9ed048c935c84a5086ec8ba3649">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return current size of the vector (bits) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01657">1657</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01338">bm::bvector&lt;&gt;::operator=()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00063">print_bvector()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00300">run_benchmark()</a>.</p>

</div>
</div>
<a id="afb23b3d28671129ae37f21fc37c31cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb23b3d28671129ae37f21fc37c31cdd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges content of bv and this bvector. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03181">3181</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00182">main()</a>.</p>

</div>
</div>
<a id="a4c6c213804cd440ce15ede3d374f0c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c213804cd440ce15ede3d374f0c69">&#9670;&nbsp;</a></span>sync_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::sync_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syncronize size if it got extended due to bulk import. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02519">2519</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="abf474232920c5a01c88db1f85608b79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf474232920c5a01c88db1f85608b79b">&#9670;&nbsp;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if bit n is set and false is bit n is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- Index of the bit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01788">1788</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample03_8cpp_source.html#l00217">load_snp_report()</a>, <a class="el" href="svsample06_8cpp_source.html#l00132">main()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00252">pick_benchmark_set()</a>.</p>

</div>
</div>
<a id="a38b7223ef1dc03d8b02b6feefea8e01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b7223ef1dc03d8b02b6feefea8e01b">&#9670;&nbsp;</a></span>throw_bad_alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::throw_bad_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06181">6181</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a27b713f8799df176e5ab5da91d782bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b713f8799df176e5ab5da91d782bf3">&#9670;&nbsp;</a></span>aggregator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<div class="memtemplate">
template&lt;class BV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbm_1_1aggregator.html">aggregator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01233">1233</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a71cabca9670588878381f72d16e059b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cabca9670588878381f72d16e059b8">&#9670;&nbsp;</a></span>enumerator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01232">1232</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02104">bm::bvector&lt;&gt;::end()</a>, and <a class="el" href="bm_8h_source.html#l02110">bm::bvector&lt;&gt;::get_enumerator()</a>.</p>

</div>
</div>
<a id="aeec1461fca400b5b4313765eb9e94c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1461fca400b5b4313765eb9e94c73">&#9670;&nbsp;</a></span>iterator_base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbm_1_1bvector_1_1iterator__base.html">iterator_base</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01231">1231</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bm_8h_source.html">bm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
