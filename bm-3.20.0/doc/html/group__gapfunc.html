<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: GAP functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GAP functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default GAP lengths table.  <a href="structbm_1_1gap__len__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1gap__len__table__min.html">bm::gap_len_table_min&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets.  <a href="structbm_1_1gap__len__table__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1gap__len__table__nl.html">bm::gap_len_table_nl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-linear size growth GAP lengths table.  <a href="structbm_1_1gap__len__table__nl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga546842afd6d6097e5c11905bcd44ddd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga546842afd6d6097e5c11905bcd44ddd6">bm::gap_is_all_zero</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:ga546842afd6d6097e5c11905bcd44ddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if GAP block is all-zero.  <a href="group__gapfunc.html#ga546842afd6d6097e5c11905bcd44ddd6">More...</a><br /></td></tr>
<tr class="separator:ga546842afd6d6097e5c11905bcd44ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67f48231637a4dacea298a38351e84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab67f48231637a4dacea298a38351e84c">bm::gap_is_all_one</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:gab67f48231637a4dacea298a38351e84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if GAP block is all-one.  <a href="group__gapfunc.html#gab67f48231637a4dacea298a38351e84c">More...</a><br /></td></tr>
<tr class="separator:gab67f48231637a4dacea298a38351e84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5fa3a228bd9d820f96f136663982aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga8b5fa3a228bd9d820f96f136663982aa">bm::gap_length</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:ga8b5fa3a228bd9d820f96f136663982aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block length.  <a href="group__gapfunc.html#ga8b5fa3a228bd9d820f96f136663982aa">More...</a><br /></td></tr>
<tr class="separator:ga8b5fa3a228bd9d820f96f136663982aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a34c5aab766103f262b22e1df5a159"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga03a34c5aab766103f262b22e1df5a159"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga03a34c5aab766103f262b22e1df5a159">bm::gap_capacity</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:ga03a34c5aab766103f262b22e1df5a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block capacity.  <a href="group__gapfunc.html#ga03a34c5aab766103f262b22e1df5a159">More...</a><br /></td></tr>
<tr class="separator:ga03a34c5aab766103f262b22e1df5a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae256c20673e9e1beb4a64cec957caa48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae256c20673e9e1beb4a64cec957caa48"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae256c20673e9e1beb4a64cec957caa48">bm::gap_limit</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:gae256c20673e9e1beb4a64cec957caa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block capacity limit.  <a href="group__gapfunc.html#gae256c20673e9e1beb4a64cec957caa48">More...</a><br /></td></tr>
<tr class="separator:gae256c20673e9e1beb4a64cec957caa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b12b23371696c9509d8421aeb082ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9b12b23371696c9509d8421aeb082ed"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab9b12b23371696c9509d8421aeb082ed">bm::gap_level</a> (const T *buf)</td></tr>
<tr class="memdesc:gab9b12b23371696c9509d8421aeb082ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP blocks capacity level.  <a href="group__gapfunc.html#gab9b12b23371696c9509d8421aeb082ed">More...</a><br /></td></tr>
<tr class="separator:gab9b12b23371696c9509d8421aeb082ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4ed22413b908890186e658ab9992fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaad4ed22413b908890186e658ab9992fa"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaad4ed22413b908890186e658ab9992fa">bm::gap_find_last</a> (const T *buf, unsigned *last)</td></tr>
<tr class="memdesc:gaad4ed22413b908890186e658ab9992fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find the last set bit.  <a href="group__gapfunc.html#gaad4ed22413b908890186e658ab9992fa">More...</a><br /></td></tr>
<tr class="separator:gaad4ed22413b908890186e658ab9992fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0204a8054e2c906df66eae53d4ad1564"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0204a8054e2c906df66eae53d4ad1564"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0204a8054e2c906df66eae53d4ad1564">bm::gap_find_first</a> (const T *buf, unsigned *first)</td></tr>
<tr class="memdesc:ga0204a8054e2c906df66eae53d4ad1564"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find the first set bit.  <a href="group__gapfunc.html#ga0204a8054e2c906df66eae53d4ad1564">More...</a><br /></td></tr>
<tr class="separator:ga0204a8054e2c906df66eae53d4ad1564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8a20a8290d5b37f212bc0bec738357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafb8a20a8290d5b37f212bc0bec738357"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357">bm::gap_test</a> (const T *buf, unsigned pos)</td></tr>
<tr class="memdesc:gafb8a20a8290d5b37f212bc0bec738357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if bit = pos is true.  <a href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357">More...</a><br /></td></tr>
<tr class="separator:gafb8a20a8290d5b37f212bc0bec738357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1c3ea43579816f35ff24fad63b8dc089">bm::gap_test_unr</a> (const T *buf, const unsigned pos)</td></tr>
<tr class="memdesc:ga1c3ea43579816f35ff24fad63b8dc089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if bit = pos is true. Analog of <a class="el" href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357" title="Tests if bit = pos is true. ">bm::gap_test</a> with SIMD unrolling.  <a href="group__gapfunc.html#ga1c3ea43579816f35ff24fad63b8dc089">More...</a><br /></td></tr>
<tr class="separator:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1117cb2e30df357a552fb1082229d76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1117cb2e30df357a552fb1082229d76"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac1117cb2e30df357a552fb1082229d76">bm::gap_bit_count</a> (const T *buf, unsigned dsize=0)</td></tr>
<tr class="memdesc:gac1117cb2e30df357a552fb1082229d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer.  <a href="group__gapfunc.html#gac1117cb2e30df357a552fb1082229d76">More...</a><br /></td></tr>
<tr class="separator:gac1117cb2e30df357a552fb1082229d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e52a07431a2d09c35b8a249b02633b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97e52a07431a2d09c35b8a249b02633b"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga97e52a07431a2d09c35b8a249b02633b">bm::gap_bit_count_unr</a> (const T *buf)</td></tr>
<tr class="memdesc:ga97e52a07431a2d09c35b8a249b02633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer. Loop unrolled version.  <a href="group__gapfunc.html#ga97e52a07431a2d09c35b8a249b02633b">More...</a><br /></td></tr>
<tr class="separator:ga97e52a07431a2d09c35b8a249b02633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae83c2f3d1d54a1814ebf51d14aa19878">bm::gap_bit_count_range</a> (const T *const buf, unsigned left, unsigned right)</td></tr>
<tr class="memdesc:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [left, right] range.  <a href="group__gapfunc.html#gae83c2f3d1d54a1814ebf51d14aa19878">More...</a><br /></td></tr>
<tr class="separator:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b3d2a5089abc09d39d80ae48718965"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga69b3d2a5089abc09d39d80ae48718965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga69b3d2a5089abc09d39d80ae48718965">bm::gap_find_rank</a> (const T *const block, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> rank, unsigned nbit_from, unsigned &amp;nbit_pos)</td></tr>
<tr class="memdesc:ga69b3d2a5089abc09d39d80ae48718965"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find position for the rank.  <a href="group__gapfunc.html#ga69b3d2a5089abc09d39d80ae48718965">More...</a><br /></td></tr>
<tr class="separator:ga69b3d2a5089abc09d39d80ae48718965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41faacade39b8d62f30216d473ef1fb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga41faacade39b8d62f30216d473ef1fb1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga41faacade39b8d62f30216d473ef1fb1">bm::gap_bit_count_to</a> (const T *const buf, T right)</td></tr>
<tr class="memdesc:ga41faacade39b8d62f30216d473ef1fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [0, right] range.  <a href="group__gapfunc.html#ga41faacade39b8d62f30216d473ef1fb1">More...</a><br /></td></tr>
<tr class="separator:ga41faacade39b8d62f30216d473ef1fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga26ab5d91179de63eb74c66ea6e1e4cc4">bm::gapcmp</a> (const T *buf1, const T *buf2)</td></tr>
<tr class="memdesc:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison of GAP buffers.  <a href="group__gapfunc.html#ga26ab5d91179de63eb74c66ea6e1e4cc4">More...</a><br /></td></tr>
<tr class="separator:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr class="memitem:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaef97eb2d854ee06d2c2137f7af11982b">bm::gap_buff_any_op</a> (const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, unsigned vect1_mask, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, unsigned vect2_mask, F f)</td></tr>
<tr class="memdesc:gaef97eb2d854ee06d2c2137f7af11982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract distance test operation for GAP buffers. Receives functor F as a template argument.  <a href="group__gapfunc.html#gaef97eb2d854ee06d2c2137f7af11982b">More...</a><br /></td></tr>
<tr class="separator:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr class="memitem:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga94c46d5dae114fdb2dd758cd80ba5dae">bm::gap_buff_count_op</a> (const T *vect1, const T *vect2, F f)</td></tr>
<tr class="memdesc:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument.  <a href="group__gapfunc.html#ga94c46d5dae114fdb2dd758cd80ba5dae">More...</a><br /></td></tr>
<tr class="separator:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59567b7dcd289833d5d09639b23c5c61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga59567b7dcd289833d5d09639b23c5c61"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga59567b7dcd289833d5d09639b23c5c61">bm::gap_set_value</a> (unsigned val, T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> buf, unsigned pos, unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> is_set)</td></tr>
<tr class="memdesc:ga59567b7dcd289833d5d09639b23c5c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears bit in the GAP buffer.  <a href="group__gapfunc.html#ga59567b7dcd289833d5d09639b23c5c61">More...</a><br /></td></tr>
<tr class="separator:ga59567b7dcd289833d5d09639b23c5c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga3e06b8bf018f8160ddda34a41143f8d4">bm::gap_add_value</a> (T *buf, unsigned pos)</td></tr>
<tr class="memdesc:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new value to the end of GAP buffer.  <a href="group__gapfunc.html#ga3e06b8bf018f8160ddda34a41143f8d4">More...</a><br /></td></tr>
<tr class="separator:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bbec8d06687f311c46d89352276248"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga77bbec8d06687f311c46d89352276248"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga77bbec8d06687f311c46d89352276248">bm::gap_shift_r1</a> (T *buf, unsigned co_flag, unsigned *new_len)</td></tr>
<tr class="memdesc:ga77bbec8d06687f311c46d89352276248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right shift GAP block by 1 bit.  <a href="group__gapfunc.html#ga77bbec8d06687f311c46d89352276248">More...</a><br /></td></tr>
<tr class="separator:ga77bbec8d06687f311c46d89352276248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7062f126291c8ab493cef420205e00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2d7062f126291c8ab493cef420205e00"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga2d7062f126291c8ab493cef420205e00">bm::gap_set_array</a> (T *buf, const T *arr, unsigned len)</td></tr>
<tr class="memdesc:ga2d7062f126291c8ab493cef420205e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert array to GAP buffer.  <a href="group__gapfunc.html#ga2d7062f126291c8ab493cef420205e00">More...</a><br /></td></tr>
<tr class="separator:ga2d7062f126291c8ab493cef420205e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e39e9863fee8647e2db865439464a05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7e39e9863fee8647e2db865439464a05"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7e39e9863fee8647e2db865439464a05">bm::bit_array_compute_gaps</a> (const T *arr, unsigned len)</td></tr>
<tr class="memdesc:ga7e39e9863fee8647e2db865439464a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute number of GAPs in bit-array.  <a href="group__gapfunc.html#ga7e39e9863fee8647e2db865439464a05">More...</a><br /></td></tr>
<tr class="separator:ga7e39e9863fee8647e2db865439464a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac62a37d6cc70a055ebdb86fcd6664b2c">bm::gap_find_in_block</a> (const T *buf, unsigned nbit, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr class="memdesc:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the next 1 bit in the GAP block.  <a href="group__gapfunc.html#gac62a37d6cc70a055ebdb86fcd6664b2c">More...</a><br /></td></tr>
<tr class="separator:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1f4e632a6f6135148ec76a3ca10e0a70">bm::gap_sub_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock.  <a href="group__gapfunc.html#ga1f4e632a6f6135148ec76a3ca10e0a70">More...</a><br /></td></tr>
<tr class="separator:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197d8b08506aa4a0589ed306ae134490"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga197d8b08506aa4a0589ed306ae134490"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga197d8b08506aa4a0589ed306ae134490">bm::gap_sub_to_bitset</a> (unsigned *dest, const T *pcurr, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest0)</td></tr>
<tr class="memdesc:ga197d8b08506aa4a0589ed306ae134490"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock with digest assist.  <a href="group__gapfunc.html#ga197d8b08506aa4a0589ed306ae134490">More...</a><br /></td></tr>
<tr class="separator:ga197d8b08506aa4a0589ed306ae134490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga8681f5db8e4c3a1467db41048dba67b1">bm::gap_xor_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga8681f5db8e4c3a1467db41048dba67b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR GAP block to bitblock.  <a href="group__gapfunc.html#ga8681f5db8e4c3a1467db41048dba67b1">More...</a><br /></td></tr>
<tr class="separator:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0322a5ff3d1b443ab31fcfacbab9168f">bm::gap_add_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="group__gapfunc.html#ga0322a5ff3d1b443ab31fcfacbab9168f">More...</a><br /></td></tr>
<tr class="separator:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1449bce424986cc7b4c4dedb09fbc715">bm::gap_and_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga1449bce424986cc7b4c4dedb09fbc715"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANDs GAP block to bitblock.  <a href="group__gapfunc.html#ga1449bce424986cc7b4c4dedb09fbc715">More...</a><br /></td></tr>
<tr class="separator:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9336750a2de2949c29d19f20d87a843"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9336750a2de2949c29d19f20d87a843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab9336750a2de2949c29d19f20d87a843">bm::gap_and_to_bitset</a> (unsigned *dest, const T *pcurr, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest0)</td></tr>
<tr class="memdesc:gab9336750a2de2949c29d19f20d87a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANDs GAP block to bitblock with digest assist.  <a href="group__gapfunc.html#gab9336750a2de2949c29d19f20d87a843">More...</a><br /></td></tr>
<tr class="separator:gab9336750a2de2949c29d19f20d87a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f4b3de019ea33367356bc0910e31a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac7f4b3de019ea33367356bc0910e31a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac7f4b3de019ea33367356bc0910e31a7">bm::gap_bitset_and_count</a> (const unsigned *block, const T *pcurr)</td></tr>
<tr class="memdesc:gac7f4b3de019ea33367356bc0910e31a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block AND masked by GAP block.  <a href="group__gapfunc.html#gac7f4b3de019ea33367356bc0910e31a7">More...</a><br /></td></tr>
<tr class="separator:gac7f4b3de019ea33367356bc0910e31a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0962484f2b2a8ea8a9c2d4de47cbc316">bm::gap_bitset_and_any</a> (const unsigned *block, const T *pcurr)</td></tr>
<tr class="memdesc:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcount test of bit block AND masked by GAP block.  <a href="group__gapfunc.html#ga0962484f2b2a8ea8a9c2d4de47cbc316">More...</a><br /></td></tr>
<tr class="separator:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7352f6f48aed8cb7ded4d9a8a7deb6af">bm::gap_bitset_sub_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block SUB masked by GAP block.  <a href="group__gapfunc.html#ga7352f6f48aed8cb7ded4d9a8a7deb6af">More...</a><br /></td></tr>
<tr class="separator:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7ef71ffa5a8fda6ffe3ff2c69fe7f077">bm::gap_bitset_sub_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block SUB masked by GAP block.  <a href="group__gapfunc.html#ga7ef71ffa5a8fda6ffe3ff2c69fe7f077">More...</a><br /></td></tr>
<tr class="separator:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4303eb15c00a062e484635737c8f43ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4303eb15c00a062e484635737c8f43ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga4303eb15c00a062e484635737c8f43ed">bm::gap_bitset_xor_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga4303eb15c00a062e484635737c8f43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block XOR masked by GAP block.  <a href="group__gapfunc.html#ga4303eb15c00a062e484635737c8f43ed">More...</a><br /></td></tr>
<tr class="separator:ga4303eb15c00a062e484635737c8f43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac737cc3e97c0787297d54da57902ca29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac737cc3e97c0787297d54da57902ca29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac737cc3e97c0787297d54da57902ca29">bm::gap_bitset_xor_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:gac737cc3e97c0787297d54da57902ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block XOR masked by GAP block.  <a href="group__gapfunc.html#gac737cc3e97c0787297d54da57902ca29">More...</a><br /></td></tr>
<tr class="separator:gac737cc3e97c0787297d54da57902ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac532282d6f0cbb3ae48bc119c55c49b9">bm::gap_bitset_or_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block OR masked by GAP block.  <a href="group__gapfunc.html#gac532282d6f0cbb3ae48bc119c55c49b9">More...</a><br /></td></tr>
<tr class="separator:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga48d5ed2e04e67900c364c4561c7787c4">bm::gap_bitset_or_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga48d5ed2e04e67900c364c4561c7787c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block OR masked by GAP block.  <a href="group__gapfunc.html#ga48d5ed2e04e67900c364c4561c7787c4">More...</a><br /></td></tr>
<tr class="separator:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga6f73b66e24322db3d885b9b53d43e75f">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr class="memdesc:ga6f73b66e24322db3d885b9b53d43e75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga6f73b66e24322db3d885b9b53d43e75f">More...</a><br /></td></tr>
<tr class="separator:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4ac4f8a08a46903655eca907b19385"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f4ac4f8a08a46903655eca907b19385"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0f4ac4f8a08a46903655eca907b19385">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf, unsigned dest_len)</td></tr>
<tr class="memdesc:ga0f4ac4f8a08a46903655eca907b19385"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga0f4ac4f8a08a46903655eca907b19385">More...</a><br /></td></tr>
<tr class="separator:ga0f4ac4f8a08a46903655eca907b19385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memTemplItemLeft" align="right" valign="top">unsigned *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga90dc1e34b98cf061c60f1efc5e3e4bf0">bm::gap_convert_to_bitset_smart</a> (unsigned *dest, const T *buf, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a> set_max)</td></tr>
<tr class="memdesc:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga90dc1e34b98cf061c60f1efc5e3e4bf0">More...</a><br /></td></tr>
<tr class="separator:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460d8564dd82a511db120e9c01fb529d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga460d8564dd82a511db120e9c01fb529d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga460d8564dd82a511db120e9c01fb529d">bm::gap_control_sum</a> (const T *buf)</td></tr>
<tr class="memdesc:ga460d8564dd82a511db120e9c01fb529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates sum of all words in GAP block. (For debugging purposes)  <a href="group__gapfunc.html#ga460d8564dd82a511db120e9c01fb529d">More...</a><br /></td></tr>
<tr class="separator:ga460d8564dd82a511db120e9c01fb529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa4547663f2ac44e1dab9d94cd866b0ca">bm::gap_set_all</a> (T *buf, unsigned set_max, unsigned value)</td></tr>
<tr class="memdesc:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits to 0 or 1 (GAP)  <a href="group__gapfunc.html#gaa4547663f2ac44e1dab9d94cd866b0ca">More...</a><br /></td></tr>
<tr class="separator:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9126461f19bfe024093c4c5fd816c083"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9126461f19bfe024093c4c5fd816c083"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga9126461f19bfe024093c4c5fd816c083">bm::gap_init_range_block</a> (T *buf, T from, T to, T value)</td></tr>
<tr class="memdesc:ga9126461f19bfe024093c4c5fd816c083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init gap block so it has block in it (can be whole block)  <a href="group__gapfunc.html#ga9126461f19bfe024093c4c5fd816c083">More...</a><br /></td></tr>
<tr class="separator:ga9126461f19bfe024093c4c5fd816c083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba1509608fe39847b88c062128fff99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ba1509608fe39847b88c062128fff99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1ba1509608fe39847b88c062128fff99">bm::gap_invert</a> (T *buf)</td></tr>
<tr class="memdesc:ga1ba1509608fe39847b88c062128fff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts all bits in the GAP buffer.  <a href="group__gapfunc.html#ga1ba1509608fe39847b88c062128fff99">More...</a><br /></td></tr>
<tr class="separator:ga1ba1509608fe39847b88c062128fff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a026368549e02e8af9b6c290536c2fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9a026368549e02e8af9b6c290536c2fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga9a026368549e02e8af9b6c290536c2fc">bm::set_gap_level</a> (T *buf, int level)</td></tr>
<tr class="memdesc:ga9a026368549e02e8af9b6c290536c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GAP block capacity level.  <a href="group__gapfunc.html#ga9a026368549e02e8af9b6c290536c2fc">More...</a><br /></td></tr>
<tr class="separator:ga9a026368549e02e8af9b6c290536c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga973ee6ac889acaa5a1cb61595b15793a">bm::gap_calc_level</a> (unsigned len, const T *glevel_len)</td></tr>
<tr class="memdesc:ga973ee6ac889acaa5a1cb61595b15793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates GAP block capacity level.  <a href="group__gapfunc.html#ga973ee6ac889acaa5a1cb61595b15793a">More...</a><br /></td></tr>
<tr class="separator:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga97b1fcf40d8fdccfccd2083d654a6436">bm::gap_free_elements</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length.  <a href="group__gapfunc.html#ga97b1fcf40d8fdccfccd2083d654a6436">More...</a><br /></td></tr>
<tr class="separator:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa2064b36ab5c3176e023cf3478e3ee04">bm::bit_block_to_gap</a> (<a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, unsigned dest_len)</td></tr>
<tr class="memdesc:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts bit block to GAP.  <a href="group__gapfunc.html#gaa2064b36ab5c3176e023cf3478e3ee04">More...</a><br /></td></tr>
<tr class="separator:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga5614d83505b04921c1e89d077ae3d3c7">bm::for_each_gap_dbit</a> (const T *buf, F &amp;func)</td></tr>
<tr class="memdesc:ga5614d83505b04921c1e89d077ae3d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate gap block as delta-bits with a functor.  <a href="group__gapfunc.html#ga5614d83505b04921c1e89d077ae3d3c7">More...</a><br /></td></tr>
<tr class="separator:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3aa03295329ef84f8e25b1da19d6794"><td class="memTemplParams" colspan="2">template&lt;typename D , typename T &gt; </td></tr>
<tr class="memitem:gab3aa03295329ef84f8e25b1da19d6794"><td class="memTemplItemLeft" align="right" valign="top">D&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab3aa03295329ef84f8e25b1da19d6794">bm::gap_convert_to_arr</a> (D *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> buf, unsigned dest_len, bool invert=false)</td></tr>
<tr class="memdesc:gab3aa03295329ef84f8e25b1da19d6794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert gap block into array of ints corresponding to 1 bits.  <a href="group__gapfunc.html#gab3aa03295329ef84f8e25b1da19d6794">More...</a><br /></td></tr>
<tr class="separator:gab3aa03295329ef84f8e25b1da19d6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18d7da0492983802511999a4ad0764a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac18d7da0492983802511999a4ad0764a">bm::gap_operation_and</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gac18d7da0492983802511999a4ad0764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP AND operation.  <a href="group__gapfunc.html#gac18d7da0492983802511999a4ad0764a">More...</a><br /></td></tr>
<tr class="separator:gac18d7da0492983802511999a4ad0764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e0312d3ab0551e883176b170c0a3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga58e0312d3ab0551e883176b170c0a3e8">bm::gap_operation_any_and</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga58e0312d3ab0551e883176b170c0a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP AND operation test.  <a href="group__gapfunc.html#ga58e0312d3ab0551e883176b170c0a3e8">More...</a><br /></td></tr>
<tr class="separator:ga58e0312d3ab0551e883176b170c0a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92d013b0c377604831f401ef6917b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gafd92d013b0c377604831f401ef6917b8">bm::gap_count_and</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gafd92d013b0c377604831f401ef6917b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount AND operation test.  <a href="group__gapfunc.html#gafd92d013b0c377604831f401ef6917b8">More...</a><br /></td></tr>
<tr class="separator:gafd92d013b0c377604831f401ef6917b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga72d2d3933b4410413eeb02e9ee0a910d">bm::gap_operation_xor</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP XOR operation.  <a href="group__gapfunc.html#ga72d2d3933b4410413eeb02e9ee0a910d">More...</a><br /></td></tr>
<tr class="separator:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8800dff60eb05404a83159035e8e72f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab8800dff60eb05404a83159035e8e72f">bm::gap_operation_any_xor</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gab8800dff60eb05404a83159035e8e72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP XOR operation test.  <a href="group__gapfunc.html#gab8800dff60eb05404a83159035e8e72f">More...</a><br /></td></tr>
<tr class="separator:gab8800dff60eb05404a83159035e8e72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38d6a3296f0562be512f47b4edfb1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae38d6a3296f0562be512f47b4edfb1ad">bm::gap_count_xor</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gae38d6a3296f0562be512f47b4edfb1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount XOR operation test.  <a href="group__gapfunc.html#gae38d6a3296f0562be512f47b4edfb1ad">More...</a><br /></td></tr>
<tr class="separator:gae38d6a3296f0562be512f47b4edfb1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda280af8910ae5fde37731a3a7a1226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gacda280af8910ae5fde37731a3a7a1226">bm::gap_operation_or</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gacda280af8910ae5fde37731a3a7a1226"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP OR operation.  <a href="group__gapfunc.html#gacda280af8910ae5fde37731a3a7a1226">More...</a><br /></td></tr>
<tr class="separator:gacda280af8910ae5fde37731a3a7a1226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125fc8dc68245a11a171e7793c6588a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga125fc8dc68245a11a171e7793c6588a2">bm::gap_count_or</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga125fc8dc68245a11a171e7793c6588a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount OR operation test.  <a href="group__gapfunc.html#ga125fc8dc68245a11a171e7793c6588a2">More...</a><br /></td></tr>
<tr class="separator:ga125fc8dc68245a11a171e7793c6588a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gabe4c83e5e162c38e297116dd1cd05ac4">bm::gap_operation_sub</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP SUB (AND NOT) operation.  <a href="group__gapfunc.html#gabe4c83e5e162c38e297116dd1cd05ac4">More...</a><br /></td></tr>
<tr class="separator:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9b33d00f74206ad655dc2cef52428b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1c9b33d00f74206ad655dc2cef52428b">bm::gap_operation_any_sub</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga1c9b33d00f74206ad655dc2cef52428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP SUB operation test.  <a href="group__gapfunc.html#ga1c9b33d00f74206ad655dc2cef52428b">More...</a><br /></td></tr>
<tr class="separator:ga1c9b33d00f74206ad655dc2cef52428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacf55c60da82a1c384f3ac3a51229d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gacacf55c60da82a1c384f3ac3a51229d4">bm::gap_count_sub</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gacacf55c60da82a1c384f3ac3a51229d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount SUB (AND NOT) operation test.  <a href="group__gapfunc.html#gacacf55c60da82a1c384f3ac3a51229d4">More...</a><br /></td></tr>
<tr class="separator:gacacf55c60da82a1c384f3ac3a51229d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa029c18363842b7c534e8c1b806cfc49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa029c18363842b7c534e8c1b806cfc49"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa029c18363842b7c534e8c1b806cfc49">bm::gap_overhead</a> (const T *length, const T *length_end, const T *glevel_len)</td></tr>
<tr class="memdesc:gaa029c18363842b7c534e8c1b806cfc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates memory overhead for number of gap blocks sharing the same memory allocation table (level lengths table).  <a href="group__gapfunc.html#gaa029c18363842b7c534e8c1b806cfc49">More...</a><br /></td></tr>
<tr class="separator:gaa029c18363842b7c534e8c1b806cfc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga2f4f5fdc0cf7a989e0eb0faeb7eb851d">bm::improve_gap_levels</a> (const T *length, const T *length_end, T *glevel_len)</td></tr>
<tr class="memdesc:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds optimal gap blocks lengths.  <a href="group__gapfunc.html#ga2f4f5fdc0cf7a989e0eb0faeb7eb851d">More...</a><br /></td></tr>
<tr class="separator:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348bb238f39c562c428a7c0b733958b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Func &gt; </td></tr>
<tr class="memitem:ga348bb238f39c562c428a7c0b733958b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga348bb238f39c562c428a7c0b733958b7">bm::for_each_gap_blk</a> (const T *buf, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> offset, Func &amp;bit_functor)</td></tr>
<tr class="memdesc:ga348bb238f39c562c428a7c0b733958b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">for-each visitor, calls a special visitor functor for each 1 bit range  <a href="group__gapfunc.html#ga348bb238f39c562c428a7c0b733958b7">More...</a><br /></td></tr>
<tr class="separator:ga348bb238f39c562c428a7c0b733958b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>GAP functions implement different opereations on GAP compressed blocks (internals) and serve as a minimal building blocks. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7e39e9863fee8647e2db865439464a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e39e9863fee8647e2db865439464a05">&#9670;&nbsp;</a></span>bit_array_compute_gaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_array_compute_gaps </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute number of GAPs in bit-array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- array of BITs </td></tr>
    <tr><td class="paramname">len</td><td>- array length </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02478">2478</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a id="gaa2064b36ab5c3176e023cf3478e3ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2064b36ab5c3176e023cf3478e3ee04">&#9670;&nbsp;</a></span>bit_block_to_gap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_to_gap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts bit block to GAP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- Destinatio GAP buffer. </td></tr>
    <tr><td class="paramname">block</td><td>- Source bitblock buffer. </td></tr>
    <tr><td class="paramname">dest_len</td><td>- length of the dest. buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New length of GAP block or 0 if conversion failed (insufficicent space). </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03500">3500</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmutil_8h_source.html#l00301">bm::bit_scan_forward32()</a>, <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00179">BMRESTRICT</a>, and <a class="el" href="bmconst_8h_source.html#l00048">bm::set_block_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l03582">bm::bit_to_gap()</a>.</p>

</div>
</div>
<a id="ga348bb238f39c562c428a7c0b733958b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga348bb238f39c562c428a7c0b733958b7">&#9670;&nbsp;</a></span>for_each_gap_blk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_gap_blk </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&#160;</td>
          <td class="paramname"><em>bit_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for-each visitor, calls a special visitor functor for each 1 bit range </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- bit block buffer pointer </td></tr>
    <tr><td class="paramname">offset</td><td>- global block offset (number of bits) </td></tr>
    <tr><td class="paramname">bit_functor</td><td>- functor must support .add_range(offset, bits_ptr, size) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmalgo__impl_8h_source.html#l01677">1677</a> of file <a class="el" href="bmalgo__impl_8h_source.html">bmalgo_impl.h</a>.</p>

</div>
</div>
<a id="ga5614d83505b04921c1e89d077ae3d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5614d83505b04921c1e89d077ae3d3c7">&#9670;&nbsp;</a></span>for_each_gap_dbit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_gap_dbit </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate gap block as delta-bits with a functor. </p>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03602">3602</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a id="ga0322a5ff3d1b443ab31fcfacbab9168f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0322a5ff3d1b443ab31fcfacbab9168f">&#9670;&nbsp;</a></span>gap_add_to_bitset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_add_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds(OR) GAP block to bitblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02831">2831</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l02569">bm::or_bit_block()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, <a class="el" href="bmaggregator_8h_source.html#l01605">bm::aggregator&lt; bvector_type &gt;::combine_shift_right_and()</a>, <a class="el" href="bmfunc_8h_source.html#l03227">bm::gap_convert_to_bitset()</a>, and <a class="el" href="bmaggregator_8h_source.html#l01040">bm::aggregator&lt; bvector_type &gt;::process_gap_blocks_or()</a>.</p>

</div>
</div>
<a id="ga3e06b8bf018f8160ddda34a41143f8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e06b8bf018f8160ddda34a41143f8d4">&#9670;&nbsp;</a></span>gap_add_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_add_value </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new value to the end of GAP buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer. </td></tr>
    <tr><td class="paramname">pos</td><td>- Index of bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New GAP buffer length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02286">2286</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmserial_8h_source.html#l01330">bm::deseriaizer_base&lt; bm::decoder &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a id="ga1449bce424986cc7b4c4dedb09fbc715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1449bce424986cc7b4c4dedb09fbc715">&#9670;&nbsp;</a></span>gap_and_to_bitset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_and_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ANDs GAP block to bitblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02863">2863</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l02616">bm::sub_bit_block()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, <a class="el" href="bmaggregator_8h_source.html#l01051">bm::aggregator&lt; bvector_type &gt;::process_gap_blocks_and()</a>, and <a class="el" href="bmaggregator_8h_source.html#l01667">bm::aggregator&lt; bvector_type &gt;::process_shift_right_and()</a>.</p>

</div>
</div>
<a id="gab9336750a2de2949c29d19f20d87a843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9336750a2de2949c29d19f20d87a843">&#9670;&nbsp;</a></span>gap_and_to_bitset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_and_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td>
          <td class="paramname"><em>digest0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ANDs GAP block to bitblock with digest assist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">digest0</td><td>- digest of 0 strides for the destination </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02897">2897</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l00641">bm::check_zero_digest()</a>, <a class="el" href="bmutil_8h_source.html#l00334">bm::count_leading_zeros_u64()</a>, <a class="el" href="bmutil_8h_source.html#l00358">bm::count_trailing_zeros_u64()</a>, <a class="el" href="bmconst_8h_source.html#l00060">bm::set_block_digest_pos_shift</a>, and <a class="el" href="bmfunc_8h_source.html#l02616">bm::sub_bit_block()</a>.</p>

</div>
</div>
<a id="gac1117cb2e30df357a552fb1082229d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1117cb2e30df357a552fb1082229d76">&#9670;&nbsp;</a></span>gap_bit_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bits ON in GAP buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">dsize</td><td>- buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01550">1550</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l01583">bm::gap_bit_count_unr()</a>.</p>

</div>
</div>
<a id="gae83c2f3d1d54a1814ebf51d14aa19878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae83c2f3d1d54a1814ebf51d14aa19878">&#9670;&nbsp;</a></span>gap_bit_count_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count_range </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts 1 bits in GAP buffer in the closed [left, right] range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">left</td><td>- leftmost bit index to start from </td></tr>
    <tr><td class="paramname">right-</td><td>rightmost bit index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01649">1649</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l01096">bm::gap_bfind()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02814">bm::bvector&lt;&gt;::count_range()</a>, <a class="el" href="bm_8h_source.html#l02716">bm::bvector&lt;&gt;::count_to()</a>, and <a class="el" href="bm_8h_source.html#l02532">bm::bvector&lt;&gt;::running_count_blocks()</a>.</p>

</div>
</div>
<a id="ga41faacade39b8d62f30216d473ef1fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41faacade39b8d62f30216d473ef1fb1">&#9670;&nbsp;</a></span>gap_bit_count_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count_to </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts 1 bits in GAP buffer in the closed [0, right] range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">right-</td><td>rightmost bit index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01745">1745</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02716">bm::bvector&lt;&gt;::count_to()</a>, and <a class="el" href="bm_8h_source.html#l02760">bm::bvector&lt;&gt;::count_to_test()</a>.</p>

</div>
</div>
<a id="ga97e52a07431a2d09c35b8a249b02633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e52a07431a2d09c35b8a249b02633b">&#9670;&nbsp;</a></span>gap_bit_count_unr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count_unr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bits ON in GAP buffer. Loop unrolled version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01583">1583</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l01550">bm::gap_bit_count()</a>, and <a class="el" href="bmsse__util_8h_source.html#l00894">bm::sse2_gap_sum_arr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>, and <a class="el" href="bmserial_8h_source.html#l00786">bm::serializer&lt; bvector_type &gt;::encode_gap_block()</a>.</p>

</div>
</div>
<a id="ga0962484f2b2a8ea8a9c2d4de47cbc316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0962484f2b2a8ea8a9c2d4de47cbc316">&#9670;&nbsp;</a></span>gap_bitset_and_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_and_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitcount test of bit block AND masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero value if AND produces any result </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02985">2985</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04299">bm::bit_block_any_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="gac7f4b3de019ea33367356bc0910e31a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f4b3de019ea33367356bc0910e31a7">&#9670;&nbsp;</a></span>gap_bitset_and_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_and_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount of bit block AND masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitcount - cardinality of the AND product </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02958">2958</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l03925">bm::bit_block_calc_count_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00336">bm::combine_count_and_operation_with_block()</a>, and <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga48d5ed2e04e67900c364c4561c7787c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d5ed2e04e67900c364c4561c7787c4">&#9670;&nbsp;</a></span>gap_bitset_or_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_or_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount test of bit block OR masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if union (OR) returns anything </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03191">3191</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00923">bm::bit_is_all_zero()</a>, and <a class="el" href="bmfunc_8h_source.html#l00950">bm::gap_is_all_zero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="gac532282d6f0cbb3ae48bc119c55c49b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac532282d6f0cbb3ae48bc119c55c49b9">&#9670;&nbsp;</a></span>gap_bitset_or_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_or_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount of bit block OR masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit count of OR </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03159">3159</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l03925">bm::bit_block_calc_count_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef71ffa5a8fda6ffe3ff2c69fe7f077">&#9670;&nbsp;</a></span>gap_bitset_sub_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_sub_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount test of bit block SUB masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero value if AND NOT produces any 1 bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03048">3048</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04299">bm::bit_block_any_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga7352f6f48aed8cb7ded4d9a8a7deb6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7352f6f48aed8cb7ded4d9a8a7deb6af">&#9670;&nbsp;</a></span>gap_bitset_sub_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_sub_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount of bit block SUB masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit-count result of AND NOT operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03014">3014</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l03925">bm::bit_block_calc_count_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="gac737cc3e97c0787297d54da57902ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac737cc3e97c0787297d54da57902ca29">&#9670;&nbsp;</a></span>gap_bitset_xor_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_xor_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount test of bit block XOR masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero value if XOR returns anything </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03122">3122</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04299">bm::bit_block_any_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga4303eb15c00a062e484635737c8f43ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4303eb15c00a062e484635737c8f43ed">&#9670;&nbsp;</a></span>gap_bitset_xor_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_xor_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bitcount of bit block XOR masked by GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bitblock buffer pointer </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit count value of XOR operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03085">3085</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l03925">bm::bit_block_calc_count_range()</a>, and <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="gaef97eb2d854ee06d2c2137f7af11982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef97eb2d854ee06d2c2137f7af11982b">&#9670;&nbsp;</a></span>gap_buff_any_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_buff_any_op </td>
          <td>(</td>
          <td class="paramtype">const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vect1_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vect2_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abstract distance test operation for GAP buffers. Receives functor F as a template argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 GAP encoded buffer. </td></tr>
    <tr><td class="paramname">vect1_mask</td><td>- XOR mask for starting bitflag for vector1 can be 0 or 1 (1 inverts the vector) </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 GAP encoded buffer. </td></tr>
    <tr><td class="paramname">vect2_mask</td><td>- same as vect1_mask </td></tr>
    <tr><td class="paramname">f</td><td>- operation functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Internal function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if operation result returns any 1 bit </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02039">2039</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l04477">bm::gap_operation_any_and()</a>, <a class="el" href="bmfunc_8h_source.html#l04655">bm::gap_operation_any_sub()</a>, and <a class="el" href="bmfunc_8h_source.html#l04544">bm::gap_operation_any_xor()</a>.</p>

</div>
</div>
<a id="ga94c46d5dae114fdb2dd758cd80ba5dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94c46d5dae114fdb2dd758cd80ba5dae">&#9670;&nbsp;</a></span>gap_buff_count_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_buff_count_op </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 GAP encoded buffer. </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 GAP encoded buffer. </td></tr>
    <tr><td class="paramname">f</td><td>- operation functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Internal function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02108">2108</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l04494">bm::gap_count_and()</a>, <a class="el" href="bmfunc_8h_source.html#l04605">bm::gap_count_or()</a>, <a class="el" href="bmfunc_8h_source.html#l04672">bm::gap_count_sub()</a>, and <a class="el" href="bmfunc_8h_source.html#l04560">bm::gap_count_xor()</a>.</p>

</div>
</div>
<a id="ga973ee6ac889acaa5a1cb61595b15793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973ee6ac889acaa5a1cb61595b15793a">&#9670;&nbsp;</a></span>gap_calc_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int bm::gap_calc_level </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates GAP block capacity level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>- GAP buffer length. </td></tr>
    <tr><td class="paramname">glevel_len</td><td>- GAP lengths table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GAP block capacity level. -1 if block does not fit any level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03427">3427</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00076">bm::gap_levels</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmserial_8h_source.html#l03194">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="bmserial_8h_source.html#l01416">bm::deserializer&lt; typename SV::bvector_type, bm::decoder &gt;::deserialize_gap()</a>, and <a class="el" href="bmfunc_8h_source.html#l06626">bm::gap_overhead()</a>.</p>

</div>
</div>
<a id="ga03a34c5aab766103f262b22e1df5a159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a34c5aab766103f262b22e1df5a159">&#9670;&nbsp;</a></span>gap_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_capacity </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returs GAP block capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
    <tr><td class="paramname">glevel_len</td><td>- pointer on GAP header word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GAP block capacity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l00993">993</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03193">bm::bvector&lt;&gt;::calc_stat()</a>, <a class="el" href="bmalloc_8h_source.html#l00360">bm::mem_alloc&lt; BA, PA, APool &gt;::free_gap_block()</a>, and <a class="el" href="bmfunc_8h_source.html#l03448">bm::gap_free_elements()</a>.</p>

</div>
</div>
<a id="ga460d8564dd82a511db120e9c01fb529d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga460d8564dd82a511db120e9c01fb529d">&#9670;&nbsp;</a></span>gap_control_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_control_sum </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates sum of all words in GAP block. (For debugging purposes) </p>
<dl class="section note"><dt>Note</dt><dd>For debugging and testing ONLY. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of all words. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03284">3284</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

</div>
</div>
<a id="gab3aa03295329ef84f8e25b1da19d6794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3aa03295329ef84f8e25b1da19d6794">&#9670;&nbsp;</a></span>gap_convert_to_arr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">D bm::gap_convert_to_arr </td>
          <td>(</td>
          <td class="paramtype">D *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert gap block into array of ints corresponding to 1 bits. </p>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03657">3657</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00086">BMREGISTER</a>, and <a class="el" href="bmdef_8h_source.html#l00179">BMRESTRICT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmserial_8h_source.html#l00786">bm::serializer&lt; bvector_type &gt;::encode_gap_block()</a>, and <a class="el" href="bmrandom_8h_source.html#l00130">bm::random_subset&lt; BV &gt;::sample()</a>.</p>

</div>
</div>
<a id="ga6f73b66e24322db3d885b9b53d43e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f73b66e24322db3d885b9b53d43e75f">&#9670;&nbsp;</a></span>gap_convert_to_bitset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_convert_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP block to bitblock conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03227">3227</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l03209">bm::bit_block_set()</a>, and <a class="el" href="bmfunc_8h_source.html#l02831">bm::gap_add_to_bitset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>, <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, <a class="el" href="bm_8h_source.html#l03051">bm::bvector&lt;&gt;::compare()</a>, <a class="el" href="bmserial_8h_source.html#l03426">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="bmserial_8h_source.html#l01416">bm::deserializer&lt; typename SV::bvector_type, bm::decoder &gt;::deserialize_gap()</a>, <a class="el" href="bmfunc_8h_source.html#l03263">bm::gap_convert_to_bitset_smart()</a>, <a class="el" href="bmrandom_8h_source.html#l00130">bm::random_subset&lt; BV &gt;::sample()</a>, and <a class="el" href="bmvmin_8h_source.html#l00143">bm::miniset&lt; A, N &gt;::swap()</a>.</p>

</div>
</div>
<a id="ga0f4ac4f8a08a46903655eca907b19385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f4ac4f8a08a46903655eca907b19385">&#9670;&nbsp;</a></span>gap_convert_to_bitset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_convert_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP block to bitblock conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">dest_len</td><td>- length/size of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03243">3243</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l02831">bm::gap_add_to_bitset()</a>.</p>

</div>
</div>
<a id="ga90dc1e34b98cf061c60f1efc5e3e4bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90dc1e34b98cf061c60f1efc5e3e4bf0">&#9670;&nbsp;</a></span>gap_convert_to_bitset_smart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned* bm::gap_convert_to_bitset_smart </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a>&#160;</td>
          <td class="paramname"><em>set_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart GAP block to bitblock conversion. </p>
<p>Checks if GAP block is ALL-ZERO or ALL-ON. In those cases returns pointer on special static bitblocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">set_max</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03263">3263</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00135">FULL_BLOCK_REAL_ADDR</a>, and <a class="el" href="bmfunc_8h_source.html#l03227">bm::gap_convert_to_bitset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="gafd92d013b0c377604831f401ef6917b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd92d013b0c377604831f401ef6917b8">&#9670;&nbsp;</a></span>gap_count_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_count_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP bitcount AND operation test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitcount of vect1 AND vect2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04494">4494</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmfunc_8h_source.html#l02108">bm::gap_buff_count_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00336">bm::combine_count_and_operation_with_block()</a>, and <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga125fc8dc68245a11a171e7793c6588a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125fc8dc68245a11a171e7793c6588a2">&#9670;&nbsp;</a></span>gap_count_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_count_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP bitcount OR operation test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitcount of vect1 OR vect2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04605">4605</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l02108">bm::gap_buff_count_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l04424">bm::or_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="gacacf55c60da82a1c384f3ac3a51229d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacacf55c60da82a1c384f3ac3a51229d4">&#9670;&nbsp;</a></span>gap_count_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_count_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP bitcount SUB (AND NOT) operation test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitcount of vect1 SUB (AND NOT) vect2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04672">4672</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l02108">bm::gap_buff_count_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l04430">bm::sub_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="gae38d6a3296f0562be512f47b4edfb1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38d6a3296f0562be512f47b4edfb1ad">&#9670;&nbsp;</a></span>gap_count_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_count_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP bitcount XOR operation test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitcount of vect1 XOR vect2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04560">4560</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l02108">bm::gap_buff_count_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l04417">bm::xor_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00119">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga0204a8054e2c906df66eae53d4ad1564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0204a8054e2c906df66eae53d4ad1564">&#9670;&nbsp;</a></span>gap_find_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_find_first </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP block find the first set bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">first</td><td>- index of the first 1 bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if 1 bit was NOT found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01069">1069</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03779">bm::bvector&lt;&gt;::find()</a>.</p>

</div>
</div>
<a id="gac62a37d6cc70a055ebdb86fcd6664b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac62a37d6cc70a055ebdb86fcd6664b2c">&#9670;&nbsp;</a></span>gap_find_in_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_find_in_block </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the next 1 bit in the GAP block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer </td></tr>
    <tr><td class="paramname">nbit</td><td>- bit index to start checking from. </td></tr>
    <tr><td class="paramname">prev</td><td>- returns previously checked value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02511">2511</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, <a class="el" href="bmfunc_8h_source.html#l01096">bm::gap_bfind()</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03943">bm::bvector&lt;&gt;::select()</a>.</p>

</div>
</div>
<a id="gaad4ed22413b908890186e658ab9992fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad4ed22413b908890186e658ab9992fa">&#9670;&nbsp;</a></span>gap_find_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_find_last </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP block find the last set bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">last</td><td>- index of the last 1 bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if 1 bit was NOT found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01039">1039</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03735">bm::bvector&lt;&gt;::find_reverse()</a>.</p>

</div>
</div>
<a id="ga69b3d2a5089abc09d39d80ae48718965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b3d2a5089abc09d39d80ae48718965">&#9670;&nbsp;</a></span>gap_find_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_find_rank </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbit_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nbit_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP block find position for the rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>- bit block buffer pointer </td></tr>
    <tr><td class="paramname">rank</td><td>- rank to find (must be &gt; 0) </td></tr>
    <tr><td class="paramname">nbit_from</td><td>- start bit position in block </td></tr>
    <tr><td class="paramname">nbit_pos</td><td>- found position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if position with rank was found, or the remaining rank (rank - population count) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01695">1695</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l01096">bm::gap_bfind()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l06485">bm::block_find_rank()</a>.</p>

</div>
</div>
<a id="ga97b1fcf40d8fdccfccd2083d654a6436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97b1fcf40d8fdccfccd2083d654a6436">&#9670;&nbsp;</a></span>gap_free_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_free_elements </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer </td></tr>
    <tr><td class="paramname">glevel_len</td><td>- GAP lengths table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of free GAP elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03448">3448</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00993">bm::gap_capacity()</a>, and <a class="el" href="bmfunc_8h_source.html#l00064">bm::bv_statistics::gap_length</a>.</p>

</div>
</div>
<a id="ga9126461f19bfe024093c4c5fd816c083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9126461f19bfe024093c4c5fd816c083">&#9670;&nbsp;</a></span>gap_init_range_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_init_range_block </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init gap block so it has block in it (can be whole block) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">from</td><td>- one block start </td></tr>
    <tr><td class="paramname">to</td><td>- one block end </td></tr>
    <tr><td class="paramname">value</td><td>- (block value)1 or 0 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03335">3335</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00087">bm::bits_in_block</a>, <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l03315">bm::gap_set_all()</a>.</p>

</div>
</div>
<a id="ga1ba1509608fe39847b88c062128fff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba1509608fe39847b88c062128fff99">&#9670;&nbsp;</a></span>gap_invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_invert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts all bits in the GAP buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03386">3386</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, <a class="el" href="bmfunc_8h_source.html#l04585">bm::gap_operation_or()</a>, and <a class="el" href="bmserial_8h_source.html#l01330">bm::deseriaizer_base&lt; bm::decoder &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a id="gab67f48231637a4dacea298a38351e84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67f48231637a4dacea298a38351e84c">&#9670;&nbsp;</a></span>gap_is_all_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool bm::gap_is_all_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if GAP block is all-one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">set_max</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all-one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l00965">965</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l06603">bm::check_block_one()</a>.</p>

</div>
</div>
<a id="ga546842afd6d6097e5c11905bcd44ddd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546842afd6d6097e5c11905bcd44ddd6">&#9670;&nbsp;</a></span>gap_is_all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool bm::gap_is_all_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if GAP block is all-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all-zero. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l00950">950</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l06580">bm::check_block_zero()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>, <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, <a class="el" href="bm_8h_source.html#l03051">bm::bvector&lt;&gt;::compare()</a>, and <a class="el" href="bmfunc_8h_source.html#l03191">bm::gap_bitset_or_any()</a>.</p>

</div>
</div>
<a id="ga8b5fa3a228bd9d820f96f136663982aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b5fa3a228bd9d820f96f136663982aa">&#9670;&nbsp;</a></span>gap_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> bm::gap_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returs GAP block length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GAP block length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l00978">978</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03193">bm::bvector&lt;&gt;::calc_stat()</a>, <a class="el" href="bmserial_8h_source.html#l03194">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="bmserial_8h_source.html#l01416">bm::deserializer&lt; typename SV::bvector_type, bm::decoder &gt;::deserialize_gap()</a>, <a class="el" href="bmserial_8h_source.html#l00786">bm::serializer&lt; bvector_type &gt;::encode_gap_block()</a>, <a class="el" href="bmserial_8h_source.html#l00702">bm::serializer&lt; bvector_type &gt;::gamma_gap_block()</a>, and <a class="el" href="bmserial_8h_source.html#l01330">bm::deseriaizer_base&lt; bm::decoder &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a id="gab9b12b23371696c9509d8421aeb082ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b12b23371696c9509d8421aeb082ed">&#9670;&nbsp;</a></span>gap_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::gap_level </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returs GAP blocks capacity level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GAP block capacity level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01022">1022</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a id="gae256c20673e9e1beb4a64cec957caa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae256c20673e9e1beb4a64cec957caa48">&#9670;&nbsp;</a></span>gap_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_limit </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returs GAP block capacity limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">glevel_len</td><td>- GAP lengths table (<a class="el" href="structbm_1_1gap__len__table.html" title="Default GAP lengths table. ">gap_len_table</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GAP block limit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01008">1008</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l01134">bm::combine_or()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l01303">bm::combine_sub()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l01216">bm::combine_xor()</a>, <a class="el" href="bm_8h_source.html#l03462">bm::bvector&lt;&gt;::import_block()</a>, <a class="el" href="bm_8h_source.html#l04144">bm::bvector&lt;&gt;::insert()</a>, and <a class="el" href="bm_8h_source.html#l03943">bm::bvector&lt;&gt;::select()</a>.</p>

</div>
</div>
<a id="gac18d7da0492983802511999a4ad0764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18d7da0492983802511999a4ad0764a">&#9670;&nbsp;</a></span>gap_operation_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* bm::gap_operation_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP AND operation. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
    <tr><td class="paramname">tmp_buf</td><td>- pointer on temporary buffer </td></tr>
    <tr><td class="paramname">dsize</td><td>- out size of the destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result pointer (tmp_buf OR vect1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04453">4453</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmfunc_8h_source.html#l01958">bm::gap_buff_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l07000">bm::operation_functions&lt; T &gt;::bit_operation_count()</a>, and <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="ga58e0312d3ab0551e883176b170c0a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e0312d3ab0551e883176b170c0a3e8">&#9670;&nbsp;</a></span>gap_operation_any_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_operation_any_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP AND operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04477">4477</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmfunc_8h_source.html#l02039">bm::gap_buff_any_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="ga1c9b33d00f74206ad655dc2cef52428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9b33d00f74206ad655dc2cef52428b">&#9670;&nbsp;</a></span>gap_operation_any_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_operation_any_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP SUB operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04655">4655</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmfunc_8h_source.html#l02039">bm::gap_buff_any_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="gab8800dff60eb05404a83159035e8e72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8800dff60eb05404a83159035e8e72f">&#9670;&nbsp;</a></span>gap_operation_any_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned bm::gap_operation_any_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP XOR operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04544">4544</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, <a class="el" href="bmfunc_8h_source.html#l02039">bm::gap_buff_any_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l04417">bm::xor_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a id="gacda280af8910ae5fde37731a3a7a1226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda280af8910ae5fde37731a3a7a1226">&#9670;&nbsp;</a></span>gap_operation_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* bm::gap_operation_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GAP OR operation. </p>
<p>Function performs OR logical oparation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
    <tr><td class="paramname">tmp_buf</td><td>- pointer on temporary buffer </td></tr>
    <tr><td class="paramname">dsize</td><td>- out destination size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result pointer (tmp_buf) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04585">4585</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, <a class="el" href="bmfunc_8h_source.html#l01958">bm::gap_buff_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l03386">bm::gap_invert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l07000">bm::operation_functions&lt; T &gt;::bit_operation_count()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l00373">bm::combine_any_operation_with_block()</a>, and <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="gabe4c83e5e162c38e297116dd1cd05ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4c83e5e162c38e297116dd1cd05ac4">&#9670;&nbsp;</a></span>gap_operation_sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* bm::gap_operation_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GAP SUB (AND NOT) operation. </p>
<p>Function performs SUB logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
    <tr><td class="paramname">tmp_buf</td><td>- pointer on temporary buffer </td></tr>
    <tr><td class="paramname">dsize</td><td>- out destination size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result pointer (tmp_buf) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04630">4630</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l04410">bm::and_op()</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, and <a class="el" href="bmfunc_8h_source.html#l01958">bm::gap_buff_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l07000">bm::operation_functions&lt; T &gt;::bit_operation_count()</a>, and <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="ga72d2d3933b4410413eeb02e9ee0a910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d2d3933b4410413eeb02e9ee0a910d">&#9670;&nbsp;</a></span>gap_operation_xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* bm::gap_operation_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAP XOR operation. </p>
<p>Function performs XOR logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect1</td><td>- operand 1 </td></tr>
    <tr><td class="paramname">vect2</td><td>- operand 2 </td></tr>
    <tr><td class="paramname">tmp_buf</td><td>- pointer on temporary buffer </td></tr>
    <tr><td class="paramname">dsize</td><td>- out destination size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result pointer (tmp_buf) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l04519">4519</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00189">BMFORCEINLINE</a>, <a class="el" href="bmfunc_8h_source.html#l01958">bm::gap_buff_op()</a>, and <a class="el" href="bmfunc_8h_source.html#l04417">bm::xor_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l07000">bm::operation_functions&lt; T &gt;::bit_operation_count()</a>, and <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="gaa029c18363842b7c534e8c1b806cfc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa029c18363842b7c534e8c1b806cfc49">&#9670;&nbsp;</a></span>gap_overhead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_overhead </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>length_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates memory overhead for number of gap blocks sharing the same memory allocation table (level lengths table). </p>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l06626">6626</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l03427">bm::gap_calc_level()</a>, and <a class="el" href="bmconst_8h_source.html#l00076">bm::gap_levels</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l06653">bm::improve_gap_levels()</a>.</p>

</div>
</div>
<a id="gaa4547663f2ac44e1dab9d94cd866b0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4547663f2ac44e1dab9d94cd866b0ca">&#9670;&nbsp;</a></span>gap_set_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_set_all </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>set_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all bits to 0 or 1 (GAP) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">set_max</td><td>- max possible bitset length </td></tr>
    <tr><td class="paramname">value</td><td>- value to set </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03315">3315</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l03335">bm::gap_init_range_block()</a>, <a class="el" href="bmserial_8h_source.html#l01330">bm::deseriaizer_base&lt; bm::decoder &gt;::read_gap_block()</a>, and <a class="el" href="bmvmin_8h_source.html#l00143">bm::miniset&lt; A, N &gt;::swap()</a>.</p>

</div>
</div>
<a id="ga2d7062f126291c8ab493cef420205e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d7062f126291c8ab493cef420205e00">&#9670;&nbsp;</a></span>gap_set_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_set_array </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert array to GAP buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer. </td></tr>
    <tr><td class="paramname">arr</td><td>- array of values to set </td></tr>
    <tr><td class="paramname">len</td><td>- length of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New GAP buffer length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02418">2418</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmserial_8h_source.html#l01416">bm::deserializer&lt; typename SV::bvector_type, bm::decoder &gt;::deserialize_gap()</a>, and <a class="el" href="bmserial_8h_source.html#l01330">bm::deseriaizer_base&lt; bm::decoder &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a id="ga59567b7dcd289833d5d09639b23c5c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59567b7dcd289833d5d09639b23c5c61">&#9670;&nbsp;</a></span>gap_set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_set_value </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>&#160;</td>
          <td class="paramname"><em>is_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or clears bit in the GAP buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
    <tr><td class="paramname">buf</td><td>- GAP buffer. </td></tr>
    <tr><td class="paramname">pos</td><td>- Index of bit to set. </td></tr>
    <tr><td class="paramname">is_set</td><td>- (OUT) flag if bit was actually set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New GAP buffer length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02193">2193</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l01096">bm::gap_bfind()</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l01134">bm::combine_or()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l01303">bm::combine_sub()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l01216">bm::combine_xor()</a>, <a class="el" href="bmfunc_8h_source.html#l02367">bm::gap_shift_r1()</a>, <a class="el" href="bm_8h_source.html#l03462">bm::bvector&lt;&gt;::import_block()</a>, <a class="el" href="bm_8h_source.html#l03943">bm::bvector&lt;&gt;::select()</a>, and <a class="el" href="bmvmin_8h_source.html#l00100">bm::miniset&lt; A, N &gt;::set()</a>.</p>

</div>
</div>
<a id="ga77bbec8d06687f311c46d89352276248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77bbec8d06687f311c46d89352276248">&#9670;&nbsp;</a></span>gap_shift_r1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::gap_shift_r1 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>co_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>new_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right shift GAP block by 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- block pointer </td></tr>
    <tr><td class="paramname">co_falg</td><td>- carry over from the previous block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>carry over bit (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02367">2367</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>, and <a class="el" href="bmfunc_8h_source.html#l02193">bm::gap_set_value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04144">bm::bvector&lt;&gt;::insert()</a>.</p>

</div>
</div>
<a id="ga1f4e632a6f6135148ec76a3ca10e0a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4e632a6f6135148ec76a3ca10e0a70">&#9670;&nbsp;</a></span>gap_sub_to_bitset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_sub_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUB (AND NOT) GAP block to bitblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02719">2719</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l02616">bm::sub_bit_block()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>, and <a class="el" href="bmaggregator_8h_source.html#l01085">bm::aggregator&lt; bvector_type &gt;::process_gap_blocks_sub()</a>.</p>

</div>
</div>
<a id="ga197d8b08506aa4a0589ed306ae134490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197d8b08506aa4a0589ed306ae134490">&#9670;&nbsp;</a></span>gap_sub_to_bitset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_sub_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td>
          <td class="paramname"><em>digest0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUB (AND NOT) GAP block to bitblock with digest assist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">digest0</td><td>- digest of 0 strides inside bit block </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02747">2747</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l00641">bm::check_zero_digest()</a>, <a class="el" href="bmutil_8h_source.html#l00334">bm::count_leading_zeros_u64()</a>, <a class="el" href="bmutil_8h_source.html#l00358">bm::count_trailing_zeros_u64()</a>, <a class="el" href="bmconst_8h_source.html#l00060">bm::set_block_digest_pos_shift</a>, and <a class="el" href="bmfunc_8h_source.html#l02616">bm::sub_bit_block()</a>.</p>

</div>
</div>
<a id="gafb8a20a8290d5b37f212bc0bec738357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb8a20a8290d5b37f212bc0bec738357">&#9670;&nbsp;</a></span>gap_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_test </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if bit = pos is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">pos</td><td>- index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if position is in "1" gap </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01124">1124</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmfunc_8h_source.html#l01167">bm::gap_test_unr()</a>, and <a class="el" href="bmvmin_8h_source.html#l00089">bm::miniset&lt; A, N &gt;::test()</a>.</p>

</div>
</div>
<a id="ga1c3ea43579816f35ff24fad63b8dc089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3ea43579816f35ff24fad63b8dc089">&#9670;&nbsp;</a></span>gap_test_unr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_test_unr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if bit = pos is true. Analog of <a class="el" href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357" title="Tests if bit = pos is true. ">bm::gap_test</a> with SIMD unrolling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">pos</td><td>- index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if position is in "1" gap </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01167">1167</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l01124">bm::gap_test()</a>, <a class="el" href="bmsse2_8h_source.html#l00345">bm::sse2_gap_find()</a>, and <a class="el" href="bmsse4_8h_source.html#l00706">bm::sse4_gap_find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmalgo__impl_8h_source.html#l01303">bm::combine_sub()</a>, <a class="el" href="bmalgo__impl_8h_source.html#l01216">bm::combine_xor()</a>, <a class="el" href="bm_8h_source.html#l02760">bm::bvector&lt;&gt;::count_to_test()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01155">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::extract_range()</a>, <a class="el" href="bmsparsevec_8h_source.html#l01014">bm::sparse_vector&lt; unsigned, bm::bvector&lt;&gt; &gt;::gather()</a>, <a class="el" href="bm_8h_source.html#l02933">bm::bvector&lt;&gt;::get_bit()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00974">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::get_half_octet()</a>, <a class="el" href="bmbmatrix_8h_source.html#l00863">bm::basic_bmatrix&lt; bm::bvector&lt;&gt; &gt;::get_octet()</a>, <a class="el" href="bm_8h_source.html#l03557">bm::bvector&lt;&gt;::inc()</a>, <a class="el" href="bmaggregator_8h_source.html#l01051">bm::aggregator&lt; bvector_type &gt;::process_gap_blocks_and()</a>, <a class="el" href="bmaggregator_8h_source.html#l01085">bm::aggregator&lt; bvector_type &gt;::process_gap_blocks_sub()</a>, <a class="el" href="bmaggregator_8h_source.html#l01119">bm::aggregator&lt; bvector_type &gt;::test_gap_blocks_and()</a>, and <a class="el" href="bmaggregator_8h_source.html#l01133">bm::aggregator&lt; bvector_type &gt;::test_gap_blocks_sub()</a>.</p>

</div>
</div>
<a id="ga8681f5db8e4c3a1467db41048dba67b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8681f5db8e4c3a1467db41048dba67b1">&#9670;&nbsp;</a></span>gap_xor_to_bitset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_xor_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pcurr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XOR GAP block to bitblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td class="paramname">pcurr</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l02805">2805</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmfunc_8h_source.html#l02663">bm::xor_bit_block()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04995">bm::bvector&lt;&gt;::combine_operation()</a>.</p>

</div>
</div>
<a id="ga26ab5d91179de63eb74c66ea6e1e4cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ab5d91179de63eb74c66ea6e1e4cc4">&#9670;&nbsp;</a></span>gapcmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::gapcmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographical comparison of GAP buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf1</td><td>- First GAP buffer pointer. </td></tr>
    <tr><td class="paramname">buf2</td><td>- Second GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 - less, =0 - equal, &gt;0 - greater. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l01891">1891</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03051">bm::bvector&lt;&gt;::compare()</a>.</p>

</div>
</div>
<a id="ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4f5fdc0cf7a989e0eb0faeb7eb851d">&#9670;&nbsp;</a></span>improve_gap_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::improve_gap_levels </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>length_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>glevel_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds optimal gap blocks lengths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>- first element of GAP lengths array </td></tr>
    <tr><td class="paramname">length_end</td><td>- end of the GAP lengths array </td></tr>
    <tr><td class="paramname">glevel_len</td><td>- destination GAP lengths array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l06653">6653</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00076">bm::gap_levels</a>, <a class="el" href="bmconst_8h_source.html#l00072">bm::gap_max_buff_len</a>, and <a class="el" href="bmfunc_8h_source.html#l06626">bm::gap_overhead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03011">bm::bvector&lt;&gt;::optimize_gap_size()</a>.</p>

</div>
</div>
<a id="ga9a026368549e02e8af9b6c290536c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a026368549e02e8af9b6c290536c2fc">&#9670;&nbsp;</a></span>set_gap_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::set_gap_level </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GAP block capacity level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- GAP buffer pointer. </td></tr>
    <tr><td class="paramname">level</td><td>new GAP block capacity level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmfunc_8h_source.html#l03405">3405</a> of file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00116">BM_ASSERT</a>, and <a class="el" href="bmconst_8h_source.html#l00076">bm::gap_levels</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmserial_8h_source.html#l03426">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="bmserial_8h_source.html#l01416">bm::deserializer&lt; typename SV::bvector_type, bm::decoder &gt;::deserialize_gap()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
