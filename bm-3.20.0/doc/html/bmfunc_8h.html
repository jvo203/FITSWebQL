<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: bmfunc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bmfunc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Bit manipulation primitives (internal)  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;memory.h&gt;</code><br />
<code>#include &quot;<a class="el" href="bmdef_8h_source.html">bmdef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bmutil_8h_source.html">bmutil.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bmfunc.h:</div>
<div class="dyncontent">
<div class="center"><img src="bmfunc_8h__incl.png" border="0" usemap="#bmfunc_8h" alt=""/></div>
<map name="bmfunc_8h" id="bmfunc_8h">
<area shape="rect" id="node3" href="bmdef_8h.html" title="Definitions(internal) " alt="" coords="82,155,150,181"/>
<area shape="rect" id="node6" href="bmutil_8h.html" title="Bit manipulation primitives (internal) " alt="" coords="174,80,242,107"/>
<area shape="rect" id="node7" href="bmconst_8h.html" title="Constants, tables and typedefs. " alt="" coords="175,155,257,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="bmfunc_8h__dep__incl.png" border="0" usemap="#bmfunc_8hdep" alt=""/></div>
<map name="bmfunc_8hdep" id="bmfunc_8hdep">
<area shape="rect" id="node2" href="bm_8h.html" title="Compressed bit&#45;vector bvector&lt;&gt; container, set algebraic methods, traversal iterators. " alt="" coords="1532,80,1583,107"/>
<area shape="rect" id="node23" href="bmalgo_8h.html" title="Algorithms for bvector&lt;&gt; (main include) " alt="" coords="1293,155,1368,181"/>
<area shape="rect" id="node30" href="bmalgo__similarity_8h.html" title="bmalgo_similarity.h" alt="" coords="433,304,567,331"/>
<area shape="rect" id="node31" href="bmaggregator_8h.html" title="Algorithms for fast aggregation of N bvectors. " alt="" coords="1056,155,1168,181"/>
<area shape="rect" id="node33" href="bmserial_8h.html" title="Serialization / compression of bvector&lt;&gt;. Set operations on compressed BLOBs. " alt="" coords="716,155,799,181"/>
<area shape="rect" id="node37" href="bmrandom_8h.html" title="Generation of random subset. " alt="" coords="73,155,167,181"/>
<area shape="rect" id="node3" href="bmbmatrix_8h.html" title="basic bit&#45;matrix class and utilities " alt="" coords="3243,155,3338,181"/>
<area shape="rect" id="node4" href="bmsparsevec_8h.html" title="Sparse constainer sparse_vector&lt;&gt; for integer types using bit&#45;transposition transform. " alt="" coords="2621,229,2731,256"/>
<area shape="rect" id="node6" href="xsample01_8cpp.html" title="Example: Example: memory consumption techniques. " alt="" coords="1463,379,1574,405"/>
<area shape="rect" id="node7" href="xsample03_8cpp.html" title="Example: SNP search in human genome. " alt="" coords="1295,379,1406,405"/>
<area shape="rect" id="node8" href="xsample05_8cpp.html" title="Example: Example on how to use bit&#45;transposed string sparse vector. " alt="" coords="654,379,765,405"/>
<area shape="rect" id="node17" href="xsample02_8cpp.html" title="Example: sparse_vector&lt;&gt; used for counting sort / historgam construction. " alt="" coords="2149,304,2259,331"/>
<area shape="rect" id="node21" href="bmstrsparsevec_8h.html" title="string sparse vector based on bit&#45;transposed matrix " alt="" coords="2051,229,2175,256"/>
<area shape="rect" id="node24" href="sample7_8cpp.html" title="Example: set operations between bvector&lt;&gt; and arrays of integers. " alt="" coords="1505,229,1601,256"/>
<area shape="rect" id="node25" href="sample9_8cpp.html" title="Example: bvector&lt;&gt; binary similarity / distance algorithms. " alt="" coords="1625,229,1721,256"/>
<area shape="rect" id="node26" href="sample11_8cpp.html" title="Example: bvector&lt;&gt; bit&#45;counting techniques analysis. " alt="" coords="1746,229,1849,256"/>
<area shape="rect" id="node27" href="sample12_8cpp.html" title="Example: bvector&lt;&gt; analysis of bit setting methods. " alt="" coords="1925,229,2027,256"/>
<area shape="rect" id="node28" href="bvsetalgebra_8cpp.html" title="Example: algebra of sets operations. " alt="" coords="846,229,965,256"/>
<area shape="rect" id="node29" href="xsample04_8cpp.html" title="Example: DNA substring search. " alt="" coords="989,229,1099,256"/>
<area shape="rect" id="node32" href="sample16_8cpp.html" title="Example: how to use bm::aggregator&lt;&gt; for logical operations. " alt="" coords="1175,229,1278,256"/>
<area shape="rect" id="node35" href="sample4_8cpp.html" title="Example: bvector&lt;&gt; serialization/deserialization. " alt="" coords="344,229,440,256"/>
<area shape="rect" id="node36" href="sample14_8cpp.html" title="Example: bvector&lt;&gt; set operations on serialized/compressed BLOBs. " alt="" coords="465,229,567,256"/>
<area shape="rect" id="node38" href="sample10_8cpp.html" title="Example: bvector&lt;&gt; generation of random sub&#45;set. " alt="" coords="115,229,218,256"/>
<area shape="rect" id="node39" href="sample1_8cpp.html" title="Example: bvector&lt;&gt; set bits and then retrieve indexes of ON bits. " alt="" coords="1595,155,1691,181"/>
<area shape="rect" id="node40" href="sample2_8cpp.html" title="Example: bvector&lt;&gt; set algebra operations AND, OR, XOR, etc. " alt="" coords="1715,155,1811,181"/>
<area shape="rect" id="node41" href="sample3_8cpp.html" title="Example: bvector&lt;&gt; with different allocation/compression strategies. " alt="" coords="1835,155,1931,181"/>
<area shape="rect" id="node42" href="sample5_8cpp.html" title="Example: bvector&lt;&gt;::enumerator use. " alt="" coords="1955,155,2051,181"/>
<area shape="rect" id="node43" href="sample6_8cpp.html" title="Example: bvector&lt;&gt; custom memory allocator. " alt="" coords="2075,155,2171,181"/>
<area shape="rect" id="node44" href="sample8_8cpp.html" title="Example: bvector&lt;&gt; &#45; STL interoperability. " alt="" coords="2195,155,2291,181"/>
<area shape="rect" id="node45" href="sample15_8cpp.html" title="Example: bvector&lt;&gt; methods to find last bit and bit&#45;vectors effective range. " alt="" coords="2315,155,2418,181"/>
<area shape="rect" id="node46" href="sample17_8cpp.html" title="Example: rank and select operations using rank&#45;select index. " alt="" coords="2442,155,2545,181"/>
<area shape="rect" id="node47" href="sample18_8cpp.html" title="Example: bulk insert iterator. " alt="" coords="2569,155,2671,181"/>
<area shape="rect" id="node48" href="sample19_8cpp.html" title="Example: bit&#45;vector merge. " alt="" coords="2695,155,2798,181"/>
<area shape="rect" id="node49" href="sample20_8cpp.html" title="Example: bvector&lt;&gt; &#45; bit&#45;shifts. " alt="" coords="2822,155,2925,181"/>
<area shape="rect" id="node50" href="xsample04a_8cpp.html" title="Example: DNA index construction. " alt="" coords="2949,155,3067,181"/>
<area shape="rect" id="node5" href="bmsparsevec__algo_8h.html" title="Algorithms for sparse_vector&lt;&gt; " alt="" coords="1933,304,2073,331"/>
<area shape="rect" id="node10" href="svsample05_8cpp.html" title="Example: sparse_vector&lt;&gt; used for set 2 set remapping (theory of groups Image) " alt="" coords="2531,379,2645,405"/>
<area shape="rect" id="node11" href="svsample06_8cpp.html" title="Example: sparse_vector&lt;&gt; scan search (non&#45;ordered set functionality) " alt="" coords="2669,379,2784,405"/>
<area shape="rect" id="node12" href="bmsparsevec__serial_8h.html" title="Serialization for sparse_vector&lt;&gt; " alt="" coords="1761,304,1908,331"/>
<area shape="rect" id="node14" href="svsample02_8cpp.html" title="Example: sparse_vector&lt;&gt; serialization. " alt="" coords="2008,379,2123,405"/>
<area shape="rect" id="node15" href="rscsample01_8cpp.html" title="Example: rsc_sparse_vector&lt;&gt; usage. " alt="" coords="2230,379,2351,405"/>
<area shape="rect" id="node16" href="bmsparsevec__compr_8h.html" title="Compressed sparse container rsc_sparse_vector&lt;&gt; for integer types. " alt="" coords="2284,304,2436,331"/>
<area shape="rect" id="node18" href="svsample01_8cpp.html" title="Example: sparse_vector&lt;&gt; container set values. " alt="" coords="2764,304,2879,331"/>
<area shape="rect" id="node19" href="svsample03_8cpp.html" title="Example: sparse_vector&lt;&gt; merge and fast extraction of content. " alt="" coords="2903,304,3017,331"/>
<area shape="rect" id="node20" href="svsample04_8cpp.html" title="Example: sparse_vector&lt;&gt; with NULL (unset) values. " alt="" coords="3041,304,3156,331"/>
<area shape="rect" id="node9" href="strsvsample02_8cpp.html" title="Example: str_sparse_vector&lt;&gt; insertion sort example. " alt="" coords="2376,379,2507,405"/>
<area shape="rect" id="node13" href="strsvsample03_8cpp.html" title="strsvsample03.cpp" alt="" coords="1811,379,1941,405"/>
<area shape="rect" id="node22" href="strsvsample01_8cpp.html" title="Example: str_sparse_vector&lt;&gt; set values, optimize memory. " alt="" coords="1556,304,1687,331"/>
<area shape="rect" id="node34" href="bmsparsevec__util_8h.html" title="bmsparsevec_util.h" alt="" coords="643,304,776,331"/>
</map>
</div>
</div>
<p><a href="bmfunc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bv__statistics.html">bm::bv_statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with statistical information about bitset's memory allocation details.  <a href="structbm_1_1bv__statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1pair.html">bm::pair&lt; First, Second &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair type.  <a href="structbm_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__decode__cache.html">bm::bit_decode_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit-decode cache structure  <a href="structbm_1_1bit__decode__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1conditional.html">bm::conditional&lt; b &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ad-hoc conditional expressions  <a href="structbm_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1conditional_3_01false_01_4.html">bm::conditional&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1copy__to__array__functor.html">bm::copy_to_array_functor&lt; B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor to copy 1 bits to array.  <a href="classbm_1_1copy__to__array__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1all__set.html">bm::all_set&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure carries pointer on bit block with all bits 1.  <a href="structbm_1_1all__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1all__set_1_1all__set__block.html">bm::all_set&lt; T &gt;::all_set_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1d__copy__func.html">bm::d_copy_func&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">d-Gap copy functor  <a href="structbm_1_1d__copy__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bitblock__get__adapter.html">bm::bitblock_get_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-block get adapter, takes bitblock and represents it as a <a class="el" href="classbm_1_1bitblock__get__adapter.html#a5fd937c34bcb5e5a2f6aa25333480db2">get_32()</a> accessor function.  <a href="classbm_1_1bitblock__get__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bitblock__store__adapter.html">bm::bitblock_store_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-block store adapter, takes bitblock and saves results into it.  <a href="classbm_1_1bitblock__store__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bitblock__sum__adapter.html">bm::bitblock_sum_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-block sum adapter, takes values and sums it /internal.  <a href="classbm_1_1bitblock__sum__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1decoder__range__adapter.html">bm::decoder_range_adapter&lt; DEC &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to get words from a range stream (see range serialized bit-block)  <a href="classbm_1_1decoder__range__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__AND.html">bm::bit_AND&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit AND functor.  <a href="structbm_1_1bit__AND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__OR.html">bm::bit_OR&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit OR functor.  <a href="structbm_1_1bit__OR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__SUB.html">bm::bit_SUB&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit SUB functor.  <a href="structbm_1_1bit__SUB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__XOR.html">bm::bit_XOR&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit XOR functor.  <a href="structbm_1_1bit__XOR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__ASSIGN.html">bm::bit_ASSIGN&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit ASSIGN functor.  <a href="structbm_1_1bit__ASSIGN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT.html">bm::bit_COUNT&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT functor.  <a href="structbm_1_1bit__COUNT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__AND.html">bm::bit_COUNT_AND&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT AND functor.  <a href="structbm_1_1bit__COUNT__AND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__XOR.html">bm::bit_COUNT_XOR&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT XOR functor.  <a href="structbm_1_1bit__COUNT__XOR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__OR.html">bm::bit_COUNT_OR&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT OR functor.  <a href="structbm_1_1bit__COUNT__OR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__SUB__AB.html">bm::bit_COUNT_SUB_AB&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT SUB AB functor.  <a href="structbm_1_1bit__COUNT__SUB__AB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__SUB__BA.html">bm::bit_COUNT_SUB_BA&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit SUB BA functor.  <a href="structbm_1_1bit__COUNT__SUB__BA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__A.html">bm::bit_COUNT_A&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT A functor.  <a href="structbm_1_1bit__COUNT__A.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bit__COUNT__B.html">bm::bit_COUNT_B&lt; W &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit COUNT B functor.  <a href="structbm_1_1bit__COUNT__B.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1operation__functions.html">bm::operation_functions&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionbm_1_1ptr__payload__t.html">bm::ptr_payload_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper union to interpret pointer as integers  <a href="unionbm_1_1ptr__payload__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacebm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html">bm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acadc64f6db9cdf71fcbc98ea4c39fbb8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#acadc64f6db9cdf71fcbc98ea4c39fbb8">bm::gap_operation_to_bitset_func_type</a>) (unsigned *, const gap_word_t *)</td></tr>
<tr class="separator:acadc64f6db9cdf71fcbc98ea4c39fbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fac8ee9bb1b1dc82271d17591ab0e"><td class="memItemLeft" align="right" valign="top">typedef gap_word_t *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a657fac8ee9bb1b1dc82271d17591ab0e">bm::gap_operation_func_type</a>) (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>, gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>, unsigned &amp;)</td></tr>
<tr class="separator:a657fac8ee9bb1b1dc82271d17591ab0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0561326f012871f6c360e50fbab8ee38"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a0561326f012871f6c360e50fbab8ee38">bm::bit_operation_count_func_type</a>) (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a>)</td></tr>
<tr class="separator:a0561326f012871f6c360e50fbab8ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2485f707b2629c5ce7681cf9fe385b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga2485f707b2629c5ce7681cf9fe385b91">bm::bit_block_calc_count_range</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr class="separator:ga2485f707b2629c5ce7681cf9fe385b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503e0f3e79f819d9b58e4b0e905be116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga503e0f3e79f819d9b58e4b0e905be116">bm::bit_block_any_range</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr class="separator:ga503e0f3e79f819d9b58e4b0e905be116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa5c88393f80256cf3b1e3b70bc3609"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadaa5c88393f80256cf3b1e3b70bc3609"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gadaa5c88393f80256cf3b1e3b70bc3609">bm::bit_scan_reverse</a> (T value)</td></tr>
<tr class="separator:gadaa5c88393f80256cf3b1e3b70bc3609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef40342b0c318391df3db2b891acf7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaef40342b0c318391df3db2b891acf7c1">bm::word_bitcount</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w)</td></tr>
<tr class="separator:gaef40342b0c318391df3db2b891acf7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cec2c137813460f4b4c65c5879a4c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a30cec2c137813460f4b4c65c5879a4c3">bm::parallel_popcnt_32</a> (unsigned int n)</td></tr>
<tr class="separator:a30cec2c137813460f4b4c65c5879a4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbaf237ff3186b3494d3b4f15d6a401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga3bbaf237ff3186b3494d3b4f15d6a401">bm::word_bitcount64</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> x)</td></tr>
<tr class="separator:ga3bbaf237ff3186b3494d3b4f15d6a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efdfff1b14ae37b27eafca466ce4bc7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a3efdfff1b14ae37b27eafca466ce4bc7">bm::bitcount64_4way</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> x, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> y, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> u, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> v)</td></tr>
<tr class="separator:a3efdfff1b14ae37b27eafca466ce4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874d5912e681f55b50ac7d19595ade1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ga874d5912e681f55b50ac7d19595ade1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga874d5912e681f55b50ac7d19595ade1c">bm::bit_for_each_4</a> (T w, F &amp;func)</td></tr>
<tr class="memdesc:ga874d5912e681f55b50ac7d19595ade1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated algorithm to unpacks octet based word into list of ON bit indexes.  <a href="group__bitfunc.html#ga874d5912e681f55b50ac7d19595ade1c">More...</a><br /></td></tr>
<tr class="separator:ga874d5912e681f55b50ac7d19595ade1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5fe95b2a2a04788455d38b9d835e03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ga9b5fe95b2a2a04788455d38b9d835e03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga9b5fe95b2a2a04788455d38b9d835e03">bm::bit_for_each</a> (T w, F &amp;func)</td></tr>
<tr class="memdesc:ga9b5fe95b2a2a04788455d38b9d835e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated algorithm to unpacks word into list of ON bit indexes.  <a href="group__bitfunc.html#ga9b5fe95b2a2a04788455d38b9d835e03">More...</a><br /></td></tr>
<tr class="separator:ga9b5fe95b2a2a04788455d38b9d835e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880ecc36db8f2343c86a41ea5a03665d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr class="memitem:ga880ecc36db8f2343c86a41ea5a03665d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga880ecc36db8f2343c86a41ea5a03665d">bm::bit_list</a> (T w, B *bits)</td></tr>
<tr class="memdesc:ga880ecc36db8f2343c86a41ea5a03665d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks word into list of ON bit indexes.  <a href="group__bitfunc.html#ga880ecc36db8f2343c86a41ea5a03665d">More...</a><br /></td></tr>
<tr class="separator:ga880ecc36db8f2343c86a41ea5a03665d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd17b75e0938ff32877b262eda6d43dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr class="memitem:gabd17b75e0938ff32877b262eda6d43dc"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gabd17b75e0938ff32877b262eda6d43dc">bm::bit_list_4</a> (T w, B *bits)</td></tr>
<tr class="memdesc:gabd17b75e0938ff32877b262eda6d43dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks word into list of ON bit indexes (quad-bit based)  <a href="group__bitfunc.html#gabd17b75e0938ff32877b262eda6d43dc">More...</a><br /></td></tr>
<tr class="separator:gabd17b75e0938ff32877b262eda6d43dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad123f7857e5dec4885013acf203fb2bd"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gad123f7857e5dec4885013acf203fb2bd"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad123f7857e5dec4885013acf203fb2bd">bm::bitscan_popcnt</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w, B *bits, unsigned short offs)</td></tr>
<tr class="memdesc:gad123f7857e5dec4885013acf203fb2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks word into list of ON bit indexes using popcnt method.  <a href="group__bitfunc.html#gad123f7857e5dec4885013acf203fb2bd">More...</a><br /></td></tr>
<tr class="separator:gad123f7857e5dec4885013acf203fb2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46102794b6f8e98c7882a8687acf9439"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:ga46102794b6f8e98c7882a8687acf9439"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga46102794b6f8e98c7882a8687acf9439">bm::bitscan_popcnt</a> (<a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w, B *bits)</td></tr>
<tr class="memdesc:ga46102794b6f8e98c7882a8687acf9439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks word into list of ON bit indexes using popcnt method.  <a href="group__bitfunc.html#ga46102794b6f8e98c7882a8687acf9439">More...</a><br /></td></tr>
<tr class="separator:ga46102794b6f8e98c7882a8687acf9439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7615262aa03cb39848faf4fae270d2"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gadf7615262aa03cb39848faf4fae270d2"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gadf7615262aa03cb39848faf4fae270d2">bm::bitscan_popcnt64</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> w, B *bits)</td></tr>
<tr class="memdesc:gadf7615262aa03cb39848faf4fae270d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks 64-bit word into list of ON bit indexes using popcnt method.  <a href="group__bitfunc.html#gadf7615262aa03cb39848faf4fae270d2">More...</a><br /></td></tr>
<tr class="separator:gadf7615262aa03cb39848faf4fae270d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439099897b5b9e544e6a6bb6dcdc4583"><td class="memTemplParams" colspan="2">template&lt;typename V , typename B &gt; </td></tr>
<tr class="memitem:a439099897b5b9e544e6a6bb6dcdc4583"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a439099897b5b9e544e6a6bb6dcdc4583">bm::bitscan</a> (V w, B *bits)</td></tr>
<tr class="separator:a439099897b5b9e544e6a6bb6dcdc4583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd510cd32cbc1dde104672383d8c7192"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#afd510cd32cbc1dde104672383d8c7192">bm::word_select64_linear</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> w, unsigned rank)</td></tr>
<tr class="memdesc:afd510cd32cbc1dde104672383d8c7192"><td class="mdescLeft">&#160;</td><td class="mdescRight">word find index of the rank-th bit set by bit-testing  <a href="namespacebm.html#afd510cd32cbc1dde104672383d8c7192">More...</a><br /></td></tr>
<tr class="separator:afd510cd32cbc1dde104672383d8c7192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac4967703527acbcf4c971f9bb5c74"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a81ac4967703527acbcf4c971f9bb5c74">bm::word_select64_bitscan</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> w, unsigned rank)</td></tr>
<tr class="memdesc:a81ac4967703527acbcf4c971f9bb5c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">word find index of the rank-th bit set by bit-testing  <a href="namespacebm.html#a81ac4967703527acbcf4c971f9bb5c74">More...</a><br /></td></tr>
<tr class="separator:a81ac4967703527acbcf4c971f9bb5c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a386d9161d66f08426496711f7a125"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ab8a386d9161d66f08426496711f7a125">bm::word_select64</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> w, unsigned rank)</td></tr>
<tr class="memdesc:ab8a386d9161d66f08426496711f7a125"><td class="mdescLeft">&#160;</td><td class="mdescRight">word find index of the rank-th bit set by bit-testing  <a href="namespacebm.html#ab8a386d9161d66f08426496711f7a125">More...</a><br /></td></tr>
<tr class="separator:ab8a386d9161d66f08426496711f7a125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8997fca5c1e020f971bf600f59c9a11e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga8997fca5c1e020f971bf600f59c9a11e">bm::widx_to_digest_mask</a> (unsigned w_idx)</td></tr>
<tr class="memdesc:ga8997fca5c1e020f971bf600f59c9a11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute digest mask for word address in block.  <a href="group__bitfunc.html#ga8997fca5c1e020f971bf600f59c9a11e">More...</a><br /></td></tr>
<tr class="separator:ga8997fca5c1e020f971bf600f59c9a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275818d5a5e23cde5ac91c9e53dad85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga275818d5a5e23cde5ac91c9e53dad85b">bm::digest_mask</a> (unsigned from, unsigned to)</td></tr>
<tr class="memdesc:ga275818d5a5e23cde5ac91c9e53dad85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute digest mask for [from..to] positions.  <a href="group__bitfunc.html#ga275818d5a5e23cde5ac91c9e53dad85b">More...</a><br /></td></tr>
<tr class="separator:ga275818d5a5e23cde5ac91c9e53dad85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa300135b60ed8ba3d101c59331563b08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaa300135b60ed8ba3d101c59331563b08">bm::check_zero_digest</a> (<a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest, unsigned bitpos_from, unsigned bitpos_to)</td></tr>
<tr class="memdesc:gaa300135b60ed8ba3d101c59331563b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if all digest bits for the range [from..to] are 0  <a href="group__bitfunc.html#gaa300135b60ed8ba3d101c59331563b08">More...</a><br /></td></tr>
<tr class="separator:gaa300135b60ed8ba3d101c59331563b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eebade7ca0b2a514c09d53f9b1ecd8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga2eebade7ca0b2a514c09d53f9b1ecd8e">bm::block_init_digest0</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga2eebade7ca0b2a514c09d53f9b1ecd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init block with 000111000 pattren based on digest.  <a href="group__bitfunc.html#ga2eebade7ca0b2a514c09d53f9b1ecd8e">More...</a><br /></td></tr>
<tr class="separator:ga2eebade7ca0b2a514c09d53f9b1ecd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc091e9ffbd206bf8ef0f55bd759c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga3bc091e9ffbd206bf8ef0f55bd759c4f">bm::calc_block_digest0</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block)</td></tr>
<tr class="memdesc:ga3bc091e9ffbd206bf8ef0f55bd759c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute digest for 64 non-zero areas.  <a href="group__bitfunc.html#ga3bc091e9ffbd206bf8ef0f55bd759c4f">More...</a><br /></td></tr>
<tr class="separator:ga3bc091e9ffbd206bf8ef0f55bd759c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83daeaae9799d1c9457a48fbfbda09b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga83daeaae9799d1c9457a48fbfbda09b0">bm::update_block_digest0</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga83daeaae9799d1c9457a48fbfbda09b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute digest for 64 non-zero areas based on existing digest (function revalidates zero areas)  <a href="group__bitfunc.html#ga83daeaae9799d1c9457a48fbfbda09b0">More...</a><br /></td></tr>
<tr class="separator:ga83daeaae9799d1c9457a48fbfbda09b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deb310cdf11bca948817f94adfec160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a3deb310cdf11bca948817f94adfec160">bm::is_const_set_operation</a> (set_operation op)</td></tr>
<tr class="memdesc:a3deb310cdf11bca948817f94adfec160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if set operation is constant (bitcount)  <a href="namespacebm.html#a3deb310cdf11bca948817f94adfec160">More...</a><br /></td></tr>
<tr class="separator:a3deb310cdf11bca948817f94adfec160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c192b64adb0590a09b5c2dad77c4b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a7c192b64adb0590a09b5c2dad77c4b76">bm::setop2op</a> (<a class="el" href="group__bvector.html#ga76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a> op)</td></tr>
<tr class="memdesc:a7c192b64adb0590a09b5c2dad77c4b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert set operation to operation.  <a href="namespacebm.html#a7c192b64adb0590a09b5c2dad77c4b76">More...</a><br /></td></tr>
<tr class="separator:a7c192b64adb0590a09b5c2dad77c4b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5363574bed384f42c8e164a9171db08"><td class="memTemplParams" colspan="2">template&lt;typename W &gt; </td></tr>
<tr class="memitem:ad5363574bed384f42c8e164a9171db08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#ad5363574bed384f42c8e164a9171db08">bm::xor_swap</a> (W &amp;x, W &amp;y)</td></tr>
<tr class="memdesc:ad5363574bed384f42c8e164a9171db08"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR swap two scalar variables.  <a href="namespacebm.html#ad5363574bed384f42c8e164a9171db08">More...</a><br /></td></tr>
<tr class="separator:ad5363574bed384f42c8e164a9171db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c54624f9d89bdbb76fa663b22e6dec5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5c54624f9d89bdbb76fa663b22e6dec5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga5c54624f9d89bdbb76fa663b22e6dec5">bm::wordcmp0</a> (T w1, T w2)</td></tr>
<tr class="memdesc:ga5c54624f9d89bdbb76fa663b22e6dec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings (reference) Auxiliary implementation for testing and reference purposes.  <a href="group__bitfunc.html#ga5c54624f9d89bdbb76fa663b22e6dec5">More...</a><br /></td></tr>
<tr class="separator:ga5c54624f9d89bdbb76fa663b22e6dec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b51634b67d65689afd911095aaf9b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae2b51634b67d65689afd911095aaf9b7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gae2b51634b67d65689afd911095aaf9b7">bm::wordcmp</a> (T a, T b)</td></tr>
<tr class="memdesc:gae2b51634b67d65689afd911095aaf9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="group__bitfunc.html#gae2b51634b67d65689afd911095aaf9b7">More...</a><br /></td></tr>
<tr class="separator:gae2b51634b67d65689afd911095aaf9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315998d35cd57cd13aa3ba967eeccba2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga315998d35cd57cd13aa3ba967eeccba2">bm::bit_is_all_zero</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> start)</td></tr>
<tr class="memdesc:ga315998d35cd57cd13aa3ba967eeccba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if all bits in the block are 0.  <a href="group__bitfunc.html#ga315998d35cd57cd13aa3ba967eeccba2">More...</a><br /></td></tr>
<tr class="separator:ga315998d35cd57cd13aa3ba967eeccba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546842afd6d6097e5c11905bcd44ddd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga546842afd6d6097e5c11905bcd44ddd6">bm::gap_is_all_zero</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:ga546842afd6d6097e5c11905bcd44ddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if GAP block is all-zero.  <a href="group__gapfunc.html#ga546842afd6d6097e5c11905bcd44ddd6">More...</a><br /></td></tr>
<tr class="separator:ga546842afd6d6097e5c11905bcd44ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67f48231637a4dacea298a38351e84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab67f48231637a4dacea298a38351e84c">bm::gap_is_all_one</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:gab67f48231637a4dacea298a38351e84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if GAP block is all-one.  <a href="group__gapfunc.html#gab67f48231637a4dacea298a38351e84c">More...</a><br /></td></tr>
<tr class="separator:gab67f48231637a4dacea298a38351e84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5fa3a228bd9d820f96f136663982aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga8b5fa3a228bd9d820f96f136663982aa">bm::gap_length</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *buf)</td></tr>
<tr class="memdesc:ga8b5fa3a228bd9d820f96f136663982aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block length.  <a href="group__gapfunc.html#ga8b5fa3a228bd9d820f96f136663982aa">More...</a><br /></td></tr>
<tr class="separator:ga8b5fa3a228bd9d820f96f136663982aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a34c5aab766103f262b22e1df5a159"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga03a34c5aab766103f262b22e1df5a159"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga03a34c5aab766103f262b22e1df5a159">bm::gap_capacity</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:ga03a34c5aab766103f262b22e1df5a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block capacity.  <a href="group__gapfunc.html#ga03a34c5aab766103f262b22e1df5a159">More...</a><br /></td></tr>
<tr class="separator:ga03a34c5aab766103f262b22e1df5a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae256c20673e9e1beb4a64cec957caa48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae256c20673e9e1beb4a64cec957caa48"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae256c20673e9e1beb4a64cec957caa48">bm::gap_limit</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:gae256c20673e9e1beb4a64cec957caa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP block capacity limit.  <a href="group__gapfunc.html#gae256c20673e9e1beb4a64cec957caa48">More...</a><br /></td></tr>
<tr class="separator:gae256c20673e9e1beb4a64cec957caa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b12b23371696c9509d8421aeb082ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9b12b23371696c9509d8421aeb082ed"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab9b12b23371696c9509d8421aeb082ed">bm::gap_level</a> (const T *buf)</td></tr>
<tr class="memdesc:gab9b12b23371696c9509d8421aeb082ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs GAP blocks capacity level.  <a href="group__gapfunc.html#gab9b12b23371696c9509d8421aeb082ed">More...</a><br /></td></tr>
<tr class="separator:gab9b12b23371696c9509d8421aeb082ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4ed22413b908890186e658ab9992fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaad4ed22413b908890186e658ab9992fa"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaad4ed22413b908890186e658ab9992fa">bm::gap_find_last</a> (const T *buf, unsigned *last)</td></tr>
<tr class="memdesc:gaad4ed22413b908890186e658ab9992fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find the last set bit.  <a href="group__gapfunc.html#gaad4ed22413b908890186e658ab9992fa">More...</a><br /></td></tr>
<tr class="separator:gaad4ed22413b908890186e658ab9992fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0204a8054e2c906df66eae53d4ad1564"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0204a8054e2c906df66eae53d4ad1564"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0204a8054e2c906df66eae53d4ad1564">bm::gap_find_first</a> (const T *buf, unsigned *first)</td></tr>
<tr class="memdesc:ga0204a8054e2c906df66eae53d4ad1564"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find the first set bit.  <a href="group__gapfunc.html#ga0204a8054e2c906df66eae53d4ad1564">More...</a><br /></td></tr>
<tr class="separator:ga0204a8054e2c906df66eae53d4ad1564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1528b231a1d7165fd940a5fbe126cd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1528b231a1d7165fd940a5fbe126cd3"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#ac1528b231a1d7165fd940a5fbe126cd3">bm::gap_bfind</a> (const T *buf, unsigned pos, unsigned *is_set)</td></tr>
<tr class="separator:ac1528b231a1d7165fd940a5fbe126cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8a20a8290d5b37f212bc0bec738357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafb8a20a8290d5b37f212bc0bec738357"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357">bm::gap_test</a> (const T *buf, unsigned pos)</td></tr>
<tr class="memdesc:gafb8a20a8290d5b37f212bc0bec738357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if bit = pos is true.  <a href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357">More...</a><br /></td></tr>
<tr class="separator:gafb8a20a8290d5b37f212bc0bec738357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1c3ea43579816f35ff24fad63b8dc089">bm::gap_test_unr</a> (const T *buf, const unsigned pos)</td></tr>
<tr class="memdesc:ga1c3ea43579816f35ff24fad63b8dc089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if bit = pos is true. Analog of <a class="el" href="group__gapfunc.html#gafb8a20a8290d5b37f212bc0bec738357" title="Tests if bit = pos is true. ">bm::gap_test</a> with SIMD unrolling.  <a href="group__gapfunc.html#ga1c3ea43579816f35ff24fad63b8dc089">More...</a><br /></td></tr>
<tr class="separator:ga1c3ea43579816f35ff24fad63b8dc089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09685ce90a5cb92953ab51e767561d77"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a09685ce90a5cb92953ab51e767561d77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a09685ce90a5cb92953ab51e767561d77">bm::for_each_nzblock</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr class="separator:a09685ce90a5cb92953ab51e767561d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c4cbd9e8c46383fd81e54e24650a42"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a79c4cbd9e8c46383fd81e54e24650a42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a79c4cbd9e8c46383fd81e54e24650a42">bm::for_each_nzblock2</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr class="separator:a79c4cbd9e8c46383fd81e54e24650a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08937253098213e5ee7dc74e7aa796e0"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a08937253098213e5ee7dc74e7aa796e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a08937253098213e5ee7dc74e7aa796e0">bm::for_each_nzblock_if</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr class="separator:a08937253098213e5ee7dc74e7aa796e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86324020a5690137a473e02eb040ec51"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a86324020a5690137a473e02eb040ec51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a86324020a5690137a473e02eb040ec51">bm::for_each_block</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr class="separator:a86324020a5690137a473e02eb040ec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a61e5ac6f06b54a9914b83c81e67d90"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a7a61e5ac6f06b54a9914b83c81e67d90"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a7a61e5ac6f06b54a9914b83c81e67d90">bm::bmfor_each</a> (T first, T last, F f)</td></tr>
<tr class="separator:a7a61e5ac6f06b54a9914b83c81e67d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9746c62e40127ffced6a2c7aae9db"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a80f9746c62e40127ffced6a2c7aae9db"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a80f9746c62e40127ffced6a2c7aae9db">bm::sum_arr</a> (T *first, T *last)</td></tr>
<tr class="separator:a80f9746c62e40127ffced6a2c7aae9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1117cb2e30df357a552fb1082229d76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1117cb2e30df357a552fb1082229d76"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac1117cb2e30df357a552fb1082229d76">bm::gap_bit_count</a> (const T *buf, unsigned dsize=0)</td></tr>
<tr class="memdesc:gac1117cb2e30df357a552fb1082229d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer.  <a href="group__gapfunc.html#gac1117cb2e30df357a552fb1082229d76">More...</a><br /></td></tr>
<tr class="separator:gac1117cb2e30df357a552fb1082229d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e52a07431a2d09c35b8a249b02633b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97e52a07431a2d09c35b8a249b02633b"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga97e52a07431a2d09c35b8a249b02633b">bm::gap_bit_count_unr</a> (const T *buf)</td></tr>
<tr class="memdesc:ga97e52a07431a2d09c35b8a249b02633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer. Loop unrolled version.  <a href="group__gapfunc.html#ga97e52a07431a2d09c35b8a249b02633b">More...</a><br /></td></tr>
<tr class="separator:ga97e52a07431a2d09c35b8a249b02633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae83c2f3d1d54a1814ebf51d14aa19878">bm::gap_bit_count_range</a> (const T *const buf, unsigned left, unsigned right)</td></tr>
<tr class="memdesc:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [left, right] range.  <a href="group__gapfunc.html#gae83c2f3d1d54a1814ebf51d14aa19878">More...</a><br /></td></tr>
<tr class="separator:gae83c2f3d1d54a1814ebf51d14aa19878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b3d2a5089abc09d39d80ae48718965"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga69b3d2a5089abc09d39d80ae48718965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga69b3d2a5089abc09d39d80ae48718965">bm::gap_find_rank</a> (const T *const block, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> rank, unsigned nbit_from, unsigned &amp;nbit_pos)</td></tr>
<tr class="memdesc:ga69b3d2a5089abc09d39d80ae48718965"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block find position for the rank.  <a href="group__gapfunc.html#ga69b3d2a5089abc09d39d80ae48718965">More...</a><br /></td></tr>
<tr class="separator:ga69b3d2a5089abc09d39d80ae48718965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41faacade39b8d62f30216d473ef1fb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga41faacade39b8d62f30216d473ef1fb1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga41faacade39b8d62f30216d473ef1fb1">bm::gap_bit_count_to</a> (const T *const buf, T right)</td></tr>
<tr class="memdesc:ga41faacade39b8d62f30216d473ef1fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [0, right] range.  <a href="group__gapfunc.html#ga41faacade39b8d62f30216d473ef1fb1">More...</a><br /></td></tr>
<tr class="separator:ga41faacade39b8d62f30216d473ef1fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4176fedb0dd0278d8f01b92542e34c15"><td class="memTemplParams" colspan="2">template&lt;class T , class Func &gt; </td></tr>
<tr class="memitem:a4176fedb0dd0278d8f01b92542e34c15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a4176fedb0dd0278d8f01b92542e34c15">bm::for_each_dgap</a> (const T *gap_buf, Func &amp;func)</td></tr>
<tr class="separator:a4176fedb0dd0278d8f01b92542e34c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6625c53e3d8bbca867211c53be5f6dc3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6625c53e3d8bbca867211c53be5f6dc3"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a6625c53e3d8bbca867211c53be5f6dc3">bm::gap_2_dgap</a> (const T *gap_buf, T *dgap_buf, bool copy_head=true)</td></tr>
<tr class="memdesc:a6625c53e3d8bbca867211c53be5f6dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert GAP buffer into D-GAP buffer.  <a href="namespacebm.html#a6625c53e3d8bbca867211c53be5f6dc3">More...</a><br /></td></tr>
<tr class="separator:a6625c53e3d8bbca867211c53be5f6dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1354189bd1dad327da73f8a34cc8f26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1354189bd1dad327da73f8a34cc8f26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#ab1354189bd1dad327da73f8a34cc8f26">bm::dgap_2_gap</a> (const T *dgap_buf, T *gap_buf, T gap_header=0)</td></tr>
<tr class="memdesc:ab1354189bd1dad327da73f8a34cc8f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert D-GAP buffer into GAP buffer.  <a href="namespacebm.html#ab1354189bd1dad327da73f8a34cc8f26">More...</a><br /></td></tr>
<tr class="separator:ab1354189bd1dad327da73f8a34cc8f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga26ab5d91179de63eb74c66ea6e1e4cc4">bm::gapcmp</a> (const T *buf1, const T *buf2)</td></tr>
<tr class="memdesc:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison of GAP buffers.  <a href="group__gapfunc.html#ga26ab5d91179de63eb74c66ea6e1e4cc4">More...</a><br /></td></tr>
<tr class="separator:ga26ab5d91179de63eb74c66ea6e1e4cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a0694d05cd78888b788db69353d721"><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr class="memitem:ae3a0694d05cd78888b788db69353d721"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#ae3a0694d05cd78888b788db69353d721">bm::gap_buff_op</a> (T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, unsigned vect1_mask, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, unsigned vect2_mask, F &amp;f, unsigned &amp;dlen)</td></tr>
<tr class="memdesc:ae3a0694d05cd78888b788db69353d721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract operation for GAP buffers. Receives functor F as a template argument.  <a href="namespacebm.html#ae3a0694d05cd78888b788db69353d721">More...</a><br /></td></tr>
<tr class="separator:ae3a0694d05cd78888b788db69353d721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr class="memitem:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaef97eb2d854ee06d2c2137f7af11982b">bm::gap_buff_any_op</a> (const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, unsigned vect1_mask, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, unsigned vect2_mask, F f)</td></tr>
<tr class="memdesc:gaef97eb2d854ee06d2c2137f7af11982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract distance test operation for GAP buffers. Receives functor F as a template argument.  <a href="group__gapfunc.html#gaef97eb2d854ee06d2c2137f7af11982b">More...</a><br /></td></tr>
<tr class="separator:gaef97eb2d854ee06d2c2137f7af11982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr class="memitem:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga94c46d5dae114fdb2dd758cd80ba5dae">bm::gap_buff_count_op</a> (const T *vect1, const T *vect2, F f)</td></tr>
<tr class="memdesc:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument.  <a href="group__gapfunc.html#ga94c46d5dae114fdb2dd758cd80ba5dae">More...</a><br /></td></tr>
<tr class="separator:ga94c46d5dae114fdb2dd758cd80ba5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59567b7dcd289833d5d09639b23c5c61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga59567b7dcd289833d5d09639b23c5c61"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga59567b7dcd289833d5d09639b23c5c61">bm::gap_set_value</a> (unsigned val, T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> buf, unsigned pos, unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> is_set)</td></tr>
<tr class="memdesc:ga59567b7dcd289833d5d09639b23c5c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears bit in the GAP buffer.  <a href="group__gapfunc.html#ga59567b7dcd289833d5d09639b23c5c61">More...</a><br /></td></tr>
<tr class="separator:ga59567b7dcd289833d5d09639b23c5c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga3e06b8bf018f8160ddda34a41143f8d4">bm::gap_add_value</a> (T *buf, unsigned pos)</td></tr>
<tr class="memdesc:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new value to the end of GAP buffer.  <a href="group__gapfunc.html#ga3e06b8bf018f8160ddda34a41143f8d4">More...</a><br /></td></tr>
<tr class="separator:ga3e06b8bf018f8160ddda34a41143f8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bbec8d06687f311c46d89352276248"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga77bbec8d06687f311c46d89352276248"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga77bbec8d06687f311c46d89352276248">bm::gap_shift_r1</a> (T *buf, unsigned co_flag, unsigned *new_len)</td></tr>
<tr class="memdesc:ga77bbec8d06687f311c46d89352276248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right shift GAP block by 1 bit.  <a href="group__gapfunc.html#ga77bbec8d06687f311c46d89352276248">More...</a><br /></td></tr>
<tr class="separator:ga77bbec8d06687f311c46d89352276248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7062f126291c8ab493cef420205e00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2d7062f126291c8ab493cef420205e00"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga2d7062f126291c8ab493cef420205e00">bm::gap_set_array</a> (T *buf, const T *arr, unsigned len)</td></tr>
<tr class="memdesc:ga2d7062f126291c8ab493cef420205e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert array to GAP buffer.  <a href="group__gapfunc.html#ga2d7062f126291c8ab493cef420205e00">More...</a><br /></td></tr>
<tr class="separator:ga2d7062f126291c8ab493cef420205e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e39e9863fee8647e2db865439464a05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7e39e9863fee8647e2db865439464a05"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7e39e9863fee8647e2db865439464a05">bm::bit_array_compute_gaps</a> (const T *arr, unsigned len)</td></tr>
<tr class="memdesc:ga7e39e9863fee8647e2db865439464a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute number of GAPs in bit-array.  <a href="group__gapfunc.html#ga7e39e9863fee8647e2db865439464a05">More...</a><br /></td></tr>
<tr class="separator:ga7e39e9863fee8647e2db865439464a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac62a37d6cc70a055ebdb86fcd6664b2c">bm::gap_find_in_block</a> (const T *buf, unsigned nbit, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr class="memdesc:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the next 1 bit in the GAP block.  <a href="group__gapfunc.html#gac62a37d6cc70a055ebdb86fcd6664b2c">More...</a><br /></td></tr>
<tr class="separator:gac62a37d6cc70a055ebdb86fcd6664b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2becf9a16ec20ab124ca8938e34b4aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga2becf9a16ec20ab124ca8938e34b4aa8">bm::set_bit</a> (unsigned *dest, unsigned bitpos)</td></tr>
<tr class="memdesc:ga2becf9a16ec20ab124ca8938e34b4aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 1 bit in a block.  <a href="group__bitfunc.html#ga2becf9a16ec20ab124ca8938e34b4aa8">More...</a><br /></td></tr>
<tr class="separator:ga2becf9a16ec20ab124ca8938e34b4aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bccc586aa791f98f1bec284b799102c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga9bccc586aa791f98f1bec284b799102c">bm::test_bit</a> (const unsigned *block, unsigned bitpos)</td></tr>
<tr class="memdesc:ga9bccc586aa791f98f1bec284b799102c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test 1 bit in a block.  <a href="group__bitfunc.html#ga9bccc586aa791f98f1bec284b799102c">More...</a><br /></td></tr>
<tr class="separator:ga9bccc586aa791f98f1bec284b799102c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad698b5242f5b629aa28e7338b7150497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad698b5242f5b629aa28e7338b7150497">bm::or_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr class="memdesc:gad698b5242f5b629aa28e7338b7150497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bits to 1 in the bitblock.  <a href="group__bitfunc.html#gad698b5242f5b629aa28e7338b7150497">More...</a><br /></td></tr>
<tr class="separator:gad698b5242f5b629aa28e7338b7150497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceaa54aa59b16299f5a87b925715e5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaceaa54aa59b16299f5a87b925715e5e8">bm::sub_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr class="memdesc:gaceaa54aa59b16299f5a87b925715e5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUB (AND NOT) bit interval to 1 in the bitblock.  <a href="group__bitfunc.html#gaceaa54aa59b16299f5a87b925715e5e8">More...</a><br /></td></tr>
<tr class="separator:gaceaa54aa59b16299f5a87b925715e5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6191abb017003b633fab24e0c6357521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga6191abb017003b633fab24e0c6357521">bm::xor_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr class="memdesc:ga6191abb017003b633fab24e0c6357521"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR bit interval to 1 in the bitblock.  <a href="group__bitfunc.html#ga6191abb017003b633fab24e0c6357521">More...</a><br /></td></tr>
<tr class="separator:ga6191abb017003b633fab24e0c6357521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1f4e632a6f6135148ec76a3ca10e0a70">bm::gap_sub_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock.  <a href="group__gapfunc.html#ga1f4e632a6f6135148ec76a3ca10e0a70">More...</a><br /></td></tr>
<tr class="separator:ga1f4e632a6f6135148ec76a3ca10e0a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197d8b08506aa4a0589ed306ae134490"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga197d8b08506aa4a0589ed306ae134490"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga197d8b08506aa4a0589ed306ae134490">bm::gap_sub_to_bitset</a> (unsigned *dest, const T *pcurr, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest0)</td></tr>
<tr class="memdesc:ga197d8b08506aa4a0589ed306ae134490"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock with digest assist.  <a href="group__gapfunc.html#ga197d8b08506aa4a0589ed306ae134490">More...</a><br /></td></tr>
<tr class="separator:ga197d8b08506aa4a0589ed306ae134490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga8681f5db8e4c3a1467db41048dba67b1">bm::gap_xor_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga8681f5db8e4c3a1467db41048dba67b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR GAP block to bitblock.  <a href="group__gapfunc.html#ga8681f5db8e4c3a1467db41048dba67b1">More...</a><br /></td></tr>
<tr class="separator:ga8681f5db8e4c3a1467db41048dba67b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0322a5ff3d1b443ab31fcfacbab9168f">bm::gap_add_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="group__gapfunc.html#ga0322a5ff3d1b443ab31fcfacbab9168f">More...</a><br /></td></tr>
<tr class="separator:ga0322a5ff3d1b443ab31fcfacbab9168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1449bce424986cc7b4c4dedb09fbc715">bm::gap_and_to_bitset</a> (unsigned *dest, const T *pcurr)</td></tr>
<tr class="memdesc:ga1449bce424986cc7b4c4dedb09fbc715"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANDs GAP block to bitblock.  <a href="group__gapfunc.html#ga1449bce424986cc7b4c4dedb09fbc715">More...</a><br /></td></tr>
<tr class="separator:ga1449bce424986cc7b4c4dedb09fbc715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9336750a2de2949c29d19f20d87a843"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9336750a2de2949c29d19f20d87a843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab9336750a2de2949c29d19f20d87a843">bm::gap_and_to_bitset</a> (unsigned *dest, const T *pcurr, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest0)</td></tr>
<tr class="memdesc:gab9336750a2de2949c29d19f20d87a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANDs GAP block to bitblock with digest assist.  <a href="group__gapfunc.html#gab9336750a2de2949c29d19f20d87a843">More...</a><br /></td></tr>
<tr class="separator:gab9336750a2de2949c29d19f20d87a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f4b3de019ea33367356bc0910e31a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac7f4b3de019ea33367356bc0910e31a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac7f4b3de019ea33367356bc0910e31a7">bm::gap_bitset_and_count</a> (const unsigned *block, const T *pcurr)</td></tr>
<tr class="memdesc:gac7f4b3de019ea33367356bc0910e31a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block AND masked by GAP block.  <a href="group__gapfunc.html#gac7f4b3de019ea33367356bc0910e31a7">More...</a><br /></td></tr>
<tr class="separator:gac7f4b3de019ea33367356bc0910e31a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0962484f2b2a8ea8a9c2d4de47cbc316">bm::gap_bitset_and_any</a> (const unsigned *block, const T *pcurr)</td></tr>
<tr class="memdesc:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcount test of bit block AND masked by GAP block.  <a href="group__gapfunc.html#ga0962484f2b2a8ea8a9c2d4de47cbc316">More...</a><br /></td></tr>
<tr class="separator:ga0962484f2b2a8ea8a9c2d4de47cbc316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7352f6f48aed8cb7ded4d9a8a7deb6af">bm::gap_bitset_sub_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block SUB masked by GAP block.  <a href="group__gapfunc.html#ga7352f6f48aed8cb7ded4d9a8a7deb6af">More...</a><br /></td></tr>
<tr class="separator:ga7352f6f48aed8cb7ded4d9a8a7deb6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga7ef71ffa5a8fda6ffe3ff2c69fe7f077">bm::gap_bitset_sub_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block SUB masked by GAP block.  <a href="group__gapfunc.html#ga7ef71ffa5a8fda6ffe3ff2c69fe7f077">More...</a><br /></td></tr>
<tr class="separator:ga7ef71ffa5a8fda6ffe3ff2c69fe7f077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4303eb15c00a062e484635737c8f43ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4303eb15c00a062e484635737c8f43ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga4303eb15c00a062e484635737c8f43ed">bm::gap_bitset_xor_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga4303eb15c00a062e484635737c8f43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block XOR masked by GAP block.  <a href="group__gapfunc.html#ga4303eb15c00a062e484635737c8f43ed">More...</a><br /></td></tr>
<tr class="separator:ga4303eb15c00a062e484635737c8f43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac737cc3e97c0787297d54da57902ca29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac737cc3e97c0787297d54da57902ca29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac737cc3e97c0787297d54da57902ca29">bm::gap_bitset_xor_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:gac737cc3e97c0787297d54da57902ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block XOR masked by GAP block.  <a href="group__gapfunc.html#gac737cc3e97c0787297d54da57902ca29">More...</a><br /></td></tr>
<tr class="separator:gac737cc3e97c0787297d54da57902ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac532282d6f0cbb3ae48bc119c55c49b9">bm::gap_bitset_or_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount of bit block OR masked by GAP block.  <a href="group__gapfunc.html#gac532282d6f0cbb3ae48bc119c55c49b9">More...</a><br /></td></tr>
<tr class="separator:gac532282d6f0cbb3ae48bc119c55c49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga48d5ed2e04e67900c364c4561c7787c4">bm::gap_bitset_or_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr class="memdesc:ga48d5ed2e04e67900c364c4561c7787c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bitcount test of bit block OR masked by GAP block.  <a href="group__gapfunc.html#ga48d5ed2e04e67900c364c4561c7787c4">More...</a><br /></td></tr>
<tr class="separator:ga48d5ed2e04e67900c364c4561c7787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada8b13c35acd8df90129b45edcfc5de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaada8b13c35acd8df90129b45edcfc5de">bm::bit_block_set</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)</td></tr>
<tr class="memdesc:gaada8b13c35acd8df90129b45edcfc5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitblock memset operation.  <a href="group__bitfunc.html#gaada8b13c35acd8df90129b45edcfc5de">More...</a><br /></td></tr>
<tr class="separator:gaada8b13c35acd8df90129b45edcfc5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga6f73b66e24322db3d885b9b53d43e75f">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr class="memdesc:ga6f73b66e24322db3d885b9b53d43e75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga6f73b66e24322db3d885b9b53d43e75f">More...</a><br /></td></tr>
<tr class="separator:ga6f73b66e24322db3d885b9b53d43e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4ac4f8a08a46903655eca907b19385"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f4ac4f8a08a46903655eca907b19385"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga0f4ac4f8a08a46903655eca907b19385">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf, unsigned dest_len)</td></tr>
<tr class="memdesc:ga0f4ac4f8a08a46903655eca907b19385"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga0f4ac4f8a08a46903655eca907b19385">More...</a><br /></td></tr>
<tr class="separator:ga0f4ac4f8a08a46903655eca907b19385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memTemplItemLeft" align="right" valign="top">unsigned *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga90dc1e34b98cf061c60f1efc5e3e4bf0">bm::gap_convert_to_bitset_smart</a> (unsigned *dest, const T *buf, id_t set_max)</td></tr>
<tr class="memdesc:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart GAP block to bitblock conversion.  <a href="group__gapfunc.html#ga90dc1e34b98cf061c60f1efc5e3e4bf0">More...</a><br /></td></tr>
<tr class="separator:ga90dc1e34b98cf061c60f1efc5e3e4bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460d8564dd82a511db120e9c01fb529d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga460d8564dd82a511db120e9c01fb529d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga460d8564dd82a511db120e9c01fb529d">bm::gap_control_sum</a> (const T *buf)</td></tr>
<tr class="memdesc:ga460d8564dd82a511db120e9c01fb529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates sum of all words in GAP block. (For debugging purposes)  <a href="group__gapfunc.html#ga460d8564dd82a511db120e9c01fb529d">More...</a><br /></td></tr>
<tr class="separator:ga460d8564dd82a511db120e9c01fb529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa4547663f2ac44e1dab9d94cd866b0ca">bm::gap_set_all</a> (T *buf, unsigned set_max, unsigned value)</td></tr>
<tr class="memdesc:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits to 0 or 1 (GAP)  <a href="group__gapfunc.html#gaa4547663f2ac44e1dab9d94cd866b0ca">More...</a><br /></td></tr>
<tr class="separator:gaa4547663f2ac44e1dab9d94cd866b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9126461f19bfe024093c4c5fd816c083"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9126461f19bfe024093c4c5fd816c083"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga9126461f19bfe024093c4c5fd816c083">bm::gap_init_range_block</a> (T *buf, T from, T to, T value)</td></tr>
<tr class="memdesc:ga9126461f19bfe024093c4c5fd816c083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init gap block so it has block in it (can be whole block)  <a href="group__gapfunc.html#ga9126461f19bfe024093c4c5fd816c083">More...</a><br /></td></tr>
<tr class="separator:ga9126461f19bfe024093c4c5fd816c083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba1509608fe39847b88c062128fff99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ba1509608fe39847b88c062128fff99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1ba1509608fe39847b88c062128fff99">bm::gap_invert</a> (T *buf)</td></tr>
<tr class="memdesc:ga1ba1509608fe39847b88c062128fff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts all bits in the GAP buffer.  <a href="group__gapfunc.html#ga1ba1509608fe39847b88c062128fff99">More...</a><br /></td></tr>
<tr class="separator:ga1ba1509608fe39847b88c062128fff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a026368549e02e8af9b6c290536c2fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9a026368549e02e8af9b6c290536c2fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga9a026368549e02e8af9b6c290536c2fc">bm::set_gap_level</a> (T *buf, int level)</td></tr>
<tr class="memdesc:ga9a026368549e02e8af9b6c290536c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GAP block capacity level.  <a href="group__gapfunc.html#ga9a026368549e02e8af9b6c290536c2fc">More...</a><br /></td></tr>
<tr class="separator:ga9a026368549e02e8af9b6c290536c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga973ee6ac889acaa5a1cb61595b15793a">bm::gap_calc_level</a> (unsigned len, const T *glevel_len)</td></tr>
<tr class="memdesc:ga973ee6ac889acaa5a1cb61595b15793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates GAP block capacity level.  <a href="group__gapfunc.html#ga973ee6ac889acaa5a1cb61595b15793a">More...</a><br /></td></tr>
<tr class="separator:ga973ee6ac889acaa5a1cb61595b15793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga97b1fcf40d8fdccfccd2083d654a6436">bm::gap_free_elements</a> (const T *buf, const T *glevel_len)</td></tr>
<tr class="memdesc:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length.  <a href="group__gapfunc.html#ga97b1fcf40d8fdccfccd2083d654a6436">More...</a><br /></td></tr>
<tr class="separator:ga97b1fcf40d8fdccfccd2083d654a6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef00ac428d2059ee81d5c5009de6adf8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef00ac428d2059ee81d5c5009de6adf8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaef00ac428d2059ee81d5c5009de6adf8">bm::bitcmp</a> (const T *buf1, const T *buf2, unsigned len)</td></tr>
<tr class="memdesc:gaef00ac428d2059ee81d5c5009de6adf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison of BIT buffers.  <a href="group__bitfunc.html#gaef00ac428d2059ee81d5c5009de6adf8">More...</a><br /></td></tr>
<tr class="separator:gaef00ac428d2059ee81d5c5009de6adf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa2064b36ab5c3176e023cf3478e3ee04">bm::bit_block_to_gap</a> (gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, unsigned dest_len)</td></tr>
<tr class="memdesc:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts bit block to GAP.  <a href="group__gapfunc.html#gaa2064b36ab5c3176e023cf3478e3ee04">More...</a><br /></td></tr>
<tr class="separator:gaa2064b36ab5c3176e023cf3478e3ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e21e72e3b5985f00dfeacd903bc7ae4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a7e21e72e3b5985f00dfeacd903bc7ae4">bm::bit_to_gap</a> (gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, unsigned dest_len)</td></tr>
<tr class="separator:a7e21e72e3b5985f00dfeacd903bc7ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga5614d83505b04921c1e89d077ae3d3c7">bm::for_each_gap_dbit</a> (const T *buf, F &amp;func)</td></tr>
<tr class="memdesc:ga5614d83505b04921c1e89d077ae3d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate gap block as delta-bits with a functor.  <a href="group__gapfunc.html#ga5614d83505b04921c1e89d077ae3d3c7">More...</a><br /></td></tr>
<tr class="separator:ga5614d83505b04921c1e89d077ae3d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3aa03295329ef84f8e25b1da19d6794"><td class="memTemplParams" colspan="2">template&lt;typename D , typename T &gt; </td></tr>
<tr class="memitem:gab3aa03295329ef84f8e25b1da19d6794"><td class="memTemplItemLeft" align="right" valign="top">D&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab3aa03295329ef84f8e25b1da19d6794">bm::gap_convert_to_arr</a> (D *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> buf, unsigned dest_len, bool invert=false)</td></tr>
<tr class="memdesc:gab3aa03295329ef84f8e25b1da19d6794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert gap block into array of ints corresponding to 1 bits.  <a href="group__gapfunc.html#gab3aa03295329ef84f8e25b1da19d6794">More...</a><br /></td></tr>
<tr class="separator:gab3aa03295329ef84f8e25b1da19d6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c50a8c6cf8e0cc47daefd75f3c1953d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga8c50a8c6cf8e0cc47daefd75f3c1953d">bm::bit_block_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block)</td></tr>
<tr class="memdesc:ga8c50a8c6cf8e0cc47daefd75f3c1953d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcount for bit block.  <a href="group__bitfunc.html#ga8c50a8c6cf8e0cc47daefd75f3c1953d">More...</a><br /></td></tr>
<tr class="separator:ga8c50a8c6cf8e0cc47daefd75f3c1953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcb8a07f167c82d7108f7351470fa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaddcb8a07f167c82d7108f7351470fa95">bm::bit_block_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:gaddcb8a07f167c82d7108f7351470fa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcount for bit block.  <a href="group__bitfunc.html#gaddcb8a07f167c82d7108f7351470fa95">More...</a><br /></td></tr>
<tr class="separator:gaddcb8a07f167c82d7108f7351470fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30df14a61f036d690c091878feaff1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gab30df14a61f036d690c091878feaff1c">bm::bit_block_calc_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end)</td></tr>
<tr class="memdesc:gab30df14a61f036d690c091878feaff1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcount for bit string.  <a href="group__bitfunc.html#gab30df14a61f036d690c091878feaff1c">More...</a><br /></td></tr>
<tr class="separator:gab30df14a61f036d690c091878feaff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc87c4764bb30d95ba4088064a404e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaafc87c4764bb30d95ba4088064a404e3">bm::bit_count_change</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w)</td></tr>
<tr class="separator:gaafc87c4764bb30d95ba4088064a404e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa511f786e7377533479d44d7e39d5ca8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#aa511f786e7377533479d44d7e39d5ca8">bm::bit_block_change32</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block)</td></tr>
<tr class="separator:aa511f786e7377533479d44d7e39d5ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6faecac8596f0cd2b18e6896435306b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad6faecac8596f0cd2b18e6896435306b">bm::bit_block_calc_change</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block)</td></tr>
<tr class="separator:gad6faecac8596f0cd2b18e6896435306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27dcfff2918d6e35bf31ab2d3165cd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga27dcfff2918d6e35bf31ab2d3165cd29">bm::bit_block_calc_count_to</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr class="separator:ga27dcfff2918d6e35bf31ab2d3165cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6427df235718ae7ce814dcb31eabdc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga6427df235718ae7ce814dcb31eabdc71">bm::bit_block_rotate_left_1</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block)</td></tr>
<tr class="separator:ga6427df235718ae7ce814dcb31eabdc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c43e6ac136b28cabd101a2fec6937d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga98c43e6ac136b28cabd101a2fec6937d">bm::bit_block_rotate_left_1_unr</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block)</td></tr>
<tr class="memdesc:ga98c43e6ac136b28cabd101a2fec6937d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolled cyclic rotation of bit-block left by 1 bit.  <a href="group__bitfunc.html#ga98c43e6ac136b28cabd101a2fec6937d">More...</a><br /></td></tr>
<tr class="separator:ga98c43e6ac136b28cabd101a2fec6937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98120d74736b1635193b3ffa6f7688a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga98120d74736b1635193b3ffa6f7688a0">bm::bit_block_insert</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, unsigned bitpos, bool value)</td></tr>
<tr class="memdesc:ga98120d74736b1635193b3ffa6f7688a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert bit into position and shift the rest right with carryover  <a href="group__bitfunc.html#ga98120d74736b1635193b3ffa6f7688a0">More...</a><br /></td></tr>
<tr class="separator:ga98120d74736b1635193b3ffa6f7688a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cd8f3d2651f3df908939744a04f255"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga29cd8f3d2651f3df908939744a04f255">bm::bit_block_shift_r1</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *empty_acc, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> co_flag)</td></tr>
<tr class="memdesc:ga29cd8f3d2651f3df908939744a04f255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right bit-shift bitblock by 1 bit (reference)  <a href="group__bitfunc.html#ga29cd8f3d2651f3df908939744a04f255">More...</a><br /></td></tr>
<tr class="separator:ga29cd8f3d2651f3df908939744a04f255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547ba1e5b611480c3ca61da97f17b598"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga547ba1e5b611480c3ca61da97f17b598">bm::bit_block_shift_r1_unr</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *empty_acc, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> co_flag)</td></tr>
<tr class="memdesc:ga547ba1e5b611480c3ca61da97f17b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right bit-shift of bit-block by 1 bit (loop unrolled)  <a href="group__bitfunc.html#ga547ba1e5b611480c3ca61da97f17b598">More...</a><br /></td></tr>
<tr class="separator:ga547ba1e5b611480c3ca61da97f17b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47856372cc4848bf1fd49f9992ad23b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaf47856372cc4848bf1fd49f9992ad23b">bm::bit_block_shift_r1_and</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> co_flag, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> mask_block, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> digest)</td></tr>
<tr class="memdesc:gaf47856372cc4848bf1fd49f9992ad23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right bit-shift of bit-block by 1 bit (reference) + AND.  <a href="group__bitfunc.html#gaf47856372cc4848bf1fd49f9992ad23b">More...</a><br /></td></tr>
<tr class="separator:gaf47856372cc4848bf1fd49f9992ad23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437c46c457300daf725c899ffcd64bc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga437c46c457300daf725c899ffcd64bc1">bm::bit_block_shift_r1_and_unr</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> co_flag, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> mask_block, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> digest)</td></tr>
<tr class="memdesc:ga437c46c457300daf725c899ffcd64bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right bit-shift bitblock by 1 bit (reference) + AND.  <a href="group__bitfunc.html#ga437c46c457300daf725c899ffcd64bc1">More...</a><br /></td></tr>
<tr class="separator:ga437c46c457300daf725c899ffcd64bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a8714bc087bc91794a2e86fd98c128"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad1a8714bc087bc91794a2e86fd98c128"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad1a8714bc087bc91794a2e86fd98c128">bm::bit_invert</a> (T *start)</td></tr>
<tr class="separator:gad1a8714bc087bc91794a2e86fd98c128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8beb7b314288f0fe2f620f1ea786da3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad8beb7b314288f0fe2f620f1ea786da3">bm::is_bits_one</a> (const <a class="el" href="namespacebm.html#aee4bc8730c4b53977ccc8ac18be42784">bm::wordop_t</a> *start)</td></tr>
<tr class="memdesc:gad8beb7b314288f0fe2f620f1ea786da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if all bits in the block are 1.  <a href="group__bitfunc.html#gad8beb7b314288f0fe2f620f1ea786da3">More...</a><br /></td></tr>
<tr class="separator:gad8beb7b314288f0fe2f620f1ea786da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d943cf66c4592e2baddf5bc0667adbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a8d943cf66c4592e2baddf5bc0667adbd">bm::and_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr class="memdesc:a8d943cf66c4592e2baddf5bc0667adbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP and functor.  <a href="namespacebm.html#a8d943cf66c4592e2baddf5bc0667adbd">More...</a><br /></td></tr>
<tr class="separator:a8d943cf66c4592e2baddf5bc0667adbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7085de3103a42f81c0d3d82903cd5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a6e7085de3103a42f81c0d3d82903cd5f">bm::xor_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr class="memdesc:a6e7085de3103a42f81c0d3d82903cd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP xor functor.  <a href="namespacebm.html#a6e7085de3103a42f81c0d3d82903cd5f">More...</a><br /></td></tr>
<tr class="separator:a6e7085de3103a42f81c0d3d82903cd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330d13a0846ca89ff6fc6927e675a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ac330d13a0846ca89ff6fc6927e675a93">bm::or_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr class="memdesc:ac330d13a0846ca89ff6fc6927e675a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP or functor.  <a href="namespacebm.html#ac330d13a0846ca89ff6fc6927e675a93">More...</a><br /></td></tr>
<tr class="separator:ac330d13a0846ca89ff6fc6927e675a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c5866395bfb88b68913b32539a2b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a35c5866395bfb88b68913b32539a2b96">bm::sub_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr class="memdesc:a35c5866395bfb88b68913b32539a2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP or functor.  <a href="namespacebm.html#a35c5866395bfb88b68913b32539a2b96">More...</a><br /></td></tr>
<tr class="separator:a35c5866395bfb88b68913b32539a2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18d7da0492983802511999a4ad0764a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> gap_word_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gac18d7da0492983802511999a4ad0764a">bm::gap_operation_and</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gac18d7da0492983802511999a4ad0764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP AND operation.  <a href="group__gapfunc.html#gac18d7da0492983802511999a4ad0764a">More...</a><br /></td></tr>
<tr class="separator:gac18d7da0492983802511999a4ad0764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e0312d3ab0551e883176b170c0a3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga58e0312d3ab0551e883176b170c0a3e8">bm::gap_operation_any_and</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga58e0312d3ab0551e883176b170c0a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP AND operation test.  <a href="group__gapfunc.html#ga58e0312d3ab0551e883176b170c0a3e8">More...</a><br /></td></tr>
<tr class="separator:ga58e0312d3ab0551e883176b170c0a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92d013b0c377604831f401ef6917b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gafd92d013b0c377604831f401ef6917b8">bm::gap_count_and</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gafd92d013b0c377604831f401ef6917b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount AND operation test.  <a href="group__gapfunc.html#gafd92d013b0c377604831f401ef6917b8">More...</a><br /></td></tr>
<tr class="separator:gafd92d013b0c377604831f401ef6917b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> gap_word_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga72d2d3933b4410413eeb02e9ee0a910d">bm::gap_operation_xor</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP XOR operation.  <a href="group__gapfunc.html#ga72d2d3933b4410413eeb02e9ee0a910d">More...</a><br /></td></tr>
<tr class="separator:ga72d2d3933b4410413eeb02e9ee0a910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8800dff60eb05404a83159035e8e72f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gab8800dff60eb05404a83159035e8e72f">bm::gap_operation_any_xor</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gab8800dff60eb05404a83159035e8e72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP XOR operation test.  <a href="group__gapfunc.html#gab8800dff60eb05404a83159035e8e72f">More...</a><br /></td></tr>
<tr class="separator:gab8800dff60eb05404a83159035e8e72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38d6a3296f0562be512f47b4edfb1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gae38d6a3296f0562be512f47b4edfb1ad">bm::gap_count_xor</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gae38d6a3296f0562be512f47b4edfb1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount XOR operation test.  <a href="group__gapfunc.html#gae38d6a3296f0562be512f47b4edfb1ad">More...</a><br /></td></tr>
<tr class="separator:gae38d6a3296f0562be512f47b4edfb1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda280af8910ae5fde37731a3a7a1226"><td class="memItemLeft" align="right" valign="top">gap_word_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gacda280af8910ae5fde37731a3a7a1226">bm::gap_operation_or</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gacda280af8910ae5fde37731a3a7a1226"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP OR operation.  <a href="group__gapfunc.html#gacda280af8910ae5fde37731a3a7a1226">More...</a><br /></td></tr>
<tr class="separator:gacda280af8910ae5fde37731a3a7a1226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125fc8dc68245a11a171e7793c6588a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga125fc8dc68245a11a171e7793c6588a2">bm::gap_count_or</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga125fc8dc68245a11a171e7793c6588a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount OR operation test.  <a href="group__gapfunc.html#ga125fc8dc68245a11a171e7793c6588a2">More...</a><br /></td></tr>
<tr class="separator:ga125fc8dc68245a11a171e7793c6588a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="memItemLeft" align="right" valign="top">gap_word_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gabe4c83e5e162c38e297116dd1cd05ac4">bm::gap_operation_sub</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2, gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> tmp_buf, unsigned &amp;dsize)</td></tr>
<tr class="memdesc:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP SUB (AND NOT) operation.  <a href="group__gapfunc.html#gabe4c83e5e162c38e297116dd1cd05ac4">More...</a><br /></td></tr>
<tr class="separator:gabe4c83e5e162c38e297116dd1cd05ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9b33d00f74206ad655dc2cef52428b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga1c9b33d00f74206ad655dc2cef52428b">bm::gap_operation_any_sub</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:ga1c9b33d00f74206ad655dc2cef52428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP SUB operation test.  <a href="group__gapfunc.html#ga1c9b33d00f74206ad655dc2cef52428b">More...</a><br /></td></tr>
<tr class="separator:ga1c9b33d00f74206ad655dc2cef52428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacf55c60da82a1c384f3ac3a51229d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bmdef_8h.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gacacf55c60da82a1c384f3ac3a51229d4">bm::gap_count_sub</a> (const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect1, const gap_word_t *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> vect2)</td></tr>
<tr class="memdesc:gacacf55c60da82a1c384f3ac3a51229d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAP bitcount SUB (AND NOT) operation test.  <a href="group__gapfunc.html#gacacf55c60da82a1c384f3ac3a51229d4">More...</a><br /></td></tr>
<tr class="separator:gacacf55c60da82a1c384f3ac3a51229d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9090de87d53e7f25eff96c8259b3485c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga9090de87d53e7f25eff96c8259b3485c">bm::bit_block_copy</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga9090de87d53e7f25eff96c8259b3485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitblock copy operation.  <a href="group__bitfunc.html#ga9090de87d53e7f25eff96c8259b3485c">More...</a><br /></td></tr>
<tr class="separator:ga9090de87d53e7f25eff96c8259b3485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ffd5891ae6d3ad112fba143e071ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga84ffd5891ae6d3ad112fba143e071ea0">bm::bit_block_stream</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga84ffd5891ae6d3ad112fba143e071ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitblock copy/stream operation.  <a href="group__bitfunc.html#ga84ffd5891ae6d3ad112fba143e071ea0">More...</a><br /></td></tr>
<tr class="separator:ga84ffd5891ae6d3ad112fba143e071ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd04ace53feb4c697df5cb7110fef702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gadd04ace53feb4c697df5cb7110fef702">bm::bit_block_and</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:gadd04ace53feb4c697df5cb7110fef702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain bitblock AND operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#gadd04ace53feb4c697df5cb7110fef702">More...</a><br /></td></tr>
<tr class="separator:gadd04ace53feb4c697df5cb7110fef702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f2fd28a0493d5c1334af291ba912ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad3f2fd28a0493d5c1334af291ba912ce">bm::bit_block_and</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:gad3f2fd28a0493d5c1334af291ba912ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">digest based bit-block AND  <a href="group__bitfunc.html#gad3f2fd28a0493d5c1334af291ba912ce">More...</a><br /></td></tr>
<tr class="separator:gad3f2fd28a0493d5c1334af291ba912ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e8cf5c2d1666242de3672af2d15eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga65e8cf5c2d1666242de3672af2d15eab">bm::bit_block_and_5way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src0, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src3, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga65e8cf5c2d1666242de3672af2d15eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">digest based bit-block AND 5-way  <a href="group__bitfunc.html#ga65e8cf5c2d1666242de3672af2d15eab">More...</a><br /></td></tr>
<tr class="separator:ga65e8cf5c2d1666242de3672af2d15eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a47387dc6e849c0b68a76abdfabe43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga5a47387dc6e849c0b68a76abdfabe43a">bm::bit_block_and_2way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga5a47387dc6e849c0b68a76abdfabe43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">digest based bit-block AND  <a href="group__bitfunc.html#ga5a47387dc6e849c0b68a76abdfabe43a">More...</a><br /></td></tr>
<tr class="separator:ga5a47387dc6e849c0b68a76abdfabe43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f92f324105dd609c203f5e32f6e542"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaf5f92f324105dd609c203f5e32f6e542">bm::bit_block_and_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gaf5f92f324105dd609c203f5e32f6e542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function ANDs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#gaf5f92f324105dd609c203f5e32f6e542">More...</a><br /></td></tr>
<tr class="separator:gaf5f92f324105dd609c203f5e32f6e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ba1d88b1aa4d69b8302a21f90bfd25"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga46ba1d88b1aa4d69b8302a21f90bfd25">bm::bit_block_and_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr class="memdesc:ga46ba1d88b1aa4d69b8302a21f90bfd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function ANDs two bitblocks and tests for any bit. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#ga46ba1d88b1aa4d69b8302a21f90bfd25">More...</a><br /></td></tr>
<tr class="separator:ga46ba1d88b1aa4d69b8302a21f90bfd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4f11036e4fddb6ba6a81eeb948c293"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga4e4f11036e4fddb6ba6a81eeb948c293">bm::bit_block_xor_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga4e4f11036e4fddb6ba6a81eeb948c293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function XORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#ga4e4f11036e4fddb6ba6a81eeb948c293">More...</a><br /></td></tr>
<tr class="separator:ga4e4f11036e4fddb6ba6a81eeb948c293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3abaf84d879afd5eccc1d1b2764c04f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad3abaf84d879afd5eccc1d1b2764c04f">bm::bit_block_xor_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gad3abaf84d879afd5eccc1d1b2764c04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function XORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#gad3abaf84d879afd5eccc1d1b2764c04f">More...</a><br /></td></tr>
<tr class="separator:gad3abaf84d879afd5eccc1d1b2764c04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df50c9e039ec7f546b375f1d91171c7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga4df50c9e039ec7f546b375f1d91171c7">bm::bit_block_sub_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga4df50c9e039ec7f546b375f1d91171c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function SUBs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#ga4df50c9e039ec7f546b375f1d91171c7">More...</a><br /></td></tr>
<tr class="separator:ga4df50c9e039ec7f546b375f1d91171c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22caa703e427b1a2c8fdd6b49c343d1f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga22caa703e427b1a2c8fdd6b49c343d1f">bm::bit_block_sub_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga22caa703e427b1a2c8fdd6b49c343d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function SUBs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#ga22caa703e427b1a2c8fdd6b49c343d1f">More...</a><br /></td></tr>
<tr class="separator:ga22caa703e427b1a2c8fdd6b49c343d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa2d0e3e71b4dd7ec2ee2ce35711e70"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gacfa2d0e3e71b4dd7ec2ee2ce35711e70">bm::bit_block_or_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr class="memdesc:gacfa2d0e3e71b4dd7ec2ee2ce35711e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function ORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#gacfa2d0e3e71b4dd7ec2ee2ce35711e70">More...</a><br /></td></tr>
<tr class="separator:gacfa2d0e3e71b4dd7ec2ee2ce35711e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1863c8565098c67fa70e62f4deada4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gace1863c8565098c67fa70e62f4deada4">bm::bit_block_or_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gace1863c8565098c67fa70e62f4deada4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function ORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="group__bitfunc.html#gace1863c8565098c67fa70e62f4deada4">More...</a><br /></td></tr>
<tr class="separator:gace1863c8565098c67fa70e62f4deada4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869fce5348076d4c7b92adcc2f1a49ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga869fce5348076d4c7b92adcc2f1a49ab">bm::bit_operation_and</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga869fce5348076d4c7b92adcc2f1a49ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitblock AND operation.  <a href="group__bitfunc.html#ga869fce5348076d4c7b92adcc2f1a49ab">More...</a><br /></td></tr>
<tr class="separator:ga869fce5348076d4c7b92adcc2f1a49ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e7d56a6bf38d1ab0ca69f609dec8ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga45e7d56a6bf38d1ab0ca69f609dec8ab">bm::bit_operation_and_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga45e7d56a6bf38d1ab0ca69f609dec8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock AND operation and calculates bitcount of the result.  <a href="group__bitfunc.html#ga45e7d56a6bf38d1ab0ca69f609dec8ab">More...</a><br /></td></tr>
<tr class="separator:ga45e7d56a6bf38d1ab0ca69f609dec8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c69c3a40533bcf4afa2ab6b95ccec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga68c69c3a40533bcf4afa2ab6b95ccec2">bm::bit_operation_and_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga68c69c3a40533bcf4afa2ab6b95ccec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock AND operation test.  <a href="group__bitfunc.html#ga68c69c3a40533bcf4afa2ab6b95ccec2">More...</a><br /></td></tr>
<tr class="separator:ga68c69c3a40533bcf4afa2ab6b95ccec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f15526a2bc34eddc187d629ad52d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga85f15526a2bc34eddc187d629ad52d94">bm::bit_operation_sub_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga85f15526a2bc34eddc187d629ad52d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock SUB operation and calculates bitcount of the result.  <a href="group__bitfunc.html#ga85f15526a2bc34eddc187d629ad52d94">More...</a><br /></td></tr>
<tr class="separator:ga85f15526a2bc34eddc187d629ad52d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d095002a7a9444b5c433f8061b328b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga19d095002a7a9444b5c433f8061b328b">bm::bit_operation_sub_count_inv</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga19d095002a7a9444b5c433f8061b328b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverted bitblock SUB operation and calculates bitcount of the result.  <a href="group__bitfunc.html#ga19d095002a7a9444b5c433f8061b328b">More...</a><br /></td></tr>
<tr class="separator:ga19d095002a7a9444b5c433f8061b328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dc5b0ac052003a3dbe032cd618c297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad1dc5b0ac052003a3dbe032cd618c297">bm::bit_operation_sub_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gad1dc5b0ac052003a3dbe032cd618c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock test of SUB operation.  <a href="group__bitfunc.html#gad1dc5b0ac052003a3dbe032cd618c297">More...</a><br /></td></tr>
<tr class="separator:gad1dc5b0ac052003a3dbe032cd618c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531051e85013087c50af3d3b74c8f456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga531051e85013087c50af3d3b74c8f456">bm::bit_operation_or_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga531051e85013087c50af3d3b74c8f456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock OR operation and calculates bitcount of the result.  <a href="group__bitfunc.html#ga531051e85013087c50af3d3b74c8f456">More...</a><br /></td></tr>
<tr class="separator:ga531051e85013087c50af3d3b74c8f456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8944d38ec3dd87dec2b96cee6257feac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga8944d38ec3dd87dec2b96cee6257feac">bm::bit_operation_or_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga8944d38ec3dd87dec2b96cee6257feac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock OR operation test.  <a href="group__bitfunc.html#ga8944d38ec3dd87dec2b96cee6257feac">More...</a><br /></td></tr>
<tr class="separator:ga8944d38ec3dd87dec2b96cee6257feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6565eb392d1d058f45666344b121b9a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga6565eb392d1d058f45666344b121b9a6">bm::bit_block_or</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga6565eb392d1d058f45666344b121b9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#ga6565eb392d1d058f45666344b121b9a6">More...</a><br /></td></tr>
<tr class="separator:ga6565eb392d1d058f45666344b121b9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba56b86a121a209ae0d58d9f4e21e64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gafba56b86a121a209ae0d58d9f4e21e64">bm::bit_block_or_2way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gafba56b86a121a209ae0d58d9f4e21e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 way (target := source1 | source2) bitblock OR operation.  <a href="group__bitfunc.html#gafba56b86a121a209ae0d58d9f4e21e64">More...</a><br /></td></tr>
<tr class="separator:gafba56b86a121a209ae0d58d9f4e21e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37cbd57b308980f03c37487bd542525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gae37cbd57b308980f03c37487bd542525">bm::bit_block_xor_2way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gae37cbd57b308980f03c37487bd542525"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 way (target := source1 ^ source2) bitblock XOR operation.  <a href="group__bitfunc.html#gae37cbd57b308980f03c37487bd542525">More...</a><br /></td></tr>
<tr class="separator:gae37cbd57b308980f03c37487bd542525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a30ce264815f038d20ecd859574060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaa6a30ce264815f038d20ecd859574060">bm::bit_block_or_3way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gaa6a30ce264815f038d20ecd859574060"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 way (target | source1 | source2) bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#gaa6a30ce264815f038d20ecd859574060">More...</a><br /></td></tr>
<tr class="separator:gaa6a30ce264815f038d20ecd859574060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ede4bfdfaff50893edfa0b2dc07d9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga10ede4bfdfaff50893edfa0b2dc07d9f">bm::bit_block_or_5way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src3, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src4)</td></tr>
<tr class="memdesc:ga10ede4bfdfaff50893edfa0b2dc07d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">5 way (target, source1, source2) bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#ga10ede4bfdfaff50893edfa0b2dc07d9f">More...</a><br /></td></tr>
<tr class="separator:ga10ede4bfdfaff50893edfa0b2dc07d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e945a9eaae699ad40f63b3f0632e6f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga0e945a9eaae699ad40f63b3f0632e6f9">bm::bit_operation_or</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga0e945a9eaae699ad40f63b3f0632e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block OR operation. Makes analysis if block is 0 or FULL.  <a href="group__bitfunc.html#ga0e945a9eaae699ad40f63b3f0632e6f9">More...</a><br /></td></tr>
<tr class="separator:ga0e945a9eaae699ad40f63b3f0632e6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd3553c1dff6fb078b0bccba8fded5ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gadd3553c1dff6fb078b0bccba8fded5ce">bm::bit_block_sub</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:gadd3553c1dff6fb078b0bccba8fded5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#gadd3553c1dff6fb078b0bccba8fded5ce">More...</a><br /></td></tr>
<tr class="separator:gadd3553c1dff6fb078b0bccba8fded5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967067183f72f04521336e6fc360a446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga967067183f72f04521336e6fc360a446">bm::bit_block_sub</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga967067183f72f04521336e6fc360a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">digest based bitblock SUB (AND NOT) operation  <a href="group__bitfunc.html#ga967067183f72f04521336e6fc360a446">More...</a><br /></td></tr>
<tr class="separator:ga967067183f72f04521336e6fc360a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72798b9d138753d42a7db13b81342ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga72798b9d138753d42a7db13b81342ff0">bm::bit_block_sub_2way</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga72798b9d138753d42a7db13b81342ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">digest based bitblock SUB (AND NOT) operation (3 operand)  <a href="group__bitfunc.html#ga72798b9d138753d42a7db13b81342ff0">More...</a><br /></td></tr>
<tr class="separator:ga72798b9d138753d42a7db13b81342ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7afa9bce28a376360ca4826960d669f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad7afa9bce28a376360ca4826960d669f">bm::bit_operation_sub</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:gad7afa9bce28a376360ca4826960d669f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitblock SUB operation.  <a href="group__bitfunc.html#gad7afa9bce28a376360ca4826960d669f">More...</a><br /></td></tr>
<tr class="separator:gad7afa9bce28a376360ca4826960d669f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b29e46698b0d48a9786419e116b5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gab5b29e46698b0d48a9786419e116b5b0">bm::bit_block_xor</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:gab5b29e46698b0d48a9786419e116b5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain bitblock XOR operation. Function does not analyse availability of source and destination blocks.  <a href="group__bitfunc.html#gab5b29e46698b0d48a9786419e116b5b0">More...</a><br /></td></tr>
<tr class="separator:gab5b29e46698b0d48a9786419e116b5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4478e86267ae5b2685f6c8f3f76ac6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga4478e86267ae5b2685f6c8f3f76ac6f5">bm::bit_andnot_arr_ffmask</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga4478e86267ae5b2685f6c8f3f76ac6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitblock AND NOT with constant ~0 mask operation.  <a href="group__bitfunc.html#ga4478e86267ae5b2685f6c8f3f76ac6f5">More...</a><br /></td></tr>
<tr class="separator:ga4478e86267ae5b2685f6c8f3f76ac6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179de722e87ccf8189d975ca6beed025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga179de722e87ccf8189d975ca6beed025">bm::bit_operation_xor</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dst, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src)</td></tr>
<tr class="memdesc:ga179de722e87ccf8189d975ca6beed025"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitblock XOR operation.  <a href="group__bitfunc.html#ga179de722e87ccf8189d975ca6beed025">More...</a><br /></td></tr>
<tr class="separator:ga179de722e87ccf8189d975ca6beed025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf82c886ea7f558005f2fc533c310967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaaf82c886ea7f558005f2fc533c310967">bm::bit_operation_xor_count</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:gaaf82c886ea7f558005f2fc533c310967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock XOR operation and calculates bitcount of the result.  <a href="group__bitfunc.html#gaaf82c886ea7f558005f2fc533c310967">More...</a><br /></td></tr>
<tr class="separator:gaaf82c886ea7f558005f2fc533c310967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3870f6d7afb1e90780ab9d392d7a9e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga3870f6d7afb1e90780ab9d392d7a9e3c">bm::bit_operation_xor_any</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src2)</td></tr>
<tr class="memdesc:ga3870f6d7afb1e90780ab9d392d7a9e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitblock XOR operation test.  <a href="group__bitfunc.html#ga3870f6d7afb1e90780ab9d392d7a9e3c">More...</a><br /></td></tr>
<tr class="separator:ga3870f6d7afb1e90780ab9d392d7a9e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b269fca6c4830c6d70dfad5c0cc146"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga40b269fca6c4830c6d70dfad5c0cc146"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga40b269fca6c4830c6d70dfad5c0cc146">bm::bit_count_nonzero_size</a> (const T *blk, unsigned data_size)</td></tr>
<tr class="memdesc:ga40b269fca6c4830c6d70dfad5c0cc146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspects block for full zero words.  <a href="group__bitfunc.html#ga40b269fca6c4830c6d70dfad5c0cc146">More...</a><br /></td></tr>
<tr class="separator:ga40b269fca6c4830c6d70dfad5c0cc146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a7c549a625df7aa7d68d43a57238c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gad6a7c549a625df7aa7d68d43a57238c7">bm::bit_find_in_block</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *data, unsigned nbit, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr class="memdesc:gad6a7c549a625df7aa7d68d43a57238c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the next 1 bit in the BIT block.  <a href="group__bitfunc.html#gad6a7c549a625df7aa7d68d43a57238c7">More...</a><br /></td></tr>
<tr class="separator:gad6a7c549a625df7aa7d68d43a57238c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06df97bb9e876e64d276d0b1fd8349e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#gaf06df97bb9e876e64d276d0b1fd8349e">bm::bit_find_last</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, unsigned *last)</td></tr>
<tr class="memdesc:gaf06df97bb9e876e64d276d0b1fd8349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">BIT block find the last set bit (backward search)  <a href="group__bitfunc.html#gaf06df97bb9e876e64d276d0b1fd8349e">More...</a><br /></td></tr>
<tr class="separator:gaf06df97bb9e876e64d276d0b1fd8349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f8929a061434ea8e7a3ea589e83420"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga22f8929a061434ea8e7a3ea589e83420">bm::bit_find_first</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, unsigned *first)</td></tr>
<tr class="memdesc:ga22f8929a061434ea8e7a3ea589e83420"><td class="mdescLeft">&#160;</td><td class="mdescRight">BIT block find the first set bit.  <a href="group__bitfunc.html#ga22f8929a061434ea8e7a3ea589e83420">More...</a><br /></td></tr>
<tr class="separator:ga22f8929a061434ea8e7a3ea589e83420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7748766faa92554bcadb744918f928"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga8d7748766faa92554bcadb744918f928">bm::bit_find_first</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, unsigned *first, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga8d7748766faa92554bcadb744918f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">BIT block find the first set bit.  <a href="group__bitfunc.html#ga8d7748766faa92554bcadb744918f928">More...</a><br /></td></tr>
<tr class="separator:ga8d7748766faa92554bcadb744918f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e029cc066746d42f097608b5687a918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga2e029cc066746d42f097608b5687a918">bm::bit_find_first_if_1</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, unsigned *first, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> digest)</td></tr>
<tr class="memdesc:ga2e029cc066746d42f097608b5687a918"><td class="mdescLeft">&#160;</td><td class="mdescRight">BIT block find the first set bit if only 1 bit is set.  <a href="group__bitfunc.html#ga2e029cc066746d42f097608b5687a918">More...</a><br /></td></tr>
<tr class="separator:ga2e029cc066746d42f097608b5687a918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f38cdf5352e5d3e85df38274050966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga88f38cdf5352e5d3e85df38274050966">bm::bit_find_rank</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> rank, unsigned nbit_from, unsigned &amp;nbit_pos)</td></tr>
<tr class="memdesc:ga88f38cdf5352e5d3e85df38274050966"><td class="mdescLeft">&#160;</td><td class="mdescRight">BIT block find position for the rank.  <a href="group__bitfunc.html#ga88f38cdf5352e5d3e85df38274050966">More...</a><br /></td></tr>
<tr class="separator:ga88f38cdf5352e5d3e85df38274050966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c35e0a4738c87fa6712790c32ef77b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a7c35e0a4738c87fa6712790c32ef77b9">bm::block_find_rank</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *const block, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> rank, unsigned nbit_from, unsigned &amp;nbit_pos)</td></tr>
<tr class="memdesc:a7c35e0a4738c87fa6712790c32ef77b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find rank in block (GAP or BIT)  <a href="namespacebm.html#a7c35e0a4738c87fa6712790c32ef77b9">More...</a><br /></td></tr>
<tr class="separator:a7c35e0a4738c87fa6712790c32ef77b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20610fae6b0de84957b74ed17429667f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a593916a103395805070a3200720c6416">bm::set_representation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga20610fae6b0de84957b74ed17429667f">bm::best_representation</a> (unsigned bit_count, unsigned total_possible_bitcount, unsigned gap_count, unsigned block_size)</td></tr>
<tr class="memdesc:ga20610fae6b0de84957b74ed17429667f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose best representation for a bit-block.  <a href="group__bitfunc.html#ga20610fae6b0de84957b74ed17429667f">More...</a><br /></td></tr>
<tr class="separator:ga20610fae6b0de84957b74ed17429667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12da51133516aac030d828842f4a27be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga12da51133516aac030d828842f4a27be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga12da51133516aac030d828842f4a27be">bm::bit_convert_to_arr</a> (T *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> dest, const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> src, <a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len, unsigned mask=0)</td></tr>
<tr class="memdesc:ga12da51133516aac030d828842f4a27be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="group__bitfunc.html#ga12da51133516aac030d828842f4a27be">More...</a><br /></td></tr>
<tr class="separator:ga12da51133516aac030d828842f4a27be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcd5d4e92ac96bf3851847ddd089614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#acdcd5d4e92ac96bf3851847ddd089614">bm::check_block_zero</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, bool deep_scan)</td></tr>
<tr class="memdesc:acdcd5d4e92ac96bf3851847ddd089614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all conditions and returns true if block consists of only 0 bits.  <a href="namespacebm.html#acdcd5d4e92ac96bf3851847ddd089614">More...</a><br /></td></tr>
<tr class="separator:acdcd5d4e92ac96bf3851847ddd089614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad074ada5eb5c60ed7deed8d970647489"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ad074ada5eb5c60ed7deed8d970647489">bm::check_block_one</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, bool deep_scan)</td></tr>
<tr class="memdesc:ad074ada5eb5c60ed7deed8d970647489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if block has only 1 bits.  <a href="namespacebm.html#ad074ada5eb5c60ed7deed8d970647489">More...</a><br /></td></tr>
<tr class="separator:ad074ada5eb5c60ed7deed8d970647489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa029c18363842b7c534e8c1b806cfc49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa029c18363842b7c534e8c1b806cfc49"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#gaa029c18363842b7c534e8c1b806cfc49">bm::gap_overhead</a> (const T *length, const T *length_end, const T *glevel_len)</td></tr>
<tr class="memdesc:gaa029c18363842b7c534e8c1b806cfc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates memory overhead for number of gap blocks sharing the same memory allocation table (level lengths table).  <a href="group__gapfunc.html#gaa029c18363842b7c534e8c1b806cfc49">More...</a><br /></td></tr>
<tr class="separator:gaa029c18363842b7c534e8c1b806cfc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gapfunc.html#ga2f4f5fdc0cf7a989e0eb0faeb7eb851d">bm::improve_gap_levels</a> (const T *length, const T *length_end, T *glevel_len)</td></tr>
<tr class="memdesc:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds optimal gap blocks lengths.  <a href="group__gapfunc.html#ga2f4f5fdc0cf7a989e0eb0faeb7eb851d">More...</a><br /></td></tr>
<tr class="separator:ga2f4f5fdc0cf7a989e0eb0faeb7eb851d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e8add24e2879da0c53a52da370a6d4"><td class="memTemplParams" colspan="2">template&lt;class It1 , class It2 , class BinaryOp , class Encoder &gt; </td></tr>
<tr class="memitem:a09e8add24e2879da0c53a52da370a6d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebm.html#a09e8add24e2879da0c53a52da370a6d4">bm::bit_recomb</a> (It1 &amp;it1, It2 &amp;it2, BinaryOp &amp;op, Encoder &amp;enc, unsigned block_size=<a class="el" href="namespacebm.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>)</td></tr>
<tr class="separator:a09e8add24e2879da0c53a52da370a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024e86d22f5d82ab70df671ab998412f"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga024e86d22f5d82ab70df671ab998412f">bm::bitscan_wave</a> (const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *w_ptr, unsigned char *bits)</td></tr>
<tr class="memdesc:ga024e86d22f5d82ab70df671ab998412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks word wave (Nx 32-bit words)  <a href="group__bitfunc.html#ga024e86d22f5d82ab70df671ab998412f">More...</a><br /></td></tr>
<tr class="separator:ga024e86d22f5d82ab70df671ab998412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668f6e31c43050e966f9d97e09a1efc9"><td class="memTemplParams" colspan="2">template&lt;typename TRGW , typename IDX , typename SZ &gt; </td></tr>
<tr class="memitem:ga668f6e31c43050e966f9d97e09a1efc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitfunc.html#ga668f6e31c43050e966f9d97e09a1efc9">bm::bit_block_gather_scatter</a> (TRGW *arr, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const IDX *idx, SZ size, unsigned start, unsigned bit_idx)</td></tr>
<tr class="memdesc:ga668f6e31c43050e966f9d97e09a1efc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit index to word gather-scatter algorithm  <a href="group__bitfunc.html#ga668f6e31c43050e966f9d97e09a1efc9">More...</a><br /></td></tr>
<tr class="separator:ga668f6e31c43050e966f9d97e09a1efc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cbf0a602ffdc1d2548e5edb48ef29a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a03cbf0a602ffdc1d2548e5edb48ef29a">bm::idx_arr_block_lookup</a> (const unsigned *idx, unsigned size, unsigned nb, unsigned start)</td></tr>
<tr class="memdesc:a03cbf0a602ffdc1d2548e5edb48ef29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">block boundaries look ahead  <a href="namespacebm.html#a03cbf0a602ffdc1d2548e5edb48ef29a">More...</a><br /></td></tr>
<tr class="separator:a03cbf0a602ffdc1d2548e5edb48ef29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae195142bd5e38879b4e1d481d324d144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ae195142bd5e38879b4e1d481d324d144">bm::set_block_bits</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> block, const unsigned *<a class="el" href="bmdef_8h.html#a3d4b22f50e6783522689451783907dc7">BMRESTRICT</a> idx, unsigned start, unsigned stop)</td></tr>
<tr class="memdesc:ae195142bd5e38879b4e1d481d324d144"><td class="mdescLeft">&#160;</td><td class="mdescRight">set bits in a bit-block using global index  <a href="namespacebm.html#ae195142bd5e38879b4e1d481d324d144">More...</a><br /></td></tr>
<tr class="separator:ae195142bd5e38879b4e1d481d324d144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5beeeed539ccf2da6b8fac8157d94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a9cf5beeeed539ccf2da6b8fac8157d94">bm::block_ptr_array_range</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> **arr, unsigned &amp;left, unsigned &amp;right)</td></tr>
<tr class="memdesc:a9cf5beeeed539ccf2da6b8fac8157d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">array range detector   <a href="namespacebm.html#a9cf5beeeed539ccf2da6b8fac8157d94">More...</a><br /></td></tr>
<tr class="separator:a9cf5beeeed539ccf2da6b8fac8157d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bac30ca2178ca5f45a8d2571898cb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ad04bac30ca2178ca5f45a8d2571898cb">bm::lower_bound_linear</a> (const unsigned *arr, unsigned target, unsigned from, unsigned to)</td></tr>
<tr class="memdesc:ad04bac30ca2178ca5f45a8d2571898cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear lower bound search in unsigned array.  <a href="namespacebm.html#ad04bac30ca2178ca5f45a8d2571898cb">More...</a><br /></td></tr>
<tr class="separator:ad04bac30ca2178ca5f45a8d2571898cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9134acef95e79cca3f711fbca4e38c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#afa9134acef95e79cca3f711fbca4e38c">bm::lower_bound</a> (const unsigned *arr, unsigned target, unsigned from, unsigned to)</td></tr>
<tr class="memdesc:afa9134acef95e79cca3f711fbca4e38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid, binary-linear lower bound search in unsigned array.  <a href="namespacebm.html#afa9134acef95e79cca3f711fbca4e38c">More...</a><br /></td></tr>
<tr class="separator:afa9134acef95e79cca3f711fbca4e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8389e24f4973b129692f9189fbcc377e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#a8389e24f4973b129692f9189fbcc377e">bm::block_to_global_index</a> (unsigned i, unsigned j, unsigned block_idx)</td></tr>
<tr class="memdesc:a8389e24f4973b129692f9189fbcc377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate <a class="el" href="classbm_1_1bvector.html">bvector&lt;&gt;</a> global bit-index from block-local coords  <a href="namespacebm.html#a8389e24f4973b129692f9189fbcc377e">More...</a><br /></td></tr>
<tr class="separator:a8389e24f4973b129692f9189fbcc377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab707ca0e26b1253cc7afe23a7c205b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#aab707ca0e26b1253cc7afe23a7c205b0">bm::ptrp_test</a> (ptr_payload_t ptr, <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> v)</td></tr>
<tr class="separator:aab707ca0e26b1253cc7afe23a7c205b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac0d07dd348f558970535943491b9e435"><td class="memItemLeft" align="right" valign="top">const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebm.html#ac0d07dd348f558970535943491b9e435">bm::set_bitscan_wave_size</a> = 2</td></tr>
<tr class="separator:ac0d07dd348f558970535943491b9e435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Bit manipulation primitives (internal) </p>

<p class="definition">Definition in file <a class="el" href="bmfunc_8h_source.html">bmfunc.h</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
